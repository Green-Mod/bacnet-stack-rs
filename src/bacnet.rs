/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const BACNET_UNSIGNED_INTEGER_MAX: i32 = -1;
pub const BBMD_ENABLED: u32 = 1;
pub const MAX_NUM_DEVICES: u32 = 1;
pub const BACNET_VENDOR_ID: u32 = 260;
pub const BACNET_VENDOR_NAME: &[u8; 28usize] = b"BACnet Stack at SourceForge\0";
pub const MAX_APDU: u32 = 1476;
pub const MAX_TSM_TRANSACTIONS: u32 = 255;
pub const MAX_ADDRESS_CACHE: u32 = 255;
pub const PRINT_ENABLED: u32 = 0;
pub const MAX_BITSTRING_BYTES: u32 = 15;
pub const MAX_CHARACTER_STRING_BYTES: u32 = 1470;
pub const MAX_OCTET_STRING_BYTES: u32 = 1470;
pub const BACNET_SVC_I_HAVE_A: u32 = 1;
pub const BACNET_SVC_WP_A: u32 = 1;
pub const BACNET_SVC_RP_A: u32 = 1;
pub const BACNET_SVC_RPM_A: u32 = 1;
pub const BACNET_SVC_DCC_A: u32 = 1;
pub const BACNET_SVC_RD_A: u32 = 1;
pub const BACNET_SVC_TS_A: u32 = 1;
pub const BACNET_SVC_SERVER: u32 = 0;
pub const BACNET_USE_OCTETSTRING: u32 = 1;
pub const BACNET_USE_DOUBLE: u32 = 1;
pub const BACNET_USE_SIGNED: u32 = 1;
pub const BACNET_PROTOCOL_VERSION: u32 = 1;
pub const BACNET_PROTOCOL_REVISION: u32 = 24;
pub const MAX_ASHRAE_OBJECT_TYPE: u32 = 65;
pub const MAX_BACNET_SERVICES_SUPPORTED: u32 = 47;
pub const BACNET_MAX_INSTANCE: u32 = 4194303;
pub const BACNET_INSTANCE_BITS: u32 = 22;
pub const BACNET_MAX_OBJECT: u32 = 1023;
pub const BACNET_ARRAY_ALL: u32 = 4294967295;
pub const BACNET_NO_DEV_ID: u32 = 4294967295;
pub const BACNET_NO_PRIORITY: u32 = 0;
pub const BACNET_MIN_PRIORITY: u32 = 1;
pub const BACNET_MAX_PRIORITY: u32 = 16;
pub const BACNET_BROADCAST_NETWORK: u32 = 65535;
pub const MAX_MAC_LEN: u32 = 7;
pub const MAX_NPDU: u32 = 26;
pub const MAX_PDU: u32 = 1502;
pub const BACNET_STATUS_OK: u32 = 0;
pub const BACNET_STATUS_ERROR: i32 = -1;
pub const BACNET_STATUS_ABORT: i32 = -2;
pub const BACNET_STATUS_REJECT: i32 = -3;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 130300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const BACNET_DATE_YEAR_EPOCH: u32 = 1900;
pub const BACNET_COLOR_FADE_TIME_MIN: u32 = 100;
pub const BACNET_COLOR_FADE_TIME_MAX: u32 = 86400000;
pub const BACNET_COLOR_RAMP_RATE_MIN: u32 = 1;
pub const BACNET_COLOR_RAMP_RATE_MAX: u32 = 30000;
pub const BACNET_COLOR_STEP_INCREMENT_MIN: u32 = 1;
pub const BACNET_COLOR_STEP_INCREMENT_MAX: u32 = 30000;
pub const HOP_COUNT_DEFAULT: u32 = 255;
pub const ROUTER_PORT_INFO_LEN: u32 = 2;
pub const NETWORK_NUMBER_LEARNED: u32 = 0;
pub const NETWORK_NUMBER_CONFIGURED: u32 = 1;
pub const BVLL_TYPE_BACNET_IP: u32 = 129;
pub const BVLC_RESULT: u32 = 0;
pub const BVLC_WRITE_BROADCAST_DISTRIBUTION_TABLE: u32 = 1;
pub const BVLC_READ_BROADCAST_DIST_TABLE: u32 = 2;
pub const BVLC_READ_BROADCAST_DIST_TABLE_ACK: u32 = 3;
pub const BVLC_FORWARDED_NPDU: u32 = 4;
pub const BVLC_REGISTER_FOREIGN_DEVICE: u32 = 5;
pub const BVLC_READ_FOREIGN_DEVICE_TABLE: u32 = 6;
pub const BVLC_READ_FOREIGN_DEVICE_TABLE_ACK: u32 = 7;
pub const BVLC_DELETE_FOREIGN_DEVICE_TABLE_ENTRY: u32 = 8;
pub const BVLC_DISTRIBUTE_BROADCAST_TO_NETWORK: u32 = 9;
pub const BVLC_ORIGINAL_UNICAST_NPDU: u32 = 10;
pub const BVLC_ORIGINAL_BROADCAST_NPDU: u32 = 11;
pub const BVLC_SECURE_BVLL: u32 = 12;
pub const BVLC_INVALID: u32 = 255;
pub const BVLC_RESULT_SUCCESSFUL_COMPLETION: u32 = 0;
pub const BVLC_RESULT_WRITE_BROADCAST_DISTRIBUTION_TABLE_NAK: u32 = 16;
pub const BVLC_RESULT_READ_BROADCAST_DISTRIBUTION_TABLE_NAK: u32 = 32;
pub const BVLC_RESULT_REGISTER_FOREIGN_DEVICE_NAK: u32 = 48;
pub const BVLC_RESULT_READ_FOREIGN_DEVICE_TABLE_NAK: u32 = 64;
pub const BVLC_RESULT_DELETE_FOREIGN_DEVICE_TABLE_ENTRY_NAK: u32 = 80;
pub const BVLC_RESULT_DISTRIBUTE_BROADCAST_TO_NETWORK_NAK: u32 = 96;
pub const BVLC_RESULT_INVALID: u32 = 65535;
pub const IP_ADDRESS_MAX: u32 = 4;
pub const BIP_ADDRESS_MAX: u32 = 6;
pub const BACNET_IP_BDT_MASK_SIZE: u32 = 4;
pub const BACNET_IP_BDT_ENTRY_SIZE: u32 = 10;
pub const BACNET_IP_FDT_ENTRY_SIZE: u32 = 10;
pub const FP_NAN: u32 = 1;
pub const FP_INFINITE: u32 = 2;
pub const FP_ZERO: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const FP_SUBNORMAL: u32 = 5;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: u32 = 1;
pub const FP_QNAN: u32 = 1;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const MAX_DAY_SCHEDULE_VALUES: u32 = 40;
pub const BACNET_READ_FILE_RECORD_COUNT: u32 = 1;
pub const BACNET_WRITE_FILE_RECORD_COUNT: u32 = 1;
pub const __HAS_FIXED_CHK_PROTOTYPES: u32 = 1;
pub const BACNET_DECODE_COMPLEX_EVENT_TYPE_PARAMETERS: u32 = 1;
pub const BACNET_COMPLEX_EVENT_TYPE_MAX_PARAMETERS: u32 = 5;
pub const RR_BY_POSITION: u32 = 1;
pub const RR_BY_SEQUENCE: u32 = 2;
pub const RR_BY_TIME: u32 = 4;
pub const RR_READ_ALL: u32 = 8;
pub const RR_ARRAY_OF_LISTS: u32 = 16;
pub const RR_OVERHEAD: u32 = 16;
pub const RR_1ST_SEQ_OVERHEAD: u32 = 5;
pub const RR_INDEX_OVERHEAD: u32 = 3;
pub const BACNET_VERSION_TEXT: &[u8; 6usize] = b"1.0.0\0";
pub const ARCNET_HEADER_MAX: u32 = 10;
pub const ARCNET_MPDU_MAX: u32 = 1512;
pub const MAX_AUTH_DATA_LEN: u32 = 16;
pub const MD5_KEY_SIZE: u32 = 16;
pub const AES_KEY_SIZE: u32 = 16;
pub const SHA256_KEY_SIZE: u32 = 32;
pub const MAX_KEY_LEN: u32 = 48;
pub const MAX_UPDATE_KEY_COUNT: u32 = 32;
pub const MAX_INCORRECT_KEYS: u32 = 255;
pub const MAX_SUPPORTED_ALGORITHMS: u32 = 255;
pub const MAX_PAD_LEN: u32 = 16;
pub const SIGNATURE_LEN: u32 = 16;
pub const BIP_HEADER_MAX: u32 = 4;
pub const BIP_MPDU_MAX: u32 = 1506;
pub const BVLL_TYPE_BACNET_IP6: u32 = 130;
pub const BVLC6_RESULT: u32 = 0;
pub const BVLC6_ORIGINAL_UNICAST_NPDU: u32 = 1;
pub const BVLC6_ORIGINAL_BROADCAST_NPDU: u32 = 2;
pub const BVLC6_ADDRESS_RESOLUTION: u32 = 3;
pub const BVLC6_FORWARDED_ADDRESS_RESOLUTION: u32 = 4;
pub const BVLC6_ADDRESS_RESOLUTION_ACK: u32 = 5;
pub const BVLC6_VIRTUAL_ADDRESS_RESOLUTION: u32 = 6;
pub const BVLC6_VIRTUAL_ADDRESS_RESOLUTION_ACK: u32 = 7;
pub const BVLC6_FORWARDED_NPDU: u32 = 8;
pub const BVLC6_REGISTER_FOREIGN_DEVICE: u32 = 9;
pub const BVLC6_DELETE_FOREIGN_DEVICE: u32 = 10;
pub const BVLC6_SECURE_BVLL: u32 = 11;
pub const BVLC6_DISTRIBUTE_BROADCAST_TO_NETWORK: u32 = 12;
pub const BVLC6_RESULT_SUCCESSFUL_COMPLETION: u32 = 0;
pub const BVLC6_RESULT_ADDRESS_RESOLUTION_NAK: u32 = 48;
pub const BVLC6_RESULT_VIRTUAL_ADDRESS_RESOLUTION_NAK: u32 = 96;
pub const BVLC6_RESULT_REGISTER_FOREIGN_DEVICE_NAK: u32 = 144;
pub const BVLC6_RESULT_DELETE_FOREIGN_DEVICE_NAK: u32 = 160;
pub const BVLC6_RESULT_DISTRIBUTE_BROADCAST_TO_NETWORK_NAK: u32 = 192;
pub const BIP6_MULTICAST_GROUP_ID: u32 = 47808;
pub const BIP6_MULTICAST_reserved_0: u32 = 65280;
pub const BIP6_MULTICAST_NODE_LOCAL: u32 = 65281;
pub const BIP6_MULTICAST_LINK_LOCAL: u32 = 65282;
pub const BIP6_MULTICAST_reserved_3: u32 = 65283;
pub const BIP6_MULTICAST_ADMIN_LOCAL: u32 = 65284;
pub const BIP6_MULTICAST_SITE_LOCAL: u32 = 65285;
pub const BIP6_MULTICAST_ORG_LOCAL: u32 = 65288;
pub const BIP6_MULTICAST_GLOBAL: u32 = 65294;
pub const IP6_ADDRESS_MAX: u32 = 16;
pub const BIP6_ADDRESS_MAX: u32 = 18;
pub const BIP6_HEADER_MAX: u32 = 4;
pub const BIP6_MPDU_MAX: u32 = 1506;
pub const COBS_ENCODED_CRC_SIZE: u32 = 5;
pub const MAX_MPDU: u32 = 1506;
pub const DLMSTP_HEADER_MAX: u32 = 10;
pub const DLMSTP_MPDU_MAX: u32 = 1512;
pub const ETHERNET_HEADER_MAX: u32 = 17;
pub const ETHERNET_MPDU_MAX: u32 = 1519;
pub const MSTP_BROADCAST_ADDRESS: u32 = 255;
pub const FRAME_TYPE_TOKEN: u32 = 0;
pub const FRAME_TYPE_POLL_FOR_MASTER: u32 = 1;
pub const FRAME_TYPE_REPLY_TO_POLL_FOR_MASTER: u32 = 2;
pub const FRAME_TYPE_TEST_REQUEST: u32 = 3;
pub const FRAME_TYPE_TEST_RESPONSE: u32 = 4;
pub const FRAME_TYPE_BACNET_DATA_EXPECTING_REPLY: u32 = 5;
pub const FRAME_TYPE_BACNET_DATA_NOT_EXPECTING_REPLY: u32 = 6;
pub const FRAME_TYPE_REPLY_POSTPONED: u32 = 7;
pub const FRAME_TYPE_BACNET_EXTENDED_DATA_EXPECTING_REPLY: u32 = 32;
pub const FRAME_TYPE_BACNET_EXTENDED_DATA_NOT_EXPECTING_REPLY: u32 = 33;
pub const FRAME_TYPE_IPV6_ENCAPSULATION: u32 = 34;
pub const FRAME_TYPE_PROPRIETARY_MIN: u32 = 128;
pub const FRAME_TYPE_PROPRIETARY_MAX: u32 = 255;
pub const CRC16_INITIAL_VALUE: u32 = 65535;
pub const CRC32K_INITIAL_VALUE: u32 = 4294967295;
pub const CRC32K_RESIDUE: u32 = 138621499;
pub const MSTP_PREAMBLE_X55: u32 = 85;
pub const MSTP_EXTENDED_FRAME_NPDU_MAX: u32 = 1497;
pub const Tno_token: u32 = 500;
pub const Tturnaround: u32 = 40;
pub const Npoll: u32 = 50;
pub const Nretry_token: u32 = 1;
pub const Tframe_gap: u32 = 20;
pub const Tpostdrive: u32 = 15;
pub const Tslot: u32 = 10;
pub const Tusage_delay: u32 = 15;
pub const DEFAULT_MAX_INFO_FRAMES: u32 = 1;
pub const DEFAULT_MAX_MASTER: u32 = 127;
pub const DEFAULT_MAC_ADDRESS: u32 = 127;
pub const VMAC_MAC_MAX: u32 = 18;
pub const BACNET_BIG_ENDIAN: u32 = 0;
pub const DEBUG_ENABLED: u32 = 0;
pub const KEY_TYPE_OFFSET: u32 = 22;
pub const KEY_TYPE_MASK: u32 = 1023;
pub const KEY_ID_MASK: u32 = 4194303;
pub const KEY_ID_MAX: u32 = 4194304;
pub const KEY_TYPE_MAX: u32 = 1024;
pub const MAX_ACCESS_CREDENTIALS: u32 = 4;
pub const MAX_REASONS_FOR_DISABLE: u32 = 4;
pub const MAX_AUTHENTICATION_FACTORS: u32 = 4;
pub const MAX_ASSIGNED_ACCESS_RIGHTS: u32 = 4;
pub const MAX_ACCESS_DOORS: u32 = 4;
pub const MAX_ACCESS_POINTS: u32 = 4;
pub const MAX_ACCESS_DOORS_COUNT: u32 = 4;
pub const MAX_ACCESS_RIGHTSS: u32 = 4;
pub const MAX_NEGATIVE_ACCESS_RIGHTS_RULES: u32 = 4;
pub const MAX_POSITIVE_ACCESS_RIGHTS_RULES: u32 = 4;
pub const MAX_ACCESS_USERS: u32 = 4;
pub const MAX_ACCESS_USER_CREDENTIALS_COUNT: u32 = 4;
pub const MAX_ACCESS_ZONES: u32 = 4;
pub const MAX_ACCESS_ZONE_ENTRY_POINTS: u32 = 4;
pub const MAX_ACCESS_ZONE_EXIT_POINTS: u32 = 4;
pub const MAX_COMMANDS: u32 = 4;
pub const MAX_COMMAND_ACTIONS: u32 = 8;
pub const MAX_CREDENTIAL_DATA_INPUTS: u32 = 4;
pub const MAX_AUTHENTICATION_FACTOR_FORMAT_COUNT: u32 = 4;
pub const MAX_DEV_NAME_LEN: u32 = 32;
pub const MAX_DEV_LOC_LEN: u32 = 64;
pub const MAX_DEV_MOD_LEN: u32 = 32;
pub const MAX_DEV_VER_LEN: u32 = 16;
pub const MAX_DEV_DESC_LEN: u32 = 64;
pub const NC_RESCAN_RECIPIENTS_SECS: u32 = 60;
pub const NC_MAX_RECIPIENTS: u32 = 10;
pub const BACNET_WEEKLY_SCHEDULE_SIZE: u32 = 8;
pub const BACNET_SCHEDULE_OBJ_PROP_REF_SIZE: u32 = 4;
pub const TL_T_START_WILD: u32 = 1;
pub const TL_T_STOP_WILD: u32 = 2;
pub const TL_MAX_ENTRIES: u32 = 1000;
pub const TL_TYPE_STATUS: u32 = 0;
pub const TL_TYPE_BOOL: u32 = 1;
pub const TL_TYPE_REAL: u32 = 2;
pub const TL_TYPE_ENUM: u32 = 3;
pub const TL_TYPE_UNSIGN: u32 = 4;
pub const TL_TYPE_SIGN: u32 = 5;
pub const TL_TYPE_BITS: u32 = 6;
pub const TL_TYPE_NULL: u32 = 7;
pub const TL_TYPE_ERROR: u32 = 8;
pub const TL_TYPE_DELTA: u32 = 9;
pub const TL_TYPE_ANY: u32 = 10;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub const BACNET_PROPERTY_ID_PROP_ACKED_TRANSITIONS: BACNET_PROPERTY_ID = 0;
pub const BACNET_PROPERTY_ID_PROP_ACK_REQUIRED: BACNET_PROPERTY_ID = 1;
pub const BACNET_PROPERTY_ID_PROP_ACTION: BACNET_PROPERTY_ID = 2;
pub const BACNET_PROPERTY_ID_PROP_ACTION_TEXT: BACNET_PROPERTY_ID = 3;
pub const BACNET_PROPERTY_ID_PROP_ACTIVE_TEXT: BACNET_PROPERTY_ID = 4;
pub const BACNET_PROPERTY_ID_PROP_ACTIVE_VT_SESSIONS: BACNET_PROPERTY_ID = 5;
pub const BACNET_PROPERTY_ID_PROP_ALARM_VALUE: BACNET_PROPERTY_ID = 6;
pub const BACNET_PROPERTY_ID_PROP_ALARM_VALUES: BACNET_PROPERTY_ID = 7;
pub const BACNET_PROPERTY_ID_PROP_ALL: BACNET_PROPERTY_ID = 8;
pub const BACNET_PROPERTY_ID_PROP_ALL_WRITES_SUCCESSFUL: BACNET_PROPERTY_ID = 9;
pub const BACNET_PROPERTY_ID_PROP_APDU_SEGMENT_TIMEOUT: BACNET_PROPERTY_ID = 10;
pub const BACNET_PROPERTY_ID_PROP_APDU_TIMEOUT: BACNET_PROPERTY_ID = 11;
pub const BACNET_PROPERTY_ID_PROP_APPLICATION_SOFTWARE_VERSION: BACNET_PROPERTY_ID = 12;
pub const BACNET_PROPERTY_ID_PROP_ARCHIVE: BACNET_PROPERTY_ID = 13;
pub const BACNET_PROPERTY_ID_PROP_BIAS: BACNET_PROPERTY_ID = 14;
pub const BACNET_PROPERTY_ID_PROP_CHANGE_OF_STATE_COUNT: BACNET_PROPERTY_ID = 15;
pub const BACNET_PROPERTY_ID_PROP_CHANGE_OF_STATE_TIME: BACNET_PROPERTY_ID = 16;
pub const BACNET_PROPERTY_ID_PROP_NOTIFICATION_CLASS: BACNET_PROPERTY_ID = 17;
pub const BACNET_PROPERTY_ID_PROP_BLANK_1: BACNET_PROPERTY_ID = 18;
pub const BACNET_PROPERTY_ID_PROP_CONTROLLED_VARIABLE_REFERENCE: BACNET_PROPERTY_ID = 19;
pub const BACNET_PROPERTY_ID_PROP_CONTROLLED_VARIABLE_UNITS: BACNET_PROPERTY_ID = 20;
pub const BACNET_PROPERTY_ID_PROP_CONTROLLED_VARIABLE_VALUE: BACNET_PROPERTY_ID = 21;
pub const BACNET_PROPERTY_ID_PROP_COV_INCREMENT: BACNET_PROPERTY_ID = 22;
pub const BACNET_PROPERTY_ID_PROP_DATE_LIST: BACNET_PROPERTY_ID = 23;
pub const BACNET_PROPERTY_ID_PROP_DAYLIGHT_SAVINGS_STATUS: BACNET_PROPERTY_ID = 24;
pub const BACNET_PROPERTY_ID_PROP_DEADBAND: BACNET_PROPERTY_ID = 25;
pub const BACNET_PROPERTY_ID_PROP_DERIVATIVE_CONSTANT: BACNET_PROPERTY_ID = 26;
pub const BACNET_PROPERTY_ID_PROP_DERIVATIVE_CONSTANT_UNITS: BACNET_PROPERTY_ID = 27;
pub const BACNET_PROPERTY_ID_PROP_DESCRIPTION: BACNET_PROPERTY_ID = 28;
pub const BACNET_PROPERTY_ID_PROP_DESCRIPTION_OF_HALT: BACNET_PROPERTY_ID = 29;
pub const BACNET_PROPERTY_ID_PROP_DEVICE_ADDRESS_BINDING: BACNET_PROPERTY_ID = 30;
pub const BACNET_PROPERTY_ID_PROP_DEVICE_TYPE: BACNET_PROPERTY_ID = 31;
pub const BACNET_PROPERTY_ID_PROP_EFFECTIVE_PERIOD: BACNET_PROPERTY_ID = 32;
pub const BACNET_PROPERTY_ID_PROP_ELAPSED_ACTIVE_TIME: BACNET_PROPERTY_ID = 33;
pub const BACNET_PROPERTY_ID_PROP_ERROR_LIMIT: BACNET_PROPERTY_ID = 34;
pub const BACNET_PROPERTY_ID_PROP_EVENT_ENABLE: BACNET_PROPERTY_ID = 35;
pub const BACNET_PROPERTY_ID_PROP_EVENT_STATE: BACNET_PROPERTY_ID = 36;
pub const BACNET_PROPERTY_ID_PROP_EVENT_TYPE: BACNET_PROPERTY_ID = 37;
pub const BACNET_PROPERTY_ID_PROP_EXCEPTION_SCHEDULE: BACNET_PROPERTY_ID = 38;
pub const BACNET_PROPERTY_ID_PROP_FAULT_VALUES: BACNET_PROPERTY_ID = 39;
pub const BACNET_PROPERTY_ID_PROP_FEEDBACK_VALUE: BACNET_PROPERTY_ID = 40;
pub const BACNET_PROPERTY_ID_PROP_FILE_ACCESS_METHOD: BACNET_PROPERTY_ID = 41;
pub const BACNET_PROPERTY_ID_PROP_FILE_SIZE: BACNET_PROPERTY_ID = 42;
pub const BACNET_PROPERTY_ID_PROP_FILE_TYPE: BACNET_PROPERTY_ID = 43;
pub const BACNET_PROPERTY_ID_PROP_FIRMWARE_REVISION: BACNET_PROPERTY_ID = 44;
pub const BACNET_PROPERTY_ID_PROP_HIGH_LIMIT: BACNET_PROPERTY_ID = 45;
pub const BACNET_PROPERTY_ID_PROP_INACTIVE_TEXT: BACNET_PROPERTY_ID = 46;
pub const BACNET_PROPERTY_ID_PROP_IN_PROCESS: BACNET_PROPERTY_ID = 47;
pub const BACNET_PROPERTY_ID_PROP_INSTANCE_OF: BACNET_PROPERTY_ID = 48;
pub const BACNET_PROPERTY_ID_PROP_INTEGRAL_CONSTANT: BACNET_PROPERTY_ID = 49;
pub const BACNET_PROPERTY_ID_PROP_INTEGRAL_CONSTANT_UNITS: BACNET_PROPERTY_ID = 50;
pub const BACNET_PROPERTY_ID_PROP_ISSUE_CONFIRMED_NOTIFICATIONS: BACNET_PROPERTY_ID = 51;
pub const BACNET_PROPERTY_ID_PROP_LIMIT_ENABLE: BACNET_PROPERTY_ID = 52;
pub const BACNET_PROPERTY_ID_PROP_LIST_OF_GROUP_MEMBERS: BACNET_PROPERTY_ID = 53;
pub const BACNET_PROPERTY_ID_PROP_LIST_OF_OBJECT_PROPERTY_REFERENCES: BACNET_PROPERTY_ID = 54;
pub const BACNET_PROPERTY_ID_PROP_LIST_OF_SESSION_KEYS: BACNET_PROPERTY_ID = 55;
pub const BACNET_PROPERTY_ID_PROP_LOCAL_DATE: BACNET_PROPERTY_ID = 56;
pub const BACNET_PROPERTY_ID_PROP_LOCAL_TIME: BACNET_PROPERTY_ID = 57;
pub const BACNET_PROPERTY_ID_PROP_LOCATION: BACNET_PROPERTY_ID = 58;
pub const BACNET_PROPERTY_ID_PROP_LOW_LIMIT: BACNET_PROPERTY_ID = 59;
pub const BACNET_PROPERTY_ID_PROP_MANIPULATED_VARIABLE_REFERENCE: BACNET_PROPERTY_ID = 60;
pub const BACNET_PROPERTY_ID_PROP_MAXIMUM_OUTPUT: BACNET_PROPERTY_ID = 61;
pub const BACNET_PROPERTY_ID_PROP_MAX_APDU_LENGTH_ACCEPTED: BACNET_PROPERTY_ID = 62;
pub const BACNET_PROPERTY_ID_PROP_MAX_INFO_FRAMES: BACNET_PROPERTY_ID = 63;
pub const BACNET_PROPERTY_ID_PROP_MAX_MASTER: BACNET_PROPERTY_ID = 64;
pub const BACNET_PROPERTY_ID_PROP_MAX_PRES_VALUE: BACNET_PROPERTY_ID = 65;
pub const BACNET_PROPERTY_ID_PROP_MINIMUM_OFF_TIME: BACNET_PROPERTY_ID = 66;
pub const BACNET_PROPERTY_ID_PROP_MINIMUM_ON_TIME: BACNET_PROPERTY_ID = 67;
pub const BACNET_PROPERTY_ID_PROP_MINIMUM_OUTPUT: BACNET_PROPERTY_ID = 68;
pub const BACNET_PROPERTY_ID_PROP_MIN_PRES_VALUE: BACNET_PROPERTY_ID = 69;
pub const BACNET_PROPERTY_ID_PROP_MODEL_NAME: BACNET_PROPERTY_ID = 70;
pub const BACNET_PROPERTY_ID_PROP_MODIFICATION_DATE: BACNET_PROPERTY_ID = 71;
pub const BACNET_PROPERTY_ID_PROP_NOTIFY_TYPE: BACNET_PROPERTY_ID = 72;
pub const BACNET_PROPERTY_ID_PROP_NUMBER_OF_APDU_RETRIES: BACNET_PROPERTY_ID = 73;
pub const BACNET_PROPERTY_ID_PROP_NUMBER_OF_STATES: BACNET_PROPERTY_ID = 74;
pub const BACNET_PROPERTY_ID_PROP_OBJECT_IDENTIFIER: BACNET_PROPERTY_ID = 75;
pub const BACNET_PROPERTY_ID_PROP_OBJECT_LIST: BACNET_PROPERTY_ID = 76;
pub const BACNET_PROPERTY_ID_PROP_OBJECT_NAME: BACNET_PROPERTY_ID = 77;
pub const BACNET_PROPERTY_ID_PROP_OBJECT_PROPERTY_REFERENCE: BACNET_PROPERTY_ID = 78;
pub const BACNET_PROPERTY_ID_PROP_OBJECT_TYPE: BACNET_PROPERTY_ID = 79;
pub const BACNET_PROPERTY_ID_PROP_OPTIONAL: BACNET_PROPERTY_ID = 80;
pub const BACNET_PROPERTY_ID_PROP_OUT_OF_SERVICE: BACNET_PROPERTY_ID = 81;
pub const BACNET_PROPERTY_ID_PROP_OUTPUT_UNITS: BACNET_PROPERTY_ID = 82;
pub const BACNET_PROPERTY_ID_PROP_EVENT_PARAMETERS: BACNET_PROPERTY_ID = 83;
pub const BACNET_PROPERTY_ID_PROP_POLARITY: BACNET_PROPERTY_ID = 84;
pub const BACNET_PROPERTY_ID_PROP_PRESENT_VALUE: BACNET_PROPERTY_ID = 85;
pub const BACNET_PROPERTY_ID_PROP_PRIORITY: BACNET_PROPERTY_ID = 86;
pub const BACNET_PROPERTY_ID_PROP_PRIORITY_ARRAY: BACNET_PROPERTY_ID = 87;
pub const BACNET_PROPERTY_ID_PROP_PRIORITY_FOR_WRITING: BACNET_PROPERTY_ID = 88;
pub const BACNET_PROPERTY_ID_PROP_PROCESS_IDENTIFIER: BACNET_PROPERTY_ID = 89;
pub const BACNET_PROPERTY_ID_PROP_PROGRAM_CHANGE: BACNET_PROPERTY_ID = 90;
pub const BACNET_PROPERTY_ID_PROP_PROGRAM_LOCATION: BACNET_PROPERTY_ID = 91;
pub const BACNET_PROPERTY_ID_PROP_PROGRAM_STATE: BACNET_PROPERTY_ID = 92;
pub const BACNET_PROPERTY_ID_PROP_PROPORTIONAL_CONSTANT: BACNET_PROPERTY_ID = 93;
pub const BACNET_PROPERTY_ID_PROP_PROPORTIONAL_CONSTANT_UNITS: BACNET_PROPERTY_ID = 94;
pub const BACNET_PROPERTY_ID_PROP_PROTOCOL_CONFORMANCE_CLASS: BACNET_PROPERTY_ID = 95;
pub const BACNET_PROPERTY_ID_PROP_PROTOCOL_OBJECT_TYPES_SUPPORTED: BACNET_PROPERTY_ID = 96;
pub const BACNET_PROPERTY_ID_PROP_PROTOCOL_SERVICES_SUPPORTED: BACNET_PROPERTY_ID = 97;
pub const BACNET_PROPERTY_ID_PROP_PROTOCOL_VERSION: BACNET_PROPERTY_ID = 98;
pub const BACNET_PROPERTY_ID_PROP_READ_ONLY: BACNET_PROPERTY_ID = 99;
pub const BACNET_PROPERTY_ID_PROP_REASON_FOR_HALT: BACNET_PROPERTY_ID = 100;
pub const BACNET_PROPERTY_ID_PROP_RECIPIENT: BACNET_PROPERTY_ID = 101;
pub const BACNET_PROPERTY_ID_PROP_RECIPIENT_LIST: BACNET_PROPERTY_ID = 102;
pub const BACNET_PROPERTY_ID_PROP_RELIABILITY: BACNET_PROPERTY_ID = 103;
pub const BACNET_PROPERTY_ID_PROP_RELINQUISH_DEFAULT: BACNET_PROPERTY_ID = 104;
pub const BACNET_PROPERTY_ID_PROP_REQUIRED: BACNET_PROPERTY_ID = 105;
pub const BACNET_PROPERTY_ID_PROP_RESOLUTION: BACNET_PROPERTY_ID = 106;
pub const BACNET_PROPERTY_ID_PROP_SEGMENTATION_SUPPORTED: BACNET_PROPERTY_ID = 107;
pub const BACNET_PROPERTY_ID_PROP_SETPOINT: BACNET_PROPERTY_ID = 108;
pub const BACNET_PROPERTY_ID_PROP_SETPOINT_REFERENCE: BACNET_PROPERTY_ID = 109;
pub const BACNET_PROPERTY_ID_PROP_STATE_TEXT: BACNET_PROPERTY_ID = 110;
pub const BACNET_PROPERTY_ID_PROP_STATUS_FLAGS: BACNET_PROPERTY_ID = 111;
pub const BACNET_PROPERTY_ID_PROP_SYSTEM_STATUS: BACNET_PROPERTY_ID = 112;
pub const BACNET_PROPERTY_ID_PROP_TIME_DELAY: BACNET_PROPERTY_ID = 113;
pub const BACNET_PROPERTY_ID_PROP_TIME_OF_ACTIVE_TIME_RESET: BACNET_PROPERTY_ID = 114;
pub const BACNET_PROPERTY_ID_PROP_TIME_OF_STATE_COUNT_RESET: BACNET_PROPERTY_ID = 115;
pub const BACNET_PROPERTY_ID_PROP_TIME_SYNCHRONIZATION_RECIPIENTS: BACNET_PROPERTY_ID = 116;
pub const BACNET_PROPERTY_ID_PROP_UNITS: BACNET_PROPERTY_ID = 117;
pub const BACNET_PROPERTY_ID_PROP_UPDATE_INTERVAL: BACNET_PROPERTY_ID = 118;
pub const BACNET_PROPERTY_ID_PROP_UTC_OFFSET: BACNET_PROPERTY_ID = 119;
pub const BACNET_PROPERTY_ID_PROP_VENDOR_IDENTIFIER: BACNET_PROPERTY_ID = 120;
pub const BACNET_PROPERTY_ID_PROP_VENDOR_NAME: BACNET_PROPERTY_ID = 121;
pub const BACNET_PROPERTY_ID_PROP_VT_CLASSES_SUPPORTED: BACNET_PROPERTY_ID = 122;
pub const BACNET_PROPERTY_ID_PROP_WEEKLY_SCHEDULE: BACNET_PROPERTY_ID = 123;
pub const BACNET_PROPERTY_ID_PROP_ATTEMPTED_SAMPLES: BACNET_PROPERTY_ID = 124;
pub const BACNET_PROPERTY_ID_PROP_AVERAGE_VALUE: BACNET_PROPERTY_ID = 125;
pub const BACNET_PROPERTY_ID_PROP_BUFFER_SIZE: BACNET_PROPERTY_ID = 126;
pub const BACNET_PROPERTY_ID_PROP_CLIENT_COV_INCREMENT: BACNET_PROPERTY_ID = 127;
pub const BACNET_PROPERTY_ID_PROP_COV_RESUBSCRIPTION_INTERVAL: BACNET_PROPERTY_ID = 128;
pub const BACNET_PROPERTY_ID_PROP_CURRENT_NOTIFY_TIME: BACNET_PROPERTY_ID = 129;
pub const BACNET_PROPERTY_ID_PROP_EVENT_TIME_STAMPS: BACNET_PROPERTY_ID = 130;
pub const BACNET_PROPERTY_ID_PROP_LOG_BUFFER: BACNET_PROPERTY_ID = 131;
pub const BACNET_PROPERTY_ID_PROP_LOG_DEVICE_OBJECT_PROPERTY: BACNET_PROPERTY_ID = 132;
pub const BACNET_PROPERTY_ID_PROP_ENABLE: BACNET_PROPERTY_ID = 133;
pub const BACNET_PROPERTY_ID_PROP_LOG_INTERVAL: BACNET_PROPERTY_ID = 134;
pub const BACNET_PROPERTY_ID_PROP_MAXIMUM_VALUE: BACNET_PROPERTY_ID = 135;
pub const BACNET_PROPERTY_ID_PROP_MINIMUM_VALUE: BACNET_PROPERTY_ID = 136;
pub const BACNET_PROPERTY_ID_PROP_NOTIFICATION_THRESHOLD: BACNET_PROPERTY_ID = 137;
pub const BACNET_PROPERTY_ID_PROP_PREVIOUS_NOTIFY_TIME: BACNET_PROPERTY_ID = 138;
pub const BACNET_PROPERTY_ID_PROP_PROTOCOL_REVISION: BACNET_PROPERTY_ID = 139;
pub const BACNET_PROPERTY_ID_PROP_RECORDS_SINCE_NOTIFICATION: BACNET_PROPERTY_ID = 140;
pub const BACNET_PROPERTY_ID_PROP_RECORD_COUNT: BACNET_PROPERTY_ID = 141;
pub const BACNET_PROPERTY_ID_PROP_START_TIME: BACNET_PROPERTY_ID = 142;
pub const BACNET_PROPERTY_ID_PROP_STOP_TIME: BACNET_PROPERTY_ID = 143;
pub const BACNET_PROPERTY_ID_PROP_STOP_WHEN_FULL: BACNET_PROPERTY_ID = 144;
pub const BACNET_PROPERTY_ID_PROP_TOTAL_RECORD_COUNT: BACNET_PROPERTY_ID = 145;
pub const BACNET_PROPERTY_ID_PROP_VALID_SAMPLES: BACNET_PROPERTY_ID = 146;
pub const BACNET_PROPERTY_ID_PROP_WINDOW_INTERVAL: BACNET_PROPERTY_ID = 147;
pub const BACNET_PROPERTY_ID_PROP_WINDOW_SAMPLES: BACNET_PROPERTY_ID = 148;
pub const BACNET_PROPERTY_ID_PROP_MAXIMUM_VALUE_TIMESTAMP: BACNET_PROPERTY_ID = 149;
pub const BACNET_PROPERTY_ID_PROP_MINIMUM_VALUE_TIMESTAMP: BACNET_PROPERTY_ID = 150;
pub const BACNET_PROPERTY_ID_PROP_VARIANCE_VALUE: BACNET_PROPERTY_ID = 151;
pub const BACNET_PROPERTY_ID_PROP_ACTIVE_COV_SUBSCRIPTIONS: BACNET_PROPERTY_ID = 152;
pub const BACNET_PROPERTY_ID_PROP_BACKUP_FAILURE_TIMEOUT: BACNET_PROPERTY_ID = 153;
pub const BACNET_PROPERTY_ID_PROP_CONFIGURATION_FILES: BACNET_PROPERTY_ID = 154;
pub const BACNET_PROPERTY_ID_PROP_DATABASE_REVISION: BACNET_PROPERTY_ID = 155;
pub const BACNET_PROPERTY_ID_PROP_DIRECT_READING: BACNET_PROPERTY_ID = 156;
pub const BACNET_PROPERTY_ID_PROP_LAST_RESTORE_TIME: BACNET_PROPERTY_ID = 157;
pub const BACNET_PROPERTY_ID_PROP_MAINTENANCE_REQUIRED: BACNET_PROPERTY_ID = 158;
pub const BACNET_PROPERTY_ID_PROP_MEMBER_OF: BACNET_PROPERTY_ID = 159;
pub const BACNET_PROPERTY_ID_PROP_MODE: BACNET_PROPERTY_ID = 160;
pub const BACNET_PROPERTY_ID_PROP_OPERATION_EXPECTED: BACNET_PROPERTY_ID = 161;
pub const BACNET_PROPERTY_ID_PROP_SETTING: BACNET_PROPERTY_ID = 162;
pub const BACNET_PROPERTY_ID_PROP_SILENCED: BACNET_PROPERTY_ID = 163;
pub const BACNET_PROPERTY_ID_PROP_TRACKING_VALUE: BACNET_PROPERTY_ID = 164;
pub const BACNET_PROPERTY_ID_PROP_ZONE_MEMBERS: BACNET_PROPERTY_ID = 165;
pub const BACNET_PROPERTY_ID_PROP_LIFE_SAFETY_ALARM_VALUES: BACNET_PROPERTY_ID = 166;
pub const BACNET_PROPERTY_ID_PROP_MAX_SEGMENTS_ACCEPTED: BACNET_PROPERTY_ID = 167;
pub const BACNET_PROPERTY_ID_PROP_PROFILE_NAME: BACNET_PROPERTY_ID = 168;
pub const BACNET_PROPERTY_ID_PROP_AUTO_SLAVE_DISCOVERY: BACNET_PROPERTY_ID = 169;
pub const BACNET_PROPERTY_ID_PROP_MANUAL_SLAVE_ADDRESS_BINDING: BACNET_PROPERTY_ID = 170;
pub const BACNET_PROPERTY_ID_PROP_SLAVE_ADDRESS_BINDING: BACNET_PROPERTY_ID = 171;
pub const BACNET_PROPERTY_ID_PROP_SLAVE_PROXY_ENABLE: BACNET_PROPERTY_ID = 172;
pub const BACNET_PROPERTY_ID_PROP_LAST_NOTIFY_RECORD: BACNET_PROPERTY_ID = 173;
pub const BACNET_PROPERTY_ID_PROP_SCHEDULE_DEFAULT: BACNET_PROPERTY_ID = 174;
pub const BACNET_PROPERTY_ID_PROP_ACCEPTED_MODES: BACNET_PROPERTY_ID = 175;
pub const BACNET_PROPERTY_ID_PROP_ADJUST_VALUE: BACNET_PROPERTY_ID = 176;
pub const BACNET_PROPERTY_ID_PROP_COUNT: BACNET_PROPERTY_ID = 177;
pub const BACNET_PROPERTY_ID_PROP_COUNT_BEFORE_CHANGE: BACNET_PROPERTY_ID = 178;
pub const BACNET_PROPERTY_ID_PROP_COUNT_CHANGE_TIME: BACNET_PROPERTY_ID = 179;
pub const BACNET_PROPERTY_ID_PROP_COV_PERIOD: BACNET_PROPERTY_ID = 180;
pub const BACNET_PROPERTY_ID_PROP_INPUT_REFERENCE: BACNET_PROPERTY_ID = 181;
pub const BACNET_PROPERTY_ID_PROP_LIMIT_MONITORING_INTERVAL: BACNET_PROPERTY_ID = 182;
pub const BACNET_PROPERTY_ID_PROP_LOGGING_OBJECT: BACNET_PROPERTY_ID = 183;
pub const BACNET_PROPERTY_ID_PROP_LOGGING_RECORD: BACNET_PROPERTY_ID = 184;
pub const BACNET_PROPERTY_ID_PROP_PRESCALE: BACNET_PROPERTY_ID = 185;
pub const BACNET_PROPERTY_ID_PROP_PULSE_RATE: BACNET_PROPERTY_ID = 186;
pub const BACNET_PROPERTY_ID_PROP_SCALE: BACNET_PROPERTY_ID = 187;
pub const BACNET_PROPERTY_ID_PROP_SCALE_FACTOR: BACNET_PROPERTY_ID = 188;
pub const BACNET_PROPERTY_ID_PROP_UPDATE_TIME: BACNET_PROPERTY_ID = 189;
pub const BACNET_PROPERTY_ID_PROP_VALUE_BEFORE_CHANGE: BACNET_PROPERTY_ID = 190;
pub const BACNET_PROPERTY_ID_PROP_VALUE_SET: BACNET_PROPERTY_ID = 191;
pub const BACNET_PROPERTY_ID_PROP_VALUE_CHANGE_TIME: BACNET_PROPERTY_ID = 192;
pub const BACNET_PROPERTY_ID_PROP_ALIGN_INTERVALS: BACNET_PROPERTY_ID = 193;
pub const BACNET_PROPERTY_ID_PROP_INTERVAL_OFFSET: BACNET_PROPERTY_ID = 195;
pub const BACNET_PROPERTY_ID_PROP_LAST_RESTART_REASON: BACNET_PROPERTY_ID = 196;
pub const BACNET_PROPERTY_ID_PROP_LOGGING_TYPE: BACNET_PROPERTY_ID = 197;
pub const BACNET_PROPERTY_ID_PROP_RESTART_NOTIFICATION_RECIPIENTS: BACNET_PROPERTY_ID = 202;
pub const BACNET_PROPERTY_ID_PROP_TIME_OF_DEVICE_RESTART: BACNET_PROPERTY_ID = 203;
pub const BACNET_PROPERTY_ID_PROP_TIME_SYNCHRONIZATION_INTERVAL: BACNET_PROPERTY_ID = 204;
pub const BACNET_PROPERTY_ID_PROP_TRIGGER: BACNET_PROPERTY_ID = 205;
pub const BACNET_PROPERTY_ID_PROP_UTC_TIME_SYNCHRONIZATION_RECIPIENTS: BACNET_PROPERTY_ID = 206;
pub const BACNET_PROPERTY_ID_PROP_NODE_SUBTYPE: BACNET_PROPERTY_ID = 207;
pub const BACNET_PROPERTY_ID_PROP_NODE_TYPE: BACNET_PROPERTY_ID = 208;
pub const BACNET_PROPERTY_ID_PROP_STRUCTURED_OBJECT_LIST: BACNET_PROPERTY_ID = 209;
pub const BACNET_PROPERTY_ID_PROP_SUBORDINATE_ANNOTATIONS: BACNET_PROPERTY_ID = 210;
pub const BACNET_PROPERTY_ID_PROP_SUBORDINATE_LIST: BACNET_PROPERTY_ID = 211;
pub const BACNET_PROPERTY_ID_PROP_ACTUAL_SHED_LEVEL: BACNET_PROPERTY_ID = 212;
pub const BACNET_PROPERTY_ID_PROP_DUTY_WINDOW: BACNET_PROPERTY_ID = 213;
pub const BACNET_PROPERTY_ID_PROP_EXPECTED_SHED_LEVEL: BACNET_PROPERTY_ID = 214;
pub const BACNET_PROPERTY_ID_PROP_FULL_DUTY_BASELINE: BACNET_PROPERTY_ID = 215;
pub const BACNET_PROPERTY_ID_PROP_REQUESTED_SHED_LEVEL: BACNET_PROPERTY_ID = 218;
pub const BACNET_PROPERTY_ID_PROP_SHED_DURATION: BACNET_PROPERTY_ID = 219;
pub const BACNET_PROPERTY_ID_PROP_SHED_LEVEL_DESCRIPTIONS: BACNET_PROPERTY_ID = 220;
pub const BACNET_PROPERTY_ID_PROP_SHED_LEVELS: BACNET_PROPERTY_ID = 221;
pub const BACNET_PROPERTY_ID_PROP_STATE_DESCRIPTION: BACNET_PROPERTY_ID = 222;
pub const BACNET_PROPERTY_ID_PROP_DOOR_ALARM_STATE: BACNET_PROPERTY_ID = 226;
pub const BACNET_PROPERTY_ID_PROP_DOOR_EXTENDED_PULSE_TIME: BACNET_PROPERTY_ID = 227;
pub const BACNET_PROPERTY_ID_PROP_DOOR_MEMBERS: BACNET_PROPERTY_ID = 228;
pub const BACNET_PROPERTY_ID_PROP_DOOR_OPEN_TOO_LONG_TIME: BACNET_PROPERTY_ID = 229;
pub const BACNET_PROPERTY_ID_PROP_DOOR_PULSE_TIME: BACNET_PROPERTY_ID = 230;
pub const BACNET_PROPERTY_ID_PROP_DOOR_STATUS: BACNET_PROPERTY_ID = 231;
pub const BACNET_PROPERTY_ID_PROP_DOOR_UNLOCK_DELAY_TIME: BACNET_PROPERTY_ID = 232;
pub const BACNET_PROPERTY_ID_PROP_LOCK_STATUS: BACNET_PROPERTY_ID = 233;
pub const BACNET_PROPERTY_ID_PROP_MASKED_ALARM_VALUES: BACNET_PROPERTY_ID = 234;
pub const BACNET_PROPERTY_ID_PROP_SECURED_STATUS: BACNET_PROPERTY_ID = 235;
pub const BACNET_PROPERTY_ID_PROP_ABSENTEE_LIMIT: BACNET_PROPERTY_ID = 244;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_ALARM_EVENTS: BACNET_PROPERTY_ID = 245;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_DOORS: BACNET_PROPERTY_ID = 246;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_EVENT: BACNET_PROPERTY_ID = 247;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_EVENT_AUTHENTICATION_FACTOR: BACNET_PROPERTY_ID = 248;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_EVENT_CREDENTIAL: BACNET_PROPERTY_ID = 249;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_EVENT_TIME: BACNET_PROPERTY_ID = 250;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_TRANSACTION_EVENTS: BACNET_PROPERTY_ID = 251;
pub const BACNET_PROPERTY_ID_PROP_ACCOMPANIMENT: BACNET_PROPERTY_ID = 252;
pub const BACNET_PROPERTY_ID_PROP_ACCOMPANIMENT_TIME: BACNET_PROPERTY_ID = 253;
pub const BACNET_PROPERTY_ID_PROP_ACTIVATION_TIME: BACNET_PROPERTY_ID = 254;
pub const BACNET_PROPERTY_ID_PROP_ACTIVE_AUTHENTICATION_POLICY: BACNET_PROPERTY_ID = 255;
pub const BACNET_PROPERTY_ID_PROP_ASSIGNED_ACCESS_RIGHTS: BACNET_PROPERTY_ID = 256;
pub const BACNET_PROPERTY_ID_PROP_AUTHENTICATION_FACTORS: BACNET_PROPERTY_ID = 257;
pub const BACNET_PROPERTY_ID_PROP_AUTHENTICATION_POLICY_LIST: BACNET_PROPERTY_ID = 258;
pub const BACNET_PROPERTY_ID_PROP_AUTHENTICATION_POLICY_NAMES: BACNET_PROPERTY_ID = 259;
pub const BACNET_PROPERTY_ID_PROP_AUTHENTICATION_STATUS: BACNET_PROPERTY_ID = 260;
pub const BACNET_PROPERTY_ID_PROP_AUTHORIZATION_MODE: BACNET_PROPERTY_ID = 261;
pub const BACNET_PROPERTY_ID_PROP_BELONGS_TO: BACNET_PROPERTY_ID = 262;
pub const BACNET_PROPERTY_ID_PROP_CREDENTIAL_DISABLE: BACNET_PROPERTY_ID = 263;
pub const BACNET_PROPERTY_ID_PROP_CREDENTIAL_STATUS: BACNET_PROPERTY_ID = 264;
pub const BACNET_PROPERTY_ID_PROP_CREDENTIALS: BACNET_PROPERTY_ID = 265;
pub const BACNET_PROPERTY_ID_PROP_CREDENTIALS_IN_ZONE: BACNET_PROPERTY_ID = 266;
pub const BACNET_PROPERTY_ID_PROP_DAYS_REMAINING: BACNET_PROPERTY_ID = 267;
pub const BACNET_PROPERTY_ID_PROP_ENTRY_POINTS: BACNET_PROPERTY_ID = 268;
pub const BACNET_PROPERTY_ID_PROP_EXIT_POINTS: BACNET_PROPERTY_ID = 269;
pub const BACNET_PROPERTY_ID_PROP_EXPIRATION_TIME: BACNET_PROPERTY_ID = 270;
pub const BACNET_PROPERTY_ID_PROP_EXTENDED_TIME_ENABLE: BACNET_PROPERTY_ID = 271;
pub const BACNET_PROPERTY_ID_PROP_FAILED_ATTEMPT_EVENTS: BACNET_PROPERTY_ID = 272;
pub const BACNET_PROPERTY_ID_PROP_FAILED_ATTEMPTS: BACNET_PROPERTY_ID = 273;
pub const BACNET_PROPERTY_ID_PROP_FAILED_ATTEMPTS_TIME: BACNET_PROPERTY_ID = 274;
pub const BACNET_PROPERTY_ID_PROP_LAST_ACCESS_EVENT: BACNET_PROPERTY_ID = 275;
pub const BACNET_PROPERTY_ID_PROP_LAST_ACCESS_POINT: BACNET_PROPERTY_ID = 276;
pub const BACNET_PROPERTY_ID_PROP_LAST_CREDENTIAL_ADDED: BACNET_PROPERTY_ID = 277;
pub const BACNET_PROPERTY_ID_PROP_LAST_CREDENTIAL_ADDED_TIME: BACNET_PROPERTY_ID = 278;
pub const BACNET_PROPERTY_ID_PROP_LAST_CREDENTIAL_REMOVED: BACNET_PROPERTY_ID = 279;
pub const BACNET_PROPERTY_ID_PROP_LAST_CREDENTIAL_REMOVED_TIME: BACNET_PROPERTY_ID = 280;
pub const BACNET_PROPERTY_ID_PROP_LAST_USE_TIME: BACNET_PROPERTY_ID = 281;
pub const BACNET_PROPERTY_ID_PROP_LOCKOUT: BACNET_PROPERTY_ID = 282;
pub const BACNET_PROPERTY_ID_PROP_LOCKOUT_RELINQUISH_TIME: BACNET_PROPERTY_ID = 283;
pub const BACNET_PROPERTY_ID_PROP_MASTER_EXEMPTION: BACNET_PROPERTY_ID = 284;
pub const BACNET_PROPERTY_ID_PROP_MAX_FAILED_ATTEMPTS: BACNET_PROPERTY_ID = 285;
pub const BACNET_PROPERTY_ID_PROP_MEMBERS: BACNET_PROPERTY_ID = 286;
pub const BACNET_PROPERTY_ID_PROP_MUSTER_POINT: BACNET_PROPERTY_ID = 287;
pub const BACNET_PROPERTY_ID_PROP_NEGATIVE_ACCESS_RULES: BACNET_PROPERTY_ID = 288;
pub const BACNET_PROPERTY_ID_PROP_NUMBER_OF_AUTHENTICATION_POLICIES: BACNET_PROPERTY_ID = 289;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_COUNT: BACNET_PROPERTY_ID = 290;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_COUNT_ADJUST: BACNET_PROPERTY_ID = 291;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_COUNT_ENABLE: BACNET_PROPERTY_ID = 292;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_EXEMPTION: BACNET_PROPERTY_ID = 293;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_LOWER_LIMIT: BACNET_PROPERTY_ID = 294;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_LOWER_LIMIT_ENFORCED: BACNET_PROPERTY_ID = 295;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_STATE: BACNET_PROPERTY_ID = 296;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_UPPER_LIMIT: BACNET_PROPERTY_ID = 297;
pub const BACNET_PROPERTY_ID_PROP_OCCUPANCY_UPPER_LIMIT_ENFORCED: BACNET_PROPERTY_ID = 298;
pub const BACNET_PROPERTY_ID_PROP_PASSBACK_EXEMPTION: BACNET_PROPERTY_ID = 299;
pub const BACNET_PROPERTY_ID_PROP_PASSBACK_MODE: BACNET_PROPERTY_ID = 300;
pub const BACNET_PROPERTY_ID_PROP_PASSBACK_TIMEOUT: BACNET_PROPERTY_ID = 301;
pub const BACNET_PROPERTY_ID_PROP_POSITIVE_ACCESS_RULES: BACNET_PROPERTY_ID = 302;
pub const BACNET_PROPERTY_ID_PROP_REASON_FOR_DISABLE: BACNET_PROPERTY_ID = 303;
pub const BACNET_PROPERTY_ID_PROP_SUPPORTED_FORMATS: BACNET_PROPERTY_ID = 304;
pub const BACNET_PROPERTY_ID_PROP_SUPPORTED_FORMAT_CLASSES: BACNET_PROPERTY_ID = 305;
pub const BACNET_PROPERTY_ID_PROP_THREAT_AUTHORITY: BACNET_PROPERTY_ID = 306;
pub const BACNET_PROPERTY_ID_PROP_THREAT_LEVEL: BACNET_PROPERTY_ID = 307;
pub const BACNET_PROPERTY_ID_PROP_TRACE_FLAG: BACNET_PROPERTY_ID = 308;
pub const BACNET_PROPERTY_ID_PROP_TRANSACTION_NOTIFICATION_CLASS: BACNET_PROPERTY_ID = 309;
pub const BACNET_PROPERTY_ID_PROP_USER_EXTERNAL_IDENTIFIER: BACNET_PROPERTY_ID = 310;
pub const BACNET_PROPERTY_ID_PROP_USER_INFORMATION_REFERENCE: BACNET_PROPERTY_ID = 311;
pub const BACNET_PROPERTY_ID_PROP_USER_NAME: BACNET_PROPERTY_ID = 317;
pub const BACNET_PROPERTY_ID_PROP_USER_TYPE: BACNET_PROPERTY_ID = 318;
pub const BACNET_PROPERTY_ID_PROP_USES_REMAINING: BACNET_PROPERTY_ID = 319;
pub const BACNET_PROPERTY_ID_PROP_ZONE_FROM: BACNET_PROPERTY_ID = 320;
pub const BACNET_PROPERTY_ID_PROP_ZONE_TO: BACNET_PROPERTY_ID = 321;
pub const BACNET_PROPERTY_ID_PROP_ACCESS_EVENT_TAG: BACNET_PROPERTY_ID = 322;
pub const BACNET_PROPERTY_ID_PROP_GLOBAL_IDENTIFIER: BACNET_PROPERTY_ID = 323;
pub const BACNET_PROPERTY_ID_PROP_VERIFICATION_TIME: BACNET_PROPERTY_ID = 326;
pub const BACNET_PROPERTY_ID_PROP_BASE_DEVICE_SECURITY_POLICY: BACNET_PROPERTY_ID = 327;
pub const BACNET_PROPERTY_ID_PROP_DISTRIBUTION_KEY_REVISION: BACNET_PROPERTY_ID = 328;
pub const BACNET_PROPERTY_ID_PROP_DO_NOT_HIDE: BACNET_PROPERTY_ID = 329;
pub const BACNET_PROPERTY_ID_PROP_KEY_SETS: BACNET_PROPERTY_ID = 330;
pub const BACNET_PROPERTY_ID_PROP_LAST_KEY_SERVER: BACNET_PROPERTY_ID = 331;
pub const BACNET_PROPERTY_ID_PROP_NETWORK_ACCESS_SECURITY_POLICIES: BACNET_PROPERTY_ID = 332;
pub const BACNET_PROPERTY_ID_PROP_PACKET_REORDER_TIME: BACNET_PROPERTY_ID = 333;
pub const BACNET_PROPERTY_ID_PROP_SECURITY_PDU_TIMEOUT: BACNET_PROPERTY_ID = 334;
pub const BACNET_PROPERTY_ID_PROP_SECURITY_TIME_WINDOW: BACNET_PROPERTY_ID = 335;
pub const BACNET_PROPERTY_ID_PROP_SUPPORTED_SECURITY_ALGORITHM: BACNET_PROPERTY_ID = 336;
pub const BACNET_PROPERTY_ID_PROP_UPDATE_KEY_SET_TIMEOUT: BACNET_PROPERTY_ID = 337;
pub const BACNET_PROPERTY_ID_PROP_BACKUP_AND_RESTORE_STATE: BACNET_PROPERTY_ID = 338;
pub const BACNET_PROPERTY_ID_PROP_BACKUP_PREPARATION_TIME: BACNET_PROPERTY_ID = 339;
pub const BACNET_PROPERTY_ID_PROP_RESTORE_COMPLETION_TIME: BACNET_PROPERTY_ID = 340;
pub const BACNET_PROPERTY_ID_PROP_RESTORE_PREPARATION_TIME: BACNET_PROPERTY_ID = 341;
pub const BACNET_PROPERTY_ID_PROP_BIT_MASK: BACNET_PROPERTY_ID = 342;
pub const BACNET_PROPERTY_ID_PROP_BIT_TEXT: BACNET_PROPERTY_ID = 343;
pub const BACNET_PROPERTY_ID_PROP_IS_UTC: BACNET_PROPERTY_ID = 344;
pub const BACNET_PROPERTY_ID_PROP_GROUP_MEMBERS: BACNET_PROPERTY_ID = 345;
pub const BACNET_PROPERTY_ID_PROP_GROUP_MEMBER_NAMES: BACNET_PROPERTY_ID = 346;
pub const BACNET_PROPERTY_ID_PROP_MEMBER_STATUS_FLAGS: BACNET_PROPERTY_ID = 347;
pub const BACNET_PROPERTY_ID_PROP_REQUESTED_UPDATE_INTERVAL: BACNET_PROPERTY_ID = 348;
pub const BACNET_PROPERTY_ID_PROP_COVU_PERIOD: BACNET_PROPERTY_ID = 349;
pub const BACNET_PROPERTY_ID_PROP_COVU_RECIPIENTS: BACNET_PROPERTY_ID = 350;
pub const BACNET_PROPERTY_ID_PROP_EVENT_MESSAGE_TEXTS: BACNET_PROPERTY_ID = 351;
pub const BACNET_PROPERTY_ID_PROP_EVENT_MESSAGE_TEXTS_CONFIG: BACNET_PROPERTY_ID = 352;
pub const BACNET_PROPERTY_ID_PROP_EVENT_DETECTION_ENABLE: BACNET_PROPERTY_ID = 353;
pub const BACNET_PROPERTY_ID_PROP_EVENT_ALGORITHM_INHIBIT: BACNET_PROPERTY_ID = 354;
pub const BACNET_PROPERTY_ID_PROP_EVENT_ALGORITHM_INHIBIT_REF: BACNET_PROPERTY_ID = 355;
pub const BACNET_PROPERTY_ID_PROP_TIME_DELAY_NORMAL: BACNET_PROPERTY_ID = 356;
pub const BACNET_PROPERTY_ID_PROP_RELIABILITY_EVALUATION_INHIBIT: BACNET_PROPERTY_ID = 357;
pub const BACNET_PROPERTY_ID_PROP_FAULT_PARAMETERS: BACNET_PROPERTY_ID = 358;
pub const BACNET_PROPERTY_ID_PROP_FAULT_TYPE: BACNET_PROPERTY_ID = 359;
pub const BACNET_PROPERTY_ID_PROP_LOCAL_FORWARDING_ONLY: BACNET_PROPERTY_ID = 360;
pub const BACNET_PROPERTY_ID_PROP_PROCESS_IDENTIFIER_FILTER: BACNET_PROPERTY_ID = 361;
pub const BACNET_PROPERTY_ID_PROP_SUBSCRIBED_RECIPIENTS: BACNET_PROPERTY_ID = 362;
pub const BACNET_PROPERTY_ID_PROP_PORT_FILTER: BACNET_PROPERTY_ID = 363;
pub const BACNET_PROPERTY_ID_PROP_AUTHORIZATION_EXEMPTIONS: BACNET_PROPERTY_ID = 364;
pub const BACNET_PROPERTY_ID_PROP_ALLOW_GROUP_DELAY_INHIBIT: BACNET_PROPERTY_ID = 365;
pub const BACNET_PROPERTY_ID_PROP_CHANNEL_NUMBER: BACNET_PROPERTY_ID = 366;
pub const BACNET_PROPERTY_ID_PROP_CONTROL_GROUPS: BACNET_PROPERTY_ID = 367;
pub const BACNET_PROPERTY_ID_PROP_EXECUTION_DELAY: BACNET_PROPERTY_ID = 368;
pub const BACNET_PROPERTY_ID_PROP_LAST_PRIORITY: BACNET_PROPERTY_ID = 369;
pub const BACNET_PROPERTY_ID_PROP_WRITE_STATUS: BACNET_PROPERTY_ID = 370;
pub const BACNET_PROPERTY_ID_PROP_PROPERTY_LIST: BACNET_PROPERTY_ID = 371;
pub const BACNET_PROPERTY_ID_PROP_SERIAL_NUMBER: BACNET_PROPERTY_ID = 372;
pub const BACNET_PROPERTY_ID_PROP_BLINK_WARN_ENABLE: BACNET_PROPERTY_ID = 373;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_FADE_TIME: BACNET_PROPERTY_ID = 374;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_RAMP_RATE: BACNET_PROPERTY_ID = 375;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_STEP_INCREMENT: BACNET_PROPERTY_ID = 376;
pub const BACNET_PROPERTY_ID_PROP_EGRESS_TIME: BACNET_PROPERTY_ID = 377;
pub const BACNET_PROPERTY_ID_PROP_IN_PROGRESS: BACNET_PROPERTY_ID = 378;
pub const BACNET_PROPERTY_ID_PROP_INSTANTANEOUS_POWER: BACNET_PROPERTY_ID = 379;
pub const BACNET_PROPERTY_ID_PROP_LIGHTING_COMMAND: BACNET_PROPERTY_ID = 380;
pub const BACNET_PROPERTY_ID_PROP_LIGHTING_COMMAND_DEFAULT_PRIORITY: BACNET_PROPERTY_ID = 381;
pub const BACNET_PROPERTY_ID_PROP_MAX_ACTUAL_VALUE: BACNET_PROPERTY_ID = 382;
pub const BACNET_PROPERTY_ID_PROP_MIN_ACTUAL_VALUE: BACNET_PROPERTY_ID = 383;
pub const BACNET_PROPERTY_ID_PROP_POWER: BACNET_PROPERTY_ID = 384;
pub const BACNET_PROPERTY_ID_PROP_TRANSITION: BACNET_PROPERTY_ID = 385;
pub const BACNET_PROPERTY_ID_PROP_EGRESS_ACTIVE: BACNET_PROPERTY_ID = 386;
pub const BACNET_PROPERTY_ID_PROP_INTERFACE_VALUE: BACNET_PROPERTY_ID = 387;
pub const BACNET_PROPERTY_ID_PROP_FAULT_HIGH_LIMIT: BACNET_PROPERTY_ID = 388;
pub const BACNET_PROPERTY_ID_PROP_FAULT_LOW_LIMIT: BACNET_PROPERTY_ID = 389;
pub const BACNET_PROPERTY_ID_PROP_LOW_DIFF_LIMIT: BACNET_PROPERTY_ID = 390;
pub const BACNET_PROPERTY_ID_PROP_STRIKE_COUNT: BACNET_PROPERTY_ID = 391;
pub const BACNET_PROPERTY_ID_PROP_TIME_OF_STRIKE_COUNT_RESET: BACNET_PROPERTY_ID = 392;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_TIMEOUT: BACNET_PROPERTY_ID = 393;
pub const BACNET_PROPERTY_ID_PROP_INITIAL_TIMEOUT: BACNET_PROPERTY_ID = 394;
pub const BACNET_PROPERTY_ID_PROP_LAST_STATE_CHANGE: BACNET_PROPERTY_ID = 395;
pub const BACNET_PROPERTY_ID_PROP_STATE_CHANGE_VALUES: BACNET_PROPERTY_ID = 396;
pub const BACNET_PROPERTY_ID_PROP_TIMER_RUNNING: BACNET_PROPERTY_ID = 397;
pub const BACNET_PROPERTY_ID_PROP_TIMER_STATE: BACNET_PROPERTY_ID = 398;
pub const BACNET_PROPERTY_ID_PROP_APDU_LENGTH: BACNET_PROPERTY_ID = 399;
pub const BACNET_PROPERTY_ID_PROP_IP_ADDRESS: BACNET_PROPERTY_ID = 400;
pub const BACNET_PROPERTY_ID_PROP_IP_DEFAULT_GATEWAY: BACNET_PROPERTY_ID = 401;
pub const BACNET_PROPERTY_ID_PROP_IP_DHCP_ENABLE: BACNET_PROPERTY_ID = 402;
pub const BACNET_PROPERTY_ID_PROP_IP_DHCP_LEASE_TIME: BACNET_PROPERTY_ID = 403;
pub const BACNET_PROPERTY_ID_PROP_IP_DHCP_LEASE_TIME_REMAINING: BACNET_PROPERTY_ID = 404;
pub const BACNET_PROPERTY_ID_PROP_IP_DHCP_SERVER: BACNET_PROPERTY_ID = 405;
pub const BACNET_PROPERTY_ID_PROP_IP_DNS_SERVER: BACNET_PROPERTY_ID = 406;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IP_GLOBAL_ADDRESS: BACNET_PROPERTY_ID = 407;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IP_MODE: BACNET_PROPERTY_ID = 408;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IP_MULTICAST_ADDRESS: BACNET_PROPERTY_ID = 409;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IP_NAT_TRAVERSAL: BACNET_PROPERTY_ID = 410;
pub const BACNET_PROPERTY_ID_PROP_IP_SUBNET_MASK: BACNET_PROPERTY_ID = 411;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IP_UDP_PORT: BACNET_PROPERTY_ID = 412;
pub const BACNET_PROPERTY_ID_PROP_BBMD_ACCEPT_FD_REGISTRATIONS: BACNET_PROPERTY_ID = 413;
pub const BACNET_PROPERTY_ID_PROP_BBMD_BROADCAST_DISTRIBUTION_TABLE: BACNET_PROPERTY_ID = 414;
pub const BACNET_PROPERTY_ID_PROP_BBMD_FOREIGN_DEVICE_TABLE: BACNET_PROPERTY_ID = 415;
pub const BACNET_PROPERTY_ID_PROP_CHANGES_PENDING: BACNET_PROPERTY_ID = 416;
pub const BACNET_PROPERTY_ID_PROP_COMMAND: BACNET_PROPERTY_ID = 417;
pub const BACNET_PROPERTY_ID_PROP_FD_BBMD_ADDRESS: BACNET_PROPERTY_ID = 418;
pub const BACNET_PROPERTY_ID_PROP_FD_SUBSCRIPTION_LIFETIME: BACNET_PROPERTY_ID = 419;
pub const BACNET_PROPERTY_ID_PROP_LINK_SPEED: BACNET_PROPERTY_ID = 420;
pub const BACNET_PROPERTY_ID_PROP_LINK_SPEEDS: BACNET_PROPERTY_ID = 421;
pub const BACNET_PROPERTY_ID_PROP_LINK_SPEED_AUTONEGOTIATE: BACNET_PROPERTY_ID = 422;
pub const BACNET_PROPERTY_ID_PROP_MAC_ADDRESS: BACNET_PROPERTY_ID = 423;
pub const BACNET_PROPERTY_ID_PROP_NETWORK_INTERFACE_NAME: BACNET_PROPERTY_ID = 424;
pub const BACNET_PROPERTY_ID_PROP_NETWORK_NUMBER: BACNET_PROPERTY_ID = 425;
pub const BACNET_PROPERTY_ID_PROP_NETWORK_NUMBER_QUALITY: BACNET_PROPERTY_ID = 426;
pub const BACNET_PROPERTY_ID_PROP_NETWORK_TYPE: BACNET_PROPERTY_ID = 427;
pub const BACNET_PROPERTY_ID_PROP_ROUTING_TABLE: BACNET_PROPERTY_ID = 428;
pub const BACNET_PROPERTY_ID_PROP_VIRTUAL_MAC_ADDRESS_TABLE: BACNET_PROPERTY_ID = 429;
pub const BACNET_PROPERTY_ID_PROP_COMMAND_TIME_ARRAY: BACNET_PROPERTY_ID = 430;
pub const BACNET_PROPERTY_ID_PROP_CURRENT_COMMAND_PRIORITY: BACNET_PROPERTY_ID = 431;
pub const BACNET_PROPERTY_ID_PROP_LAST_COMMAND_TIME: BACNET_PROPERTY_ID = 432;
pub const BACNET_PROPERTY_ID_PROP_VALUE_SOURCE: BACNET_PROPERTY_ID = 433;
pub const BACNET_PROPERTY_ID_PROP_VALUE_SOURCE_ARRAY: BACNET_PROPERTY_ID = 434;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IPV6_MODE: BACNET_PROPERTY_ID = 435;
pub const BACNET_PROPERTY_ID_PROP_IPV6_ADDRESS: BACNET_PROPERTY_ID = 436;
pub const BACNET_PROPERTY_ID_PROP_IPV6_PREFIX_LENGTH: BACNET_PROPERTY_ID = 437;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IPV6_UDP_PORT: BACNET_PROPERTY_ID = 438;
pub const BACNET_PROPERTY_ID_PROP_IPV6_DEFAULT_GATEWAY: BACNET_PROPERTY_ID = 439;
pub const BACNET_PROPERTY_ID_PROP_BACNET_IPV6_MULTICAST_ADDRESS: BACNET_PROPERTY_ID = 440;
pub const BACNET_PROPERTY_ID_PROP_IPV6_DNS_SERVER: BACNET_PROPERTY_ID = 441;
pub const BACNET_PROPERTY_ID_PROP_IPV6_AUTO_ADDRESSING_ENABLE: BACNET_PROPERTY_ID = 442;
pub const BACNET_PROPERTY_ID_PROP_IPV6_DHCP_LEASE_TIME: BACNET_PROPERTY_ID = 443;
pub const BACNET_PROPERTY_ID_PROP_IPV6_DHCP_LEASE_TIME_REMAINING: BACNET_PROPERTY_ID = 444;
pub const BACNET_PROPERTY_ID_PROP_IPV6_DHCP_SERVER: BACNET_PROPERTY_ID = 445;
pub const BACNET_PROPERTY_ID_PROP_IPV6_ZONE_INDEX: BACNET_PROPERTY_ID = 446;
pub const BACNET_PROPERTY_ID_PROP_ASSIGNED_LANDING_CALLS: BACNET_PROPERTY_ID = 447;
pub const BACNET_PROPERTY_ID_PROP_CAR_ASSIGNED_DIRECTION: BACNET_PROPERTY_ID = 448;
pub const BACNET_PROPERTY_ID_PROP_CAR_DOOR_COMMAND: BACNET_PROPERTY_ID = 449;
pub const BACNET_PROPERTY_ID_PROP_CAR_DOOR_STATUS: BACNET_PROPERTY_ID = 450;
pub const BACNET_PROPERTY_ID_PROP_CAR_DOOR_TEXT: BACNET_PROPERTY_ID = 451;
pub const BACNET_PROPERTY_ID_PROP_CAR_DOOR_ZONE: BACNET_PROPERTY_ID = 452;
pub const BACNET_PROPERTY_ID_PROP_CAR_DRIVE_STATUS: BACNET_PROPERTY_ID = 453;
pub const BACNET_PROPERTY_ID_PROP_CAR_LOAD: BACNET_PROPERTY_ID = 454;
pub const BACNET_PROPERTY_ID_PROP_CAR_LOAD_UNITS: BACNET_PROPERTY_ID = 455;
pub const BACNET_PROPERTY_ID_PROP_CAR_MODE: BACNET_PROPERTY_ID = 456;
pub const BACNET_PROPERTY_ID_PROP_CAR_MOVING_DIRECTION: BACNET_PROPERTY_ID = 457;
pub const BACNET_PROPERTY_ID_PROP_CAR_POSITION: BACNET_PROPERTY_ID = 458;
pub const BACNET_PROPERTY_ID_PROP_ELEVATOR_GROUP: BACNET_PROPERTY_ID = 459;
pub const BACNET_PROPERTY_ID_PROP_ENERGY_METER: BACNET_PROPERTY_ID = 460;
pub const BACNET_PROPERTY_ID_PROP_ENERGY_METER_REF: BACNET_PROPERTY_ID = 461;
pub const BACNET_PROPERTY_ID_PROP_ESCALATOR_MODE: BACNET_PROPERTY_ID = 462;
pub const BACNET_PROPERTY_ID_PROP_FAULT_SIGNALS: BACNET_PROPERTY_ID = 463;
pub const BACNET_PROPERTY_ID_PROP_FLOOR_TEXT: BACNET_PROPERTY_ID = 464;
pub const BACNET_PROPERTY_ID_PROP_GROUP_ID: BACNET_PROPERTY_ID = 465;
pub const BACNET_PROPERTY_ID_PROP_GROUP_MODE: BACNET_PROPERTY_ID = 467;
pub const BACNET_PROPERTY_ID_PROP_HIGHER_DECK: BACNET_PROPERTY_ID = 468;
pub const BACNET_PROPERTY_ID_PROP_INSTALLATION_ID: BACNET_PROPERTY_ID = 469;
pub const BACNET_PROPERTY_ID_PROP_LANDING_CALLS: BACNET_PROPERTY_ID = 470;
pub const BACNET_PROPERTY_ID_PROP_LANDING_CALL_CONTROL: BACNET_PROPERTY_ID = 471;
pub const BACNET_PROPERTY_ID_PROP_LANDING_DOOR_STATUS: BACNET_PROPERTY_ID = 472;
pub const BACNET_PROPERTY_ID_PROP_LOWER_DECK: BACNET_PROPERTY_ID = 473;
pub const BACNET_PROPERTY_ID_PROP_MACHINE_ROOM_ID: BACNET_PROPERTY_ID = 474;
pub const BACNET_PROPERTY_ID_PROP_MAKING_CAR_CALL: BACNET_PROPERTY_ID = 475;
pub const BACNET_PROPERTY_ID_PROP_NEXT_STOPPING_FLOOR: BACNET_PROPERTY_ID = 476;
pub const BACNET_PROPERTY_ID_PROP_OPERATION_DIRECTION: BACNET_PROPERTY_ID = 477;
pub const BACNET_PROPERTY_ID_PROP_PASSENGER_ALARM: BACNET_PROPERTY_ID = 478;
pub const BACNET_PROPERTY_ID_PROP_POWER_MODE: BACNET_PROPERTY_ID = 479;
pub const BACNET_PROPERTY_ID_PROP_REGISTERED_CAR_CALL: BACNET_PROPERTY_ID = 480;
pub const BACNET_PROPERTY_ID_PROP_ACTIVE_COV_MULTIPLE_SUBSCRIPTIONS: BACNET_PROPERTY_ID = 481;
pub const BACNET_PROPERTY_ID_PROP_PROTOCOL_LEVEL: BACNET_PROPERTY_ID = 482;
pub const BACNET_PROPERTY_ID_PROP_REFERENCE_PORT: BACNET_PROPERTY_ID = 483;
pub const BACNET_PROPERTY_ID_PROP_DEPLOYED_PROFILE_LOCATION: BACNET_PROPERTY_ID = 484;
pub const BACNET_PROPERTY_ID_PROP_PROFILE_LOCATION: BACNET_PROPERTY_ID = 485;
pub const BACNET_PROPERTY_ID_PROP_TAGS: BACNET_PROPERTY_ID = 486;
pub const BACNET_PROPERTY_ID_PROP_SUBORDINATE_NODE_TYPES: BACNET_PROPERTY_ID = 487;
pub const BACNET_PROPERTY_ID_PROP_SUBORDINATE_TAGS: BACNET_PROPERTY_ID = 488;
pub const BACNET_PROPERTY_ID_PROP_SUBORDINATE_RELATIONSHIPS: BACNET_PROPERTY_ID = 489;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_SUBORDINATE_RELATIONSHIP: BACNET_PROPERTY_ID = 490;
pub const BACNET_PROPERTY_ID_PROP_REPRESENTS: BACNET_PROPERTY_ID = 491;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_PRESENT_VALUE: BACNET_PROPERTY_ID = 492;
pub const BACNET_PROPERTY_ID_PROP_PRESENT_STAGE: BACNET_PROPERTY_ID = 493;
pub const BACNET_PROPERTY_ID_PROP_STAGES: BACNET_PROPERTY_ID = 494;
pub const BACNET_PROPERTY_ID_PROP_STAGE_NAMES: BACNET_PROPERTY_ID = 495;
pub const BACNET_PROPERTY_ID_PROP_TARGET_REFERENCES: BACNET_PROPERTY_ID = 496;
pub const BACNET_PROPERTY_ID_PROP_AUDIT_SOURCE_LEVEL: BACNET_PROPERTY_ID = 497;
pub const BACNET_PROPERTY_ID_PROP_AUDIT_LEVEL: BACNET_PROPERTY_ID = 498;
pub const BACNET_PROPERTY_ID_PROP_AUDIT_NOTIFICATION_RECIPIENT: BACNET_PROPERTY_ID = 499;
pub const BACNET_PROPERTY_ID_PROP_AUDIT_PRIORITY_FILTER: BACNET_PROPERTY_ID = 500;
pub const BACNET_PROPERTY_ID_PROP_AUDITABLE_OPERATIONS: BACNET_PROPERTY_ID = 501;
pub const BACNET_PROPERTY_ID_PROP_DELETE_ON_FORWARD: BACNET_PROPERTY_ID = 502;
pub const BACNET_PROPERTY_ID_PROP_MAXIMUM_SEND_DELAY: BACNET_PROPERTY_ID = 503;
pub const BACNET_PROPERTY_ID_PROP_MONITORED_OBJECTS: BACNET_PROPERTY_ID = 504;
pub const BACNET_PROPERTY_ID_PROP_SEND_NOW: BACNET_PROPERTY_ID = 505;
pub const BACNET_PROPERTY_ID_PROP_FLOOR_NUMBER: BACNET_PROPERTY_ID = 506;
pub const BACNET_PROPERTY_ID_PROP_DEVICE_UUID: BACNET_PROPERTY_ID = 507;
pub const BACNET_PROPERTY_ID_PROP_ADDITIONAL_REFERENCE_PORTS: BACNET_PROPERTY_ID = 508;
pub const BACNET_PROPERTY_ID_PROP_CERTIFICATE_SIGNING_REQUEST_FILE: BACNET_PROPERTY_ID = 509;
pub const BACNET_PROPERTY_ID_PROP_COMMAND_VALIDATION_RESULT: BACNET_PROPERTY_ID = 510;
pub const BACNET_PROPERTY_ID_PROP_ISSUER_CERTIFICATE_FILES: BACNET_PROPERTY_ID = 511;
pub const BACNET_PROPERTY_ID_PROP_RESERVED_RANGE_MAX: BACNET_PROPERTY_ID = 511;
pub const BACNET_PROPERTY_ID_PROP_PROPRIETARY_RANGE_MIN: BACNET_PROPERTY_ID = 512;
pub const BACNET_PROPERTY_ID_PROP_PROPRIETARY_RANGE_MAX: BACNET_PROPERTY_ID = 4194303;
pub const BACNET_PROPERTY_ID_PROP_RESERVED_RANGE_MIN2: BACNET_PROPERTY_ID = 4194304;
pub const BACNET_PROPERTY_ID_PROP_MAX_BVLC_LENGTH_ACCEPTED: BACNET_PROPERTY_ID = 4194304;
pub const BACNET_PROPERTY_ID_PROP_MAX_NPDU_LENGTH_ACCEPTED: BACNET_PROPERTY_ID = 4194305;
pub const BACNET_PROPERTY_ID_PROP_OPERATIONAL_CERTIFICATE_FILE: BACNET_PROPERTY_ID = 4194306;
pub const BACNET_PROPERTY_ID_PROP_CURRENT_HEALTH: BACNET_PROPERTY_ID = 4194307;
pub const BACNET_PROPERTY_ID_PROP_SC_CONNECT_WAIT_TIMEOUT: BACNET_PROPERTY_ID = 4194308;
pub const BACNET_PROPERTY_ID_PROP_SC_DIRECT_CONNECT_ACCEPT_ENABLE: BACNET_PROPERTY_ID = 4194309;
pub const BACNET_PROPERTY_ID_PROP_SC_DIRECT_CONNECT_ACCEPT_URIS: BACNET_PROPERTY_ID = 4194310;
pub const BACNET_PROPERTY_ID_PROP_SC_DIRECT_CONNECT_BINDING: BACNET_PROPERTY_ID = 4194311;
pub const BACNET_PROPERTY_ID_PROP_SC_DIRECT_CONNECT_CONNECTION_STATUS: BACNET_PROPERTY_ID = 4194312;
pub const BACNET_PROPERTY_ID_PROP_SC_DIRECT_CONNECT_INITIATE_ENABLE: BACNET_PROPERTY_ID = 4194313;
pub const BACNET_PROPERTY_ID_PROP_SC_DISCONNECT_WAIT_TIMEOUT: BACNET_PROPERTY_ID = 4194314;
pub const BACNET_PROPERTY_ID_PROP_SC_FAILED_CONNECTION_REQUESTS: BACNET_PROPERTY_ID = 4194315;
pub const BACNET_PROPERTY_ID_PROP_SC_FAILOVER_HUB_CONNECTION_STATUS: BACNET_PROPERTY_ID = 4194316;
pub const BACNET_PROPERTY_ID_PROP_SC_FAILOVER_HUB_URI: BACNET_PROPERTY_ID = 4194317;
pub const BACNET_PROPERTY_ID_PROP_SC_HUB_CONNECTOR_STATE: BACNET_PROPERTY_ID = 4194318;
pub const BACNET_PROPERTY_ID_PROP_SC_HUB_FUNCTION_ACCEPT_URIS: BACNET_PROPERTY_ID = 4194319;
pub const BACNET_PROPERTY_ID_PROP_SC_HUB_FUNCTION_BINDING: BACNET_PROPERTY_ID = 4194320;
pub const BACNET_PROPERTY_ID_PROP_SC_HUB_FUNCTION_CONNECTION_STATUS: BACNET_PROPERTY_ID = 4194321;
pub const BACNET_PROPERTY_ID_PROP_SC_HUB_FUNCTION_ENABLE: BACNET_PROPERTY_ID = 4194322;
pub const BACNET_PROPERTY_ID_PROP_SC_HEARTBEAT_TIMEOUT: BACNET_PROPERTY_ID = 4194323;
pub const BACNET_PROPERTY_ID_PROP_SC_PRIMARY_HUB_CONNECTION_STATUS: BACNET_PROPERTY_ID = 4194324;
pub const BACNET_PROPERTY_ID_PROP_SC_PRIMARY_HUB_URI: BACNET_PROPERTY_ID = 4194325;
pub const BACNET_PROPERTY_ID_PROP_SC_MAXIMUM_RECONNECT_TIME: BACNET_PROPERTY_ID = 4194326;
pub const BACNET_PROPERTY_ID_PROP_SC_MINIMUM_RECONNECT_TIME: BACNET_PROPERTY_ID = 4194327;
pub const BACNET_PROPERTY_ID_PROP_COLOR_OVERRIDE: BACNET_PROPERTY_ID = 4194328;
pub const BACNET_PROPERTY_ID_PROP_COLOR_REFERENCE: BACNET_PROPERTY_ID = 4194329;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_COLOR: BACNET_PROPERTY_ID = 4194330;
pub const BACNET_PROPERTY_ID_PROP_DEFAULT_COLOR_TEMPERATURE: BACNET_PROPERTY_ID = 4194331;
pub const BACNET_PROPERTY_ID_PROP_OVERRIDE_COLOR_REFERENCE: BACNET_PROPERTY_ID = 4194332;
pub const BACNET_PROPERTY_ID_PROP_COLOR_COMMAND: BACNET_PROPERTY_ID = 4194334;
pub const BACNET_PROPERTY_ID_PROP_HIGH_END_TRIM: BACNET_PROPERTY_ID = 4194335;
pub const BACNET_PROPERTY_ID_PROP_LOW_END_TRIM: BACNET_PROPERTY_ID = 4194336;
pub const BACNET_PROPERTY_ID_PROP_TRIM_FADE_TIME: BACNET_PROPERTY_ID = 4194337;
pub const BACNET_PROPERTY_ID_MAX_BACNET_PROPERTY_ID: BACNET_PROPERTY_ID = 16777215;
pub type BACNET_PROPERTY_ID = ::std::os::raw::c_uint;
pub const BACNET_LIMIT_ENABLE_EVENT_LOW_LIMIT_ENABLE: BACNET_LIMIT_ENABLE = 1;
pub const BACNET_LIMIT_ENABLE_EVENT_HIGH_LIMIT_ENABLE: BACNET_LIMIT_ENABLE = 2;
pub type BACNET_LIMIT_ENABLE = ::std::os::raw::c_uint;
pub const BACNET_ACTION_ACTION_DIRECT: BACNET_ACTION = 0;
pub const BACNET_ACTION_ACTION_REVERSE: BACNET_ACTION = 1;
pub type BACNET_ACTION = ::std::os::raw::c_uint;
pub const BACNET_BINARY_PV_MIN_BINARY_PV: BACNET_BINARY_PV = 0;
pub const BACNET_BINARY_PV_BINARY_INACTIVE: BACNET_BINARY_PV = 0;
pub const BACNET_BINARY_PV_BINARY_ACTIVE: BACNET_BINARY_PV = 1;
pub const BACNET_BINARY_PV_MAX_BINARY_PV: BACNET_BINARY_PV = 1;
pub const BACNET_BINARY_PV_BINARY_NULL: BACNET_BINARY_PV = 255;
pub type BACNET_BINARY_PV = ::std::os::raw::c_uint;
pub const BACNET_ACTION_VALUE_TYPE_ACTION_BINARY_PV: BACNET_ACTION_VALUE_TYPE = 0;
pub const BACNET_ACTION_VALUE_TYPE_ACTION_UNSIGNED: BACNET_ACTION_VALUE_TYPE = 1;
pub const BACNET_ACTION_VALUE_TYPE_ACTION_FLOAT: BACNET_ACTION_VALUE_TYPE = 2;
pub type BACNET_ACTION_VALUE_TYPE = ::std::os::raw::c_uint;
pub const BACNET_EVENT_STATE_EVENT_STATE_NORMAL: BACNET_EVENT_STATE = 0;
pub const BACNET_EVENT_STATE_EVENT_STATE_FAULT: BACNET_EVENT_STATE = 1;
pub const BACNET_EVENT_STATE_EVENT_STATE_OFFNORMAL: BACNET_EVENT_STATE = 2;
pub const BACNET_EVENT_STATE_EVENT_STATE_HIGH_LIMIT: BACNET_EVENT_STATE = 3;
pub const BACNET_EVENT_STATE_EVENT_STATE_LOW_LIMIT: BACNET_EVENT_STATE = 4;
pub const BACNET_EVENT_STATE_EVENT_STATE_MAX: BACNET_EVENT_STATE = 5;
pub type BACNET_EVENT_STATE = ::std::os::raw::c_uint;
pub const BACNET_EVENT_ENABLE_EVENT_ENABLE_TO_OFFNORMAL: BACNET_EVENT_ENABLE = 1;
pub const BACNET_EVENT_ENABLE_EVENT_ENABLE_TO_FAULT: BACNET_EVENT_ENABLE = 2;
pub const BACNET_EVENT_ENABLE_EVENT_ENABLE_TO_NORMAL: BACNET_EVENT_ENABLE = 4;
pub type BACNET_EVENT_ENABLE = ::std::os::raw::c_uint;
pub const BACNET_DEVICE_STATUS_STATUS_OPERATIONAL: BACNET_DEVICE_STATUS = 0;
pub const BACNET_DEVICE_STATUS_STATUS_OPERATIONAL_READ_ONLY: BACNET_DEVICE_STATUS = 1;
pub const BACNET_DEVICE_STATUS_STATUS_DOWNLOAD_REQUIRED: BACNET_DEVICE_STATUS = 2;
pub const BACNET_DEVICE_STATUS_STATUS_DOWNLOAD_IN_PROGRESS: BACNET_DEVICE_STATUS = 3;
pub const BACNET_DEVICE_STATUS_STATUS_NON_OPERATIONAL: BACNET_DEVICE_STATUS = 4;
pub const BACNET_DEVICE_STATUS_STATUS_BACKUP_IN_PROGRESS: BACNET_DEVICE_STATUS = 5;
pub const BACNET_DEVICE_STATUS_MAX_DEVICE_STATUS: BACNET_DEVICE_STATUS = 6;
pub type BACNET_DEVICE_STATUS = ::std::os::raw::c_uint;
pub const BACNET_ENGINEERING_UNITS_UNITS_METERS_PER_SECOND_PER_SECOND: BACNET_ENGINEERING_UNITS =
    166;
pub const BACNET_ENGINEERING_UNITS_UNITS_SQUARE_METERS: BACNET_ENGINEERING_UNITS = 0;
pub const BACNET_ENGINEERING_UNITS_UNITS_SQUARE_CENTIMETERS: BACNET_ENGINEERING_UNITS = 116;
pub const BACNET_ENGINEERING_UNITS_UNITS_SQUARE_FEET: BACNET_ENGINEERING_UNITS = 1;
pub const BACNET_ENGINEERING_UNITS_UNITS_SQUARE_INCHES: BACNET_ENGINEERING_UNITS = 115;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY1: BACNET_ENGINEERING_UNITS = 105;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY2: BACNET_ENGINEERING_UNITS = 106;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY3: BACNET_ENGINEERING_UNITS = 107;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY4: BACNET_ENGINEERING_UNITS = 108;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY5: BACNET_ENGINEERING_UNITS = 109;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY6: BACNET_ENGINEERING_UNITS = 110;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY7: BACNET_ENGINEERING_UNITS = 111;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY8: BACNET_ENGINEERING_UNITS = 112;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY9: BACNET_ENGINEERING_UNITS = 113;
pub const BACNET_ENGINEERING_UNITS_UNITS_CURRENCY10: BACNET_ENGINEERING_UNITS = 114;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIAMPERES: BACNET_ENGINEERING_UNITS = 2;
pub const BACNET_ENGINEERING_UNITS_UNITS_AMPERES: BACNET_ENGINEERING_UNITS = 3;
pub const BACNET_ENGINEERING_UNITS_UNITS_AMPERES_PER_METER: BACNET_ENGINEERING_UNITS = 167;
pub const BACNET_ENGINEERING_UNITS_UNITS_AMPERES_PER_SQUARE_METER: BACNET_ENGINEERING_UNITS = 168;
pub const BACNET_ENGINEERING_UNITS_UNITS_AMPERE_SQUARE_METERS: BACNET_ENGINEERING_UNITS = 169;
pub const BACNET_ENGINEERING_UNITS_UNITS_DECIBELS: BACNET_ENGINEERING_UNITS = 199;
pub const BACNET_ENGINEERING_UNITS_UNITS_DECIBELS_MILLIVOLT: BACNET_ENGINEERING_UNITS = 200;
pub const BACNET_ENGINEERING_UNITS_UNITS_DECIBELS_VOLT: BACNET_ENGINEERING_UNITS = 201;
pub const BACNET_ENGINEERING_UNITS_UNITS_FARADS: BACNET_ENGINEERING_UNITS = 170;
pub const BACNET_ENGINEERING_UNITS_UNITS_HENRYS: BACNET_ENGINEERING_UNITS = 171;
pub const BACNET_ENGINEERING_UNITS_UNITS_OHMS: BACNET_ENGINEERING_UNITS = 4;
pub const BACNET_ENGINEERING_UNITS_UNITS_OHM_METERS: BACNET_ENGINEERING_UNITS = 172;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIOHMS: BACNET_ENGINEERING_UNITS = 145;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOHMS: BACNET_ENGINEERING_UNITS = 122;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGOHMS: BACNET_ENGINEERING_UNITS = 123;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROSIEMENS: BACNET_ENGINEERING_UNITS = 190;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLISIEMENS: BACNET_ENGINEERING_UNITS = 202;
pub const BACNET_ENGINEERING_UNITS_UNITS_SIEMENS: BACNET_ENGINEERING_UNITS = 173;
pub const BACNET_ENGINEERING_UNITS_UNITS_SIEMENS_PER_METER: BACNET_ENGINEERING_UNITS = 174;
pub const BACNET_ENGINEERING_UNITS_UNITS_TESLAS: BACNET_ENGINEERING_UNITS = 175;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLTS: BACNET_ENGINEERING_UNITS = 5;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIVOLTS: BACNET_ENGINEERING_UNITS = 124;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOVOLTS: BACNET_ENGINEERING_UNITS = 6;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAVOLTS: BACNET_ENGINEERING_UNITS = 7;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLT_AMPERES: BACNET_ENGINEERING_UNITS = 8;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOVOLT_AMPERES: BACNET_ENGINEERING_UNITS = 9;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAVOLT_AMPERES: BACNET_ENGINEERING_UNITS = 10;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLT_AMPERES_REACTIVE: BACNET_ENGINEERING_UNITS = 11;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOVOLT_AMPERES_REACTIVE: BACNET_ENGINEERING_UNITS = 12;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAVOLT_AMPERES_REACTIVE: BACNET_ENGINEERING_UNITS = 13;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLTS_PER_DEGREE_KELVIN: BACNET_ENGINEERING_UNITS = 176;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLTS_PER_METER: BACNET_ENGINEERING_UNITS = 177;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_PHASE: BACNET_ENGINEERING_UNITS = 14;
pub const BACNET_ENGINEERING_UNITS_UNITS_POWER_FACTOR: BACNET_ENGINEERING_UNITS = 15;
pub const BACNET_ENGINEERING_UNITS_UNITS_WEBERS: BACNET_ENGINEERING_UNITS = 178;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULES: BACNET_ENGINEERING_UNITS = 16;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOJOULES: BACNET_ENGINEERING_UNITS = 17;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOJOULES_PER_KILOGRAM: BACNET_ENGINEERING_UNITS = 125;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAJOULES: BACNET_ENGINEERING_UNITS = 126;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATT_HOURS: BACNET_ENGINEERING_UNITS = 18;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOWATT_HOURS: BACNET_ENGINEERING_UNITS = 19;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAWATT_HOURS: BACNET_ENGINEERING_UNITS = 146;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATT_HOURS_REACTIVE: BACNET_ENGINEERING_UNITS = 203;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOWATT_HOURS_REACTIVE: BACNET_ENGINEERING_UNITS = 204;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAWATT_HOURS_REACTIVE: BACNET_ENGINEERING_UNITS = 205;
pub const BACNET_ENGINEERING_UNITS_UNITS_BTUS: BACNET_ENGINEERING_UNITS = 20;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILO_BTUS: BACNET_ENGINEERING_UNITS = 147;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGA_BTUS: BACNET_ENGINEERING_UNITS = 148;
pub const BACNET_ENGINEERING_UNITS_UNITS_THERMS: BACNET_ENGINEERING_UNITS = 21;
pub const BACNET_ENGINEERING_UNITS_UNITS_TON_HOURS: BACNET_ENGINEERING_UNITS = 22;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULES_PER_KILOGRAM_DRY_AIR: BACNET_ENGINEERING_UNITS = 23;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOJOULES_PER_KILOGRAM_DRY_AIR: BACNET_ENGINEERING_UNITS =
    149;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAJOULES_PER_KILOGRAM_DRY_AIR: BACNET_ENGINEERING_UNITS =
    150;
pub const BACNET_ENGINEERING_UNITS_UNITS_BTUS_PER_POUND_DRY_AIR: BACNET_ENGINEERING_UNITS = 24;
pub const BACNET_ENGINEERING_UNITS_UNITS_BTUS_PER_POUND: BACNET_ENGINEERING_UNITS = 117;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULES_PER_DEGREE_KELVIN: BACNET_ENGINEERING_UNITS = 127;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOJOULES_PER_DEGREE_KELVIN: BACNET_ENGINEERING_UNITS =
    151;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAJOULES_PER_DEGREE_KELVIN: BACNET_ENGINEERING_UNITS =
    152;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULES_PER_KILOGRAM_DEGREE_KELVIN:
    BACNET_ENGINEERING_UNITS = 128;
pub const BACNET_ENGINEERING_UNITS_UNITS_NEWTON: BACNET_ENGINEERING_UNITS = 153;
pub const BACNET_ENGINEERING_UNITS_UNITS_CYCLES_PER_HOUR: BACNET_ENGINEERING_UNITS = 25;
pub const BACNET_ENGINEERING_UNITS_UNITS_CYCLES_PER_MINUTE: BACNET_ENGINEERING_UNITS = 26;
pub const BACNET_ENGINEERING_UNITS_UNITS_HERTZ: BACNET_ENGINEERING_UNITS = 27;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOHERTZ: BACNET_ENGINEERING_UNITS = 129;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAHERTZ: BACNET_ENGINEERING_UNITS = 130;
pub const BACNET_ENGINEERING_UNITS_UNITS_PER_HOUR: BACNET_ENGINEERING_UNITS = 131;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_OF_WATER_PER_KILOGRAM_DRY_AIR:
    BACNET_ENGINEERING_UNITS = 28;
pub const BACNET_ENGINEERING_UNITS_UNITS_PERCENT_RELATIVE_HUMIDITY: BACNET_ENGINEERING_UNITS = 29;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROMETERS: BACNET_ENGINEERING_UNITS = 194;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIMETERS: BACNET_ENGINEERING_UNITS = 30;
pub const BACNET_ENGINEERING_UNITS_UNITS_CENTIMETERS: BACNET_ENGINEERING_UNITS = 118;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOMETERS: BACNET_ENGINEERING_UNITS = 193;
pub const BACNET_ENGINEERING_UNITS_UNITS_METERS: BACNET_ENGINEERING_UNITS = 31;
pub const BACNET_ENGINEERING_UNITS_UNITS_INCHES: BACNET_ENGINEERING_UNITS = 32;
pub const BACNET_ENGINEERING_UNITS_UNITS_FEET: BACNET_ENGINEERING_UNITS = 33;
pub const BACNET_ENGINEERING_UNITS_UNITS_CANDELAS: BACNET_ENGINEERING_UNITS = 179;
pub const BACNET_ENGINEERING_UNITS_UNITS_CANDELAS_PER_SQUARE_METER: BACNET_ENGINEERING_UNITS = 180;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATTS_PER_SQUARE_FOOT: BACNET_ENGINEERING_UNITS = 34;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATTS_PER_SQUARE_METER: BACNET_ENGINEERING_UNITS = 35;
pub const BACNET_ENGINEERING_UNITS_UNITS_LUMENS: BACNET_ENGINEERING_UNITS = 36;
pub const BACNET_ENGINEERING_UNITS_UNITS_LUXES: BACNET_ENGINEERING_UNITS = 37;
pub const BACNET_ENGINEERING_UNITS_UNITS_FOOT_CANDLES: BACNET_ENGINEERING_UNITS = 38;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIGRAMS: BACNET_ENGINEERING_UNITS = 196;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS: BACNET_ENGINEERING_UNITS = 195;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOGRAMS: BACNET_ENGINEERING_UNITS = 39;
pub const BACNET_ENGINEERING_UNITS_UNITS_POUNDS_MASS: BACNET_ENGINEERING_UNITS = 40;
pub const BACNET_ENGINEERING_UNITS_UNITS_TONS: BACNET_ENGINEERING_UNITS = 41;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_SECOND: BACNET_ENGINEERING_UNITS = 154;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 155;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOGRAMS_PER_SECOND: BACNET_ENGINEERING_UNITS = 42;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOGRAMS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 43;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOGRAMS_PER_HOUR: BACNET_ENGINEERING_UNITS = 44;
pub const BACNET_ENGINEERING_UNITS_UNITS_POUNDS_MASS_PER_SECOND: BACNET_ENGINEERING_UNITS = 119;
pub const BACNET_ENGINEERING_UNITS_UNITS_POUNDS_MASS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 45;
pub const BACNET_ENGINEERING_UNITS_UNITS_POUNDS_MASS_PER_HOUR: BACNET_ENGINEERING_UNITS = 46;
pub const BACNET_ENGINEERING_UNITS_UNITS_TONS_PER_HOUR: BACNET_ENGINEERING_UNITS = 156;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIWATTS: BACNET_ENGINEERING_UNITS = 132;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATTS: BACNET_ENGINEERING_UNITS = 47;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOWATTS: BACNET_ENGINEERING_UNITS = 48;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAWATTS: BACNET_ENGINEERING_UNITS = 49;
pub const BACNET_ENGINEERING_UNITS_UNITS_BTUS_PER_HOUR: BACNET_ENGINEERING_UNITS = 50;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILO_BTUS_PER_HOUR: BACNET_ENGINEERING_UNITS = 157;
pub const BACNET_ENGINEERING_UNITS_UNITS_HORSEPOWER: BACNET_ENGINEERING_UNITS = 51;
pub const BACNET_ENGINEERING_UNITS_UNITS_TONS_REFRIGERATION: BACNET_ENGINEERING_UNITS = 52;
pub const BACNET_ENGINEERING_UNITS_UNITS_PASCALS: BACNET_ENGINEERING_UNITS = 53;
pub const BACNET_ENGINEERING_UNITS_UNITS_HECTOPASCALS: BACNET_ENGINEERING_UNITS = 133;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOPASCALS: BACNET_ENGINEERING_UNITS = 54;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIBARS: BACNET_ENGINEERING_UNITS = 134;
pub const BACNET_ENGINEERING_UNITS_UNITS_BARS: BACNET_ENGINEERING_UNITS = 55;
pub const BACNET_ENGINEERING_UNITS_UNITS_POUNDS_FORCE_PER_SQUARE_INCH: BACNET_ENGINEERING_UNITS =
    56;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIMETERS_OF_WATER: BACNET_ENGINEERING_UNITS = 206;
pub const BACNET_ENGINEERING_UNITS_UNITS_CENTIMETERS_OF_WATER: BACNET_ENGINEERING_UNITS = 57;
pub const BACNET_ENGINEERING_UNITS_UNITS_INCHES_OF_WATER: BACNET_ENGINEERING_UNITS = 58;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIMETERS_OF_MERCURY: BACNET_ENGINEERING_UNITS = 59;
pub const BACNET_ENGINEERING_UNITS_UNITS_CENTIMETERS_OF_MERCURY: BACNET_ENGINEERING_UNITS = 60;
pub const BACNET_ENGINEERING_UNITS_UNITS_INCHES_OF_MERCURY: BACNET_ENGINEERING_UNITS = 61;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_CELSIUS: BACNET_ENGINEERING_UNITS = 62;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_KELVIN: BACNET_ENGINEERING_UNITS = 63;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_KELVIN_PER_HOUR: BACNET_ENGINEERING_UNITS = 181;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_KELVIN_PER_MINUTE: BACNET_ENGINEERING_UNITS = 182;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_FAHRENHEIT: BACNET_ENGINEERING_UNITS = 64;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREE_DAYS_CELSIUS: BACNET_ENGINEERING_UNITS = 65;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREE_DAYS_FAHRENHEIT: BACNET_ENGINEERING_UNITS = 66;
pub const BACNET_ENGINEERING_UNITS_UNITS_DELTA_DEGREES_FAHRENHEIT: BACNET_ENGINEERING_UNITS = 120;
pub const BACNET_ENGINEERING_UNITS_UNITS_DELTA_DEGREES_KELVIN: BACNET_ENGINEERING_UNITS = 121;
pub const BACNET_ENGINEERING_UNITS_UNITS_YEARS: BACNET_ENGINEERING_UNITS = 67;
pub const BACNET_ENGINEERING_UNITS_UNITS_MONTHS: BACNET_ENGINEERING_UNITS = 68;
pub const BACNET_ENGINEERING_UNITS_UNITS_WEEKS: BACNET_ENGINEERING_UNITS = 69;
pub const BACNET_ENGINEERING_UNITS_UNITS_DAYS: BACNET_ENGINEERING_UNITS = 70;
pub const BACNET_ENGINEERING_UNITS_UNITS_HOURS: BACNET_ENGINEERING_UNITS = 71;
pub const BACNET_ENGINEERING_UNITS_UNITS_MINUTES: BACNET_ENGINEERING_UNITS = 72;
pub const BACNET_ENGINEERING_UNITS_UNITS_SECONDS: BACNET_ENGINEERING_UNITS = 73;
pub const BACNET_ENGINEERING_UNITS_UNITS_HUNDREDTHS_SECONDS: BACNET_ENGINEERING_UNITS = 158;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLISECONDS: BACNET_ENGINEERING_UNITS = 159;
pub const BACNET_ENGINEERING_UNITS_UNITS_NEWTON_METERS: BACNET_ENGINEERING_UNITS = 160;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIMETERS_PER_SECOND: BACNET_ENGINEERING_UNITS = 161;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIMETERS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 162;
pub const BACNET_ENGINEERING_UNITS_UNITS_METERS_PER_SECOND: BACNET_ENGINEERING_UNITS = 74;
pub const BACNET_ENGINEERING_UNITS_UNITS_METERS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 163;
pub const BACNET_ENGINEERING_UNITS_UNITS_METERS_PER_HOUR: BACNET_ENGINEERING_UNITS = 164;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOMETERS_PER_HOUR: BACNET_ENGINEERING_UNITS = 75;
pub const BACNET_ENGINEERING_UNITS_UNITS_FEET_PER_SECOND: BACNET_ENGINEERING_UNITS = 76;
pub const BACNET_ENGINEERING_UNITS_UNITS_FEET_PER_MINUTE: BACNET_ENGINEERING_UNITS = 77;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILES_PER_HOUR: BACNET_ENGINEERING_UNITS = 78;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_FEET: BACNET_ENGINEERING_UNITS = 79;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_METERS: BACNET_ENGINEERING_UNITS = 80;
pub const BACNET_ENGINEERING_UNITS_UNITS_IMPERIAL_GALLONS: BACNET_ENGINEERING_UNITS = 81;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLILITERS: BACNET_ENGINEERING_UNITS = 197;
pub const BACNET_ENGINEERING_UNITS_UNITS_LITERS: BACNET_ENGINEERING_UNITS = 82;
pub const BACNET_ENGINEERING_UNITS_UNITS_US_GALLONS: BACNET_ENGINEERING_UNITS = 83;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_FEET_PER_SECOND: BACNET_ENGINEERING_UNITS = 142;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_FEET_PER_MINUTE: BACNET_ENGINEERING_UNITS = 84;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_FEET_PER_HOUR: BACNET_ENGINEERING_UNITS = 191;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_METERS_PER_SECOND: BACNET_ENGINEERING_UNITS = 85;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_METERS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 165;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_METERS_PER_HOUR: BACNET_ENGINEERING_UNITS = 135;
pub const BACNET_ENGINEERING_UNITS_UNITS_IMPERIAL_GALLONS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 86;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLILITERS_PER_SECOND: BACNET_ENGINEERING_UNITS = 198;
pub const BACNET_ENGINEERING_UNITS_UNITS_LITERS_PER_SECOND: BACNET_ENGINEERING_UNITS = 87;
pub const BACNET_ENGINEERING_UNITS_UNITS_LITERS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 88;
pub const BACNET_ENGINEERING_UNITS_UNITS_LITERS_PER_HOUR: BACNET_ENGINEERING_UNITS = 136;
pub const BACNET_ENGINEERING_UNITS_UNITS_US_GALLONS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 89;
pub const BACNET_ENGINEERING_UNITS_UNITS_US_GALLONS_PER_HOUR: BACNET_ENGINEERING_UNITS = 192;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_ANGULAR: BACNET_ENGINEERING_UNITS = 90;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_CELSIUS_PER_HOUR: BACNET_ENGINEERING_UNITS = 91;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_CELSIUS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 92;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_FAHRENHEIT_PER_HOUR: BACNET_ENGINEERING_UNITS = 93;
pub const BACNET_ENGINEERING_UNITS_UNITS_DEGREES_FAHRENHEIT_PER_MINUTE: BACNET_ENGINEERING_UNITS =
    94;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULE_SECONDS: BACNET_ENGINEERING_UNITS = 183;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOGRAMS_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 186;
pub const BACNET_ENGINEERING_UNITS_UNITS_KW_HOURS_PER_SQUARE_METER: BACNET_ENGINEERING_UNITS = 137;
pub const BACNET_ENGINEERING_UNITS_UNITS_KW_HOURS_PER_SQUARE_FOOT: BACNET_ENGINEERING_UNITS = 138;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAJOULES_PER_SQUARE_METER: BACNET_ENGINEERING_UNITS =
    139;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAJOULES_PER_SQUARE_FOOT: BACNET_ENGINEERING_UNITS = 140;
pub const BACNET_ENGINEERING_UNITS_UNITS_NO_UNITS: BACNET_ENGINEERING_UNITS = 95;
pub const BACNET_ENGINEERING_UNITS_UNITS_NEWTON_SECONDS: BACNET_ENGINEERING_UNITS = 187;
pub const BACNET_ENGINEERING_UNITS_UNITS_NEWTONS_PER_METER: BACNET_ENGINEERING_UNITS = 188;
pub const BACNET_ENGINEERING_UNITS_UNITS_PARTS_PER_MILLION: BACNET_ENGINEERING_UNITS = 96;
pub const BACNET_ENGINEERING_UNITS_UNITS_PARTS_PER_BILLION: BACNET_ENGINEERING_UNITS = 97;
pub const BACNET_ENGINEERING_UNITS_UNITS_PERCENT: BACNET_ENGINEERING_UNITS = 98;
pub const BACNET_ENGINEERING_UNITS_UNITS_PERCENT_OBSCURATION_PER_FOOT: BACNET_ENGINEERING_UNITS =
    143;
pub const BACNET_ENGINEERING_UNITS_UNITS_PERCENT_OBSCURATION_PER_METER: BACNET_ENGINEERING_UNITS =
    144;
pub const BACNET_ENGINEERING_UNITS_UNITS_PERCENT_PER_SECOND: BACNET_ENGINEERING_UNITS = 99;
pub const BACNET_ENGINEERING_UNITS_UNITS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 100;
pub const BACNET_ENGINEERING_UNITS_UNITS_PER_SECOND: BACNET_ENGINEERING_UNITS = 101;
pub const BACNET_ENGINEERING_UNITS_UNITS_PSI_PER_DEGREE_FAHRENHEIT: BACNET_ENGINEERING_UNITS = 102;
pub const BACNET_ENGINEERING_UNITS_UNITS_RADIANS: BACNET_ENGINEERING_UNITS = 103;
pub const BACNET_ENGINEERING_UNITS_UNITS_RADIANS_PER_SECOND: BACNET_ENGINEERING_UNITS = 184;
pub const BACNET_ENGINEERING_UNITS_UNITS_REVOLUTIONS_PER_MINUTE: BACNET_ENGINEERING_UNITS = 104;
pub const BACNET_ENGINEERING_UNITS_UNITS_SQUARE_METERS_PER_NEWTON: BACNET_ENGINEERING_UNITS = 185;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATTS_PER_METER_PER_DEGREE_KELVIN:
    BACNET_ENGINEERING_UNITS = 189;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATTS_PER_SQUARE_METER_DEGREE_KELVIN:
    BACNET_ENGINEERING_UNITS = 141;
pub const BACNET_ENGINEERING_UNITS_UNITS_PER_MILLE: BACNET_ENGINEERING_UNITS = 207;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_GRAM: BACNET_ENGINEERING_UNITS = 208;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOGRAMS_PER_KILOGRAM: BACNET_ENGINEERING_UNITS = 209;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_KILOGRAM: BACNET_ENGINEERING_UNITS = 210;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIGRAMS_PER_GRAM: BACNET_ENGINEERING_UNITS = 211;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIGRAMS_PER_KILOGRAM: BACNET_ENGINEERING_UNITS = 212;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_MILLILITER: BACNET_ENGINEERING_UNITS = 213;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_LITER: BACNET_ENGINEERING_UNITS = 214;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIGRAMS_PER_LITER: BACNET_ENGINEERING_UNITS = 215;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROGRAMS_PER_LITER: BACNET_ENGINEERING_UNITS = 216;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 217;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIGRAMS_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 218;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROGRAMS_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 219;
pub const BACNET_ENGINEERING_UNITS_UNITS_NANOGRAMS_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 220;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_CUBIC_CENTIMETER: BACNET_ENGINEERING_UNITS = 221;
pub const BACNET_ENGINEERING_UNITS_UNITS_BECQUERELS: BACNET_ENGINEERING_UNITS = 222;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOBECQUERELS: BACNET_ENGINEERING_UNITS = 223;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGABECQUERELS: BACNET_ENGINEERING_UNITS = 224;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAY: BACNET_ENGINEERING_UNITS = 225;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIGRAY: BACNET_ENGINEERING_UNITS = 226;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROGRAY: BACNET_ENGINEERING_UNITS = 227;
pub const BACNET_ENGINEERING_UNITS_UNITS_SIEVERTS: BACNET_ENGINEERING_UNITS = 228;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLISIEVERTS: BACNET_ENGINEERING_UNITS = 229;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROSIEVERTS: BACNET_ENGINEERING_UNITS = 230;
pub const BACNET_ENGINEERING_UNITS_UNITS_MICROSIEVERTS_PER_HOUR: BACNET_ENGINEERING_UNITS = 231;
pub const BACNET_ENGINEERING_UNITS_UNITS_DECIBELS_A: BACNET_ENGINEERING_UNITS = 232;
pub const BACNET_ENGINEERING_UNITS_UNITS_NEPHELOMETRIC_TURBIDITY_UNIT: BACNET_ENGINEERING_UNITS =
    233;
pub const BACNET_ENGINEERING_UNITS_UNITS_PH: BACNET_ENGINEERING_UNITS = 234;
pub const BACNET_ENGINEERING_UNITS_UNITS_GRAMS_PER_SQUARE_METER: BACNET_ENGINEERING_UNITS = 235;
pub const BACNET_ENGINEERING_UNITS_UNITS_MINUTES_PER_DEGREE_KELVIN: BACNET_ENGINEERING_UNITS = 236;
pub const BACNET_ENGINEERING_UNITS_UNITS_OHM_METER_SQUARED_PER_METER: BACNET_ENGINEERING_UNITS =
    237;
pub const BACNET_ENGINEERING_UNITS_UNITS_AMPERE_SECONDS: BACNET_ENGINEERING_UNITS = 238;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLT_AMPERE_HOURS: BACNET_ENGINEERING_UNITS = 239;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOVOLT_AMPERE_HOURS: BACNET_ENGINEERING_UNITS = 240;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAVOLT_AMPERE_HOURS: BACNET_ENGINEERING_UNITS = 241;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLT_AMPERE_HOURS_REACTIVE: BACNET_ENGINEERING_UNITS = 242;
pub const BACNET_ENGINEERING_UNITS_UNITS_KILOVOLT_AMPERE_HOURS_REACTIVE: BACNET_ENGINEERING_UNITS =
    243;
pub const BACNET_ENGINEERING_UNITS_UNITS_MEGAVOLT_AMPERE_HOURS_REACTIVE: BACNET_ENGINEERING_UNITS =
    244;
pub const BACNET_ENGINEERING_UNITS_UNITS_VOLT_SQUARE_HOURS: BACNET_ENGINEERING_UNITS = 245;
pub const BACNET_ENGINEERING_UNITS_UNITS_AMPERE_SQUARE_HOURS: BACNET_ENGINEERING_UNITS = 246;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULE_PER_HOURS: BACNET_ENGINEERING_UNITS = 247;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_FEET_PER_DAY: BACNET_ENGINEERING_UNITS = 248;
pub const BACNET_ENGINEERING_UNITS_UNITS_CUBIC_METERS_PER_DAY: BACNET_ENGINEERING_UNITS = 249;
pub const BACNET_ENGINEERING_UNITS_UNITS_WATT_HOURS_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 250;
pub const BACNET_ENGINEERING_UNITS_UNITS_JOULES_PER_CUBIC_METER: BACNET_ENGINEERING_UNITS = 251;
pub const BACNET_ENGINEERING_UNITS_UNITS_MOLE_PERCENT: BACNET_ENGINEERING_UNITS = 252;
pub const BACNET_ENGINEERING_UNITS_UNITS_PASCAL_SECONDS: BACNET_ENGINEERING_UNITS = 253;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLION_STANDARD_CUBIC_FEET_PER_MINUTE:
    BACNET_ENGINEERING_UNITS = 254;
pub const BACNET_ENGINEERING_UNITS_UNITS_RESERVED_RANGE_MAX: BACNET_ENGINEERING_UNITS = 255;
pub const BACNET_ENGINEERING_UNITS_UNITS_PROPRIETARY_RANGE_MIN: BACNET_ENGINEERING_UNITS = 256;
pub const BACNET_ENGINEERING_UNITS_UNITS_PROPRIETARY_RANGE_MAX: BACNET_ENGINEERING_UNITS = 47807;
pub const BACNET_ENGINEERING_UNITS_UNITS_RESERVED_RANGE_MIN2: BACNET_ENGINEERING_UNITS = 47808;
pub const BACNET_ENGINEERING_UNITS_UNITS_STANDARD_CUBIC_FEET_PER_DAY: BACNET_ENGINEERING_UNITS =
    47808;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLION_STANDARD_CUBIC_FEET_PER_DAY:
    BACNET_ENGINEERING_UNITS = 47809;
pub const BACNET_ENGINEERING_UNITS_UNITS_THOUSAND_CUBIC_FEET_PER_DAY: BACNET_ENGINEERING_UNITS =
    47810;
pub const BACNET_ENGINEERING_UNITS_UNITS_THOUSAND_STANDARD_CUBIC_FEET_PER_DAY:
    BACNET_ENGINEERING_UNITS = 47811;
pub const BACNET_ENGINEERING_UNITS_UNITS_POUNDS_MASS_PER_DAY: BACNET_ENGINEERING_UNITS = 47812;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIREMS: BACNET_ENGINEERING_UNITS = 47814;
pub const BACNET_ENGINEERING_UNITS_UNITS_MILLIREMS_PER_HOUR: BACNET_ENGINEERING_UNITS = 47815;
pub const BACNET_ENGINEERING_UNITS_UNITS_RESERVED_RANGE_MAX2: BACNET_ENGINEERING_UNITS = 49999;
pub const BACNET_ENGINEERING_UNITS_UNITS_PROPRIETARY_RANGE_MIN2: BACNET_ENGINEERING_UNITS = 50000;
pub const BACNET_ENGINEERING_UNITS_UNITS_PROPRIETARY_RANGE_MAX2: BACNET_ENGINEERING_UNITS = 65535;
pub type BACNET_ENGINEERING_UNITS = ::std::os::raw::c_uint;
pub const BACNET_POLARITY_POLARITY_NORMAL: BACNET_POLARITY = 0;
pub const BACNET_POLARITY_POLARITY_REVERSE: BACNET_POLARITY = 1;
pub const BACNET_POLARITY_MAX_POLARITY: BACNET_POLARITY = 2;
pub type BACNET_POLARITY = ::std::os::raw::c_uint;
pub const BACNET_PROGRAM_REQUEST_PROGRAM_REQUEST_READY: BACNET_PROGRAM_REQUEST = 0;
pub const BACNET_PROGRAM_REQUEST_PROGRAM_REQUEST_LOAD: BACNET_PROGRAM_REQUEST = 1;
pub const BACNET_PROGRAM_REQUEST_PROGRAM_REQUEST_RUN: BACNET_PROGRAM_REQUEST = 2;
pub const BACNET_PROGRAM_REQUEST_PROGRAM_REQUEST_HALT: BACNET_PROGRAM_REQUEST = 3;
pub const BACNET_PROGRAM_REQUEST_PROGRAM_REQUEST_RESTART: BACNET_PROGRAM_REQUEST = 4;
pub const BACNET_PROGRAM_REQUEST_PROGRAM_REQUEST_UNLOAD: BACNET_PROGRAM_REQUEST = 5;
pub type BACNET_PROGRAM_REQUEST = ::std::os::raw::c_uint;
pub const BACNET_PROGRAM_STATE_PROGRAM_STATE_IDLE: BACNET_PROGRAM_STATE = 0;
pub const BACNET_PROGRAM_STATE_PROGRAM_STATE_LOADING: BACNET_PROGRAM_STATE = 1;
pub const BACNET_PROGRAM_STATE_PROGRAM_STATE_RUNNING: BACNET_PROGRAM_STATE = 2;
pub const BACNET_PROGRAM_STATE_PROGRAM_STATE_WAITING: BACNET_PROGRAM_STATE = 3;
pub const BACNET_PROGRAM_STATE_PROGRAM_STATE_HALTED: BACNET_PROGRAM_STATE = 4;
pub const BACNET_PROGRAM_STATE_PROGRAM_STATE_UNLOADING: BACNET_PROGRAM_STATE = 5;
pub type BACNET_PROGRAM_STATE = ::std::os::raw::c_uint;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_NORMAL: BACNET_PROGRAM_ERROR = 0;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_LOAD_FAILED: BACNET_PROGRAM_ERROR = 1;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_INTERNAL: BACNET_PROGRAM_ERROR = 2;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_PROGRAM: BACNET_PROGRAM_ERROR = 3;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_OTHER: BACNET_PROGRAM_ERROR = 4;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_PROPRIETARY_MIN: BACNET_PROGRAM_ERROR = 64;
pub const BACNET_PROGRAM_ERROR_PROGRAM_ERROR_PROPRIETARY_MAX: BACNET_PROGRAM_ERROR = 65535;
pub type BACNET_PROGRAM_ERROR = ::std::os::raw::c_uint;
pub const BACNET_RESTART_REASON_RESTART_REASON_UNKNOWN: BACNET_RESTART_REASON = 0;
pub const BACNET_RESTART_REASON_RESTART_REASON_COLDSTART: BACNET_RESTART_REASON = 1;
pub const BACNET_RESTART_REASON_RESTART_REASON_WARMSTART: BACNET_RESTART_REASON = 2;
pub const BACNET_RESTART_REASON_RESTART_REASON_DETECTED_POWER_LOST: BACNET_RESTART_REASON = 3;
pub const BACNET_RESTART_REASON_RESTART_REASON_DETECTED_POWER_OFF: BACNET_RESTART_REASON = 4;
pub const BACNET_RESTART_REASON_RESTART_REASON_HARDWARE_WATCHDOG: BACNET_RESTART_REASON = 5;
pub const BACNET_RESTART_REASON_RESTART_REASON_SOFTWARE_WATCHDOG: BACNET_RESTART_REASON = 6;
pub const BACNET_RESTART_REASON_RESTART_REASON_SUSPENDED: BACNET_RESTART_REASON = 7;
pub const BACNET_RESTART_REASON_RESTART_REASON_PROPRIETARY_MIN: BACNET_RESTART_REASON = 64;
pub const BACNET_RESTART_REASON_RESTART_REASON_PROPRIETARY_MAX: BACNET_RESTART_REASON = 255;
pub type BACNET_RESTART_REASON = ::std::os::raw::c_uint;
pub const BACNET_PROPERTY_STATES_PROP_STATE_BOOLEAN_VALUE: BACNET_PROPERTY_STATES = 0;
pub const BACNET_PROPERTY_STATES_PROP_STATE_BINARY_VALUE: BACNET_PROPERTY_STATES = 1;
pub const BACNET_PROPERTY_STATES_PROP_STATE_EVENT_TYPE: BACNET_PROPERTY_STATES = 2;
pub const BACNET_PROPERTY_STATES_PROP_STATE_POLARITY: BACNET_PROPERTY_STATES = 3;
pub const BACNET_PROPERTY_STATES_PROP_STATE_PROGRAM_CHANGE: BACNET_PROPERTY_STATES = 4;
pub const BACNET_PROPERTY_STATES_PROP_STATE_PROGRAM_STATE: BACNET_PROPERTY_STATES = 5;
pub const BACNET_PROPERTY_STATES_PROP_STATE_REASON_FOR_HALT: BACNET_PROPERTY_STATES = 6;
pub const BACNET_PROPERTY_STATES_PROP_STATE_RELIABILITY: BACNET_PROPERTY_STATES = 7;
pub const BACNET_PROPERTY_STATES_PROP_STATE_EVENT_STATE: BACNET_PROPERTY_STATES = 8;
pub const BACNET_PROPERTY_STATES_PROP_STATE_SYSTEM_STATUS: BACNET_PROPERTY_STATES = 9;
pub const BACNET_PROPERTY_STATES_PROP_STATE_UNITS: BACNET_PROPERTY_STATES = 10;
pub const BACNET_PROPERTY_STATES_PROP_STATE_UNSIGNED_VALUE: BACNET_PROPERTY_STATES = 11;
pub const BACNET_PROPERTY_STATES_PROP_STATE_LIFE_SAFETY_MODE: BACNET_PROPERTY_STATES = 12;
pub const BACNET_PROPERTY_STATES_PROP_STATE_LIFE_SAFETY_STATE: BACNET_PROPERTY_STATES = 13;
pub const BACNET_PROPERTY_STATES_PROP_STATE_RESTART_REASON: BACNET_PROPERTY_STATES = 14;
pub const BACNET_PROPERTY_STATES_PROP_STATE_DOOR_ALARM_STATE: BACNET_PROPERTY_STATES = 15;
pub const BACNET_PROPERTY_STATES_PROP_STATE_ACTION: BACNET_PROPERTY_STATES = 16;
pub const BACNET_PROPERTY_STATES_PROP_STATE_DOOR_SECURED_STATUS: BACNET_PROPERTY_STATES = 17;
pub const BACNET_PROPERTY_STATES_PROP_STATE_DOOR_STATUS: BACNET_PROPERTY_STATES = 18;
pub const BACNET_PROPERTY_STATES_PROP_STATE_DOOR_VALUE: BACNET_PROPERTY_STATES = 19;
pub const BACNET_PROPERTY_STATES_PROP_STATE_FILE_ACCESS_METHOD: BACNET_PROPERTY_STATES = 20;
pub const BACNET_PROPERTY_STATES_PROP_STATE_LOCK_STATUS: BACNET_PROPERTY_STATES = 21;
pub const BACNET_PROPERTY_STATES_PROP_STATE_LIFE_SAFETY_OPERATION: BACNET_PROPERTY_STATES = 22;
pub const BACNET_PROPERTY_STATES_PROP_STATE_MAINTENANCE: BACNET_PROPERTY_STATES = 23;
pub const BACNET_PROPERTY_STATES_PROP_STATE_NODE_TYPE: BACNET_PROPERTY_STATES = 24;
pub const BACNET_PROPERTY_STATES_PROP_STATE_NOTIFY_TYPE: BACNET_PROPERTY_STATES = 25;
pub const BACNET_PROPERTY_STATES_PROP_STATE_SECURITY_LEVEL: BACNET_PROPERTY_STATES = 26;
pub const BACNET_PROPERTY_STATES_PROP_STATE_SHED_STATE: BACNET_PROPERTY_STATES = 27;
pub const BACNET_PROPERTY_STATES_PROP_STATE_SILENCED_STATE: BACNET_PROPERTY_STATES = 28;
pub const BACNET_PROPERTY_STATES_PROP_STATE_ACCESS_EVENT: BACNET_PROPERTY_STATES = 30;
pub const BACNET_PROPERTY_STATES_PROP_STATE_ZONE_OCCUPANCY_STATE: BACNET_PROPERTY_STATES = 31;
pub const BACNET_PROPERTY_STATES_PROP_STATE_ACCESS_CRED_DISABLE_REASON: BACNET_PROPERTY_STATES = 32;
pub const BACNET_PROPERTY_STATES_PROP_STATE_ACCESS_CRED_DISABLE: BACNET_PROPERTY_STATES = 33;
pub const BACNET_PROPERTY_STATES_PROP_STATE_AUTHENTICATION_STATUS: BACNET_PROPERTY_STATES = 34;
pub type BACNET_PROPERTY_STATES = ::std::os::raw::c_uint;
pub const BACNET_RELIABILITY_RELIABILITY_NO_FAULT_DETECTED: BACNET_RELIABILITY = 0;
pub const BACNET_RELIABILITY_RELIABILITY_NO_SENSOR: BACNET_RELIABILITY = 1;
pub const BACNET_RELIABILITY_RELIABILITY_OVER_RANGE: BACNET_RELIABILITY = 2;
pub const BACNET_RELIABILITY_RELIABILITY_UNDER_RANGE: BACNET_RELIABILITY = 3;
pub const BACNET_RELIABILITY_RELIABILITY_OPEN_LOOP: BACNET_RELIABILITY = 4;
pub const BACNET_RELIABILITY_RELIABILITY_SHORTED_LOOP: BACNET_RELIABILITY = 5;
pub const BACNET_RELIABILITY_RELIABILITY_NO_OUTPUT: BACNET_RELIABILITY = 6;
pub const BACNET_RELIABILITY_RELIABILITY_UNRELIABLE_OTHER: BACNET_RELIABILITY = 7;
pub const BACNET_RELIABILITY_RELIABILITY_PROCESS_ERROR: BACNET_RELIABILITY = 8;
pub const BACNET_RELIABILITY_RELIABILITY_MULTI_STATE_FAULT: BACNET_RELIABILITY = 9;
pub const BACNET_RELIABILITY_RELIABILITY_CONFIGURATION_ERROR: BACNET_RELIABILITY = 10;
pub const BACNET_RELIABILITY_RELIABILITY_RESERVED_11: BACNET_RELIABILITY = 11;
pub const BACNET_RELIABILITY_RELIABILITY_COMMUNICATION_FAILURE: BACNET_RELIABILITY = 12;
pub const BACNET_RELIABILITY_RELIABILITY_MEMBER_FAULT: BACNET_RELIABILITY = 13;
pub const BACNET_RELIABILITY_RELIABILITY_MONITORED_OBJECT_FAULT: BACNET_RELIABILITY = 14;
pub const BACNET_RELIABILITY_RELIABILITY_TRIPPED: BACNET_RELIABILITY = 15;
pub const BACNET_RELIABILITY_RELIABILITY_LAMP_FAILURE: BACNET_RELIABILITY = 16;
pub const BACNET_RELIABILITY_RELIABILITY_ACTIVATION_FAILURE: BACNET_RELIABILITY = 17;
pub const BACNET_RELIABILITY_RELIABILITY_RENEW_DHCP_FAILURE: BACNET_RELIABILITY = 18;
pub const BACNET_RELIABILITY_RELIABILITY_RENEW_FD_REGISTRATION_FAILURE: BACNET_RELIABILITY = 19;
pub const BACNET_RELIABILITY_RELIABILITY_RESTART_AUTO_NEGOTIATION_FAILURE: BACNET_RELIABILITY = 20;
pub const BACNET_RELIABILITY_RELIABILITY_RESTART_FAILURE: BACNET_RELIABILITY = 21;
pub const BACNET_RELIABILITY_RELIABILITY_PROPRIETARY_COMMAND_FAILURE: BACNET_RELIABILITY = 22;
pub const BACNET_RELIABILITY_RELIABILITY_FAULTS_LISTED: BACNET_RELIABILITY = 23;
pub const BACNET_RELIABILITY_RELIABILITY_REFERENCED_OBJECT_FAULT: BACNET_RELIABILITY = 24;
pub const BACNET_RELIABILITY_RELIABILITY_MULTI_STATE_OUT_OF_RANGE: BACNET_RELIABILITY = 25;
pub const BACNET_RELIABILITY_RELIABILITY_PROPRIETARY_MIN: BACNET_RELIABILITY = 64;
pub const BACNET_RELIABILITY_RELIABILITY_PROPRIETARY_MAX: BACNET_RELIABILITY = 65535;
pub type BACNET_RELIABILITY = ::std::os::raw::c_uint;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_BITSTRING: BACNET_EVENT_TYPE = 0;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_STATE: BACNET_EVENT_TYPE = 1;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_VALUE: BACNET_EVENT_TYPE = 2;
pub const BACNET_EVENT_TYPE_EVENT_COMMAND_FAILURE: BACNET_EVENT_TYPE = 3;
pub const BACNET_EVENT_TYPE_EVENT_FLOATING_LIMIT: BACNET_EVENT_TYPE = 4;
pub const BACNET_EVENT_TYPE_EVENT_OUT_OF_RANGE: BACNET_EVENT_TYPE = 5;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_LIFE_SAFETY: BACNET_EVENT_TYPE = 8;
pub const BACNET_EVENT_TYPE_EVENT_EXTENDED: BACNET_EVENT_TYPE = 9;
pub const BACNET_EVENT_TYPE_EVENT_BUFFER_READY: BACNET_EVENT_TYPE = 10;
pub const BACNET_EVENT_TYPE_EVENT_UNSIGNED_RANGE: BACNET_EVENT_TYPE = 11;
pub const BACNET_EVENT_TYPE_EVENT_ACCESS_EVENT: BACNET_EVENT_TYPE = 13;
pub const BACNET_EVENT_TYPE_EVENT_DOUBLE_OUT_OF_RANGE: BACNET_EVENT_TYPE = 14;
pub const BACNET_EVENT_TYPE_EVENT_SIGNED_OUT_OF_RANGE: BACNET_EVENT_TYPE = 15;
pub const BACNET_EVENT_TYPE_EVENT_UNSIGNED_OUT_OF_RANGE: BACNET_EVENT_TYPE = 16;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_CHARACTERSTRING: BACNET_EVENT_TYPE = 17;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_STATUS_FLAGS: BACNET_EVENT_TYPE = 18;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_RELIABILITY: BACNET_EVENT_TYPE = 19;
pub const BACNET_EVENT_TYPE_EVENT_NONE: BACNET_EVENT_TYPE = 20;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_DISCRETE_VALUE: BACNET_EVENT_TYPE = 21;
pub const BACNET_EVENT_TYPE_EVENT_CHANGE_OF_TIMER: BACNET_EVENT_TYPE = 22;
pub const BACNET_EVENT_TYPE_EVENT_PROPRIETARY_MIN: BACNET_EVENT_TYPE = 64;
pub const BACNET_EVENT_TYPE_EVENT_PROPRIETARY_MAX: BACNET_EVENT_TYPE = 65535;
pub type BACNET_EVENT_TYPE = ::std::os::raw::c_uint;
pub const BACNET_FILE_ACCESS_METHOD_FILE_RECORD_ACCESS: BACNET_FILE_ACCESS_METHOD = 0;
pub const BACNET_FILE_ACCESS_METHOD_FILE_STREAM_ACCESS: BACNET_FILE_ACCESS_METHOD = 1;
pub const BACNET_FILE_ACCESS_METHOD_FILE_RECORD_AND_STREAM_ACCESS: BACNET_FILE_ACCESS_METHOD = 2;
pub type BACNET_FILE_ACCESS_METHOD = ::std::os::raw::c_uint;
pub const BACNET_LIFE_SAFETY_MODE_MIN_LIFE_SAFETY_MODE: BACNET_LIFE_SAFETY_MODE = 0;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_OFF: BACNET_LIFE_SAFETY_MODE = 0;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_ON: BACNET_LIFE_SAFETY_MODE = 1;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_TEST: BACNET_LIFE_SAFETY_MODE = 2;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_MANNED: BACNET_LIFE_SAFETY_MODE = 3;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_UNMANNED: BACNET_LIFE_SAFETY_MODE = 4;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_ARMED: BACNET_LIFE_SAFETY_MODE = 5;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_DISARMED: BACNET_LIFE_SAFETY_MODE = 6;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_PREARMED: BACNET_LIFE_SAFETY_MODE = 7;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_SLOW: BACNET_LIFE_SAFETY_MODE = 8;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_FAST: BACNET_LIFE_SAFETY_MODE = 9;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_DISCONNECTED: BACNET_LIFE_SAFETY_MODE = 10;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_ENABLED: BACNET_LIFE_SAFETY_MODE = 11;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_DISABLED: BACNET_LIFE_SAFETY_MODE = 12;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_AUTOMATIC_RELEASE_DISABLED:
    BACNET_LIFE_SAFETY_MODE = 13;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_DEFAULT: BACNET_LIFE_SAFETY_MODE = 14;
pub const BACNET_LIFE_SAFETY_MODE_MAX_LIFE_SAFETY_MODE: BACNET_LIFE_SAFETY_MODE = 15;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_PROPRIETARY_MIN: BACNET_LIFE_SAFETY_MODE = 256;
pub const BACNET_LIFE_SAFETY_MODE_LIFE_SAFETY_MODE_PROPRIETARY_MAX: BACNET_LIFE_SAFETY_MODE = 65535;
pub type BACNET_LIFE_SAFETY_MODE = ::std::os::raw::c_uint;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_NONE: BACNET_LIFE_SAFETY_OPERATION = 0;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_SILENCE: BACNET_LIFE_SAFETY_OPERATION = 1;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_SILENCE_AUDIBLE:
    BACNET_LIFE_SAFETY_OPERATION = 2;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_SILENCE_VISUAL: BACNET_LIFE_SAFETY_OPERATION =
    3;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_RESET: BACNET_LIFE_SAFETY_OPERATION = 4;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_RESET_ALARM: BACNET_LIFE_SAFETY_OPERATION = 5;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_RESET_FAULT: BACNET_LIFE_SAFETY_OPERATION = 6;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_UNSILENCE: BACNET_LIFE_SAFETY_OPERATION = 7;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_UNSILENCE_AUDIBLE:
    BACNET_LIFE_SAFETY_OPERATION = 8;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_UNSILENCE_VISUAL:
    BACNET_LIFE_SAFETY_OPERATION = 9;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_PROPRIETARY_MIN:
    BACNET_LIFE_SAFETY_OPERATION = 64;
pub const BACNET_LIFE_SAFETY_OPERATION_LIFE_SAFETY_OP_PROPRIETARY_MAX:
    BACNET_LIFE_SAFETY_OPERATION = 65535;
pub type BACNET_LIFE_SAFETY_OPERATION = ::std::os::raw::c_uint;
pub const BACNET_LIFE_SAFETY_STATE_MIN_LIFE_SAFETY_STATE: BACNET_LIFE_SAFETY_STATE = 0;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_QUIET: BACNET_LIFE_SAFETY_STATE = 0;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_PRE_ALARM: BACNET_LIFE_SAFETY_STATE = 1;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_ALARM: BACNET_LIFE_SAFETY_STATE = 2;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_FAULT: BACNET_LIFE_SAFETY_STATE = 3;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_FAULT_PRE_ALARM: BACNET_LIFE_SAFETY_STATE = 4;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_FAULT_ALARM: BACNET_LIFE_SAFETY_STATE = 5;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_NOT_READY: BACNET_LIFE_SAFETY_STATE = 6;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_ACTIVE: BACNET_LIFE_SAFETY_STATE = 7;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TAMPER: BACNET_LIFE_SAFETY_STATE = 8;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TEST_ALARM: BACNET_LIFE_SAFETY_STATE = 9;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TEST_ACTIVE: BACNET_LIFE_SAFETY_STATE = 10;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TEST_FAULT: BACNET_LIFE_SAFETY_STATE = 11;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TEST_FAULT_ALARM: BACNET_LIFE_SAFETY_STATE =
    12;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_HOLDUP: BACNET_LIFE_SAFETY_STATE = 13;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_DURESS: BACNET_LIFE_SAFETY_STATE = 14;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TAMPER_ALARM: BACNET_LIFE_SAFETY_STATE = 15;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_ABNORMAL: BACNET_LIFE_SAFETY_STATE = 16;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_EMERGENCY_POWER: BACNET_LIFE_SAFETY_STATE = 17;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_DELAYED: BACNET_LIFE_SAFETY_STATE = 18;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_BLOCKED: BACNET_LIFE_SAFETY_STATE = 19;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_LOCAL_ALARM: BACNET_LIFE_SAFETY_STATE = 20;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_GENERAL_ALARM: BACNET_LIFE_SAFETY_STATE = 21;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_SUPERVISORY: BACNET_LIFE_SAFETY_STATE = 22;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_TEST_SUPERVISORY: BACNET_LIFE_SAFETY_STATE =
    23;
pub const BACNET_LIFE_SAFETY_STATE_MAX_LIFE_SAFETY_STATE: BACNET_LIFE_SAFETY_STATE = 24;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_PROPRIETARY_MIN: BACNET_LIFE_SAFETY_STATE =
    256;
pub const BACNET_LIFE_SAFETY_STATE_LIFE_SAFETY_STATE_PROPRIETARY_MAX: BACNET_LIFE_SAFETY_STATE =
    65535;
pub type BACNET_LIFE_SAFETY_STATE = ::std::os::raw::c_uint;
pub const BACNET_SILENCED_STATE_SILENCED_STATE_UNSILENCED: BACNET_SILENCED_STATE = 0;
pub const BACNET_SILENCED_STATE_SILENCED_STATE_AUDIBLE_SILENCED: BACNET_SILENCED_STATE = 1;
pub const BACNET_SILENCED_STATE_SILENCED_STATE_VISIBLE_SILENCED: BACNET_SILENCED_STATE = 2;
pub const BACNET_SILENCED_STATE_SILENCED_STATE_ALL_SILENCED: BACNET_SILENCED_STATE = 3;
pub const BACNET_SILENCED_STATE_SILENCED_STATE_PROPRIETARY_MIN: BACNET_SILENCED_STATE = 64;
pub const BACNET_SILENCED_STATE_SILENCED_STATE_PROPRIETARY_MAX: BACNET_SILENCED_STATE = 65535;
pub type BACNET_SILENCED_STATE = ::std::os::raw::c_uint;
pub const BACNET_MAINTENANCE_MAINTENANCE_NONE: BACNET_MAINTENANCE = 0;
pub const BACNET_MAINTENANCE_MAINTENANCE_PERIODIC_TEST: BACNET_MAINTENANCE = 1;
pub const BACNET_MAINTENANCE_MAINTENANCE_NEED_SERVICE_OPERATIONAL: BACNET_MAINTENANCE = 2;
pub const BACNET_MAINTENANCE_MAINTENANCE_NEED_SERVICE_INOPERATIVE: BACNET_MAINTENANCE = 3;
pub const BACNET_MAINTENANCE_MAINTENANCE_PROPRIETARY_MIN: BACNET_MAINTENANCE = 256;
pub const BACNET_MAINTENANCE_MAINTENANCE_PROPRIETARY_MAX: BACNET_MAINTENANCE = 65535;
pub type BACNET_MAINTENANCE = ::std::os::raw::c_uint;
pub const BACNET_NOTIFY_TYPE_NOTIFY_ALARM: BACNET_NOTIFY_TYPE = 0;
pub const BACNET_NOTIFY_TYPE_NOTIFY_EVENT: BACNET_NOTIFY_TYPE = 1;
pub const BACNET_NOTIFY_TYPE_NOTIFY_ACK_NOTIFICATION: BACNET_NOTIFY_TYPE = 2;
pub const BACNET_NOTIFY_TYPE_NOTIFY_MAX: BACNET_NOTIFY_TYPE = 3;
pub type BACNET_NOTIFY_TYPE = ::std::os::raw::c_uint;
pub const BACnetObjectType_OBJECT_ANALOG_INPUT: BACnetObjectType = 0;
pub const BACnetObjectType_OBJECT_ANALOG_OUTPUT: BACnetObjectType = 1;
pub const BACnetObjectType_OBJECT_ANALOG_VALUE: BACnetObjectType = 2;
pub const BACnetObjectType_OBJECT_BINARY_INPUT: BACnetObjectType = 3;
pub const BACnetObjectType_OBJECT_BINARY_OUTPUT: BACnetObjectType = 4;
pub const BACnetObjectType_OBJECT_BINARY_VALUE: BACnetObjectType = 5;
pub const BACnetObjectType_OBJECT_CALENDAR: BACnetObjectType = 6;
pub const BACnetObjectType_OBJECT_COMMAND: BACnetObjectType = 7;
pub const BACnetObjectType_OBJECT_DEVICE: BACnetObjectType = 8;
pub const BACnetObjectType_OBJECT_EVENT_ENROLLMENT: BACnetObjectType = 9;
pub const BACnetObjectType_OBJECT_FILE: BACnetObjectType = 10;
pub const BACnetObjectType_OBJECT_GROUP: BACnetObjectType = 11;
pub const BACnetObjectType_OBJECT_LOOP: BACnetObjectType = 12;
pub const BACnetObjectType_OBJECT_MULTI_STATE_INPUT: BACnetObjectType = 13;
pub const BACnetObjectType_OBJECT_MULTI_STATE_OUTPUT: BACnetObjectType = 14;
pub const BACnetObjectType_OBJECT_NOTIFICATION_CLASS: BACnetObjectType = 15;
pub const BACnetObjectType_OBJECT_PROGRAM: BACnetObjectType = 16;
pub const BACnetObjectType_OBJECT_SCHEDULE: BACnetObjectType = 17;
pub const BACnetObjectType_OBJECT_AVERAGING: BACnetObjectType = 18;
pub const BACnetObjectType_OBJECT_MULTI_STATE_VALUE: BACnetObjectType = 19;
pub const BACnetObjectType_OBJECT_TRENDLOG: BACnetObjectType = 20;
pub const BACnetObjectType_OBJECT_LIFE_SAFETY_POINT: BACnetObjectType = 21;
pub const BACnetObjectType_OBJECT_LIFE_SAFETY_ZONE: BACnetObjectType = 22;
pub const BACnetObjectType_OBJECT_ACCUMULATOR: BACnetObjectType = 23;
pub const BACnetObjectType_OBJECT_PULSE_CONVERTER: BACnetObjectType = 24;
pub const BACnetObjectType_OBJECT_EVENT_LOG: BACnetObjectType = 25;
pub const BACnetObjectType_OBJECT_GLOBAL_GROUP: BACnetObjectType = 26;
pub const BACnetObjectType_OBJECT_TREND_LOG_MULTIPLE: BACnetObjectType = 27;
pub const BACnetObjectType_OBJECT_LOAD_CONTROL: BACnetObjectType = 28;
pub const BACnetObjectType_OBJECT_STRUCTURED_VIEW: BACnetObjectType = 29;
pub const BACnetObjectType_OBJECT_ACCESS_DOOR: BACnetObjectType = 30;
pub const BACnetObjectType_OBJECT_TIMER: BACnetObjectType = 31;
pub const BACnetObjectType_OBJECT_ACCESS_CREDENTIAL: BACnetObjectType = 32;
pub const BACnetObjectType_OBJECT_ACCESS_POINT: BACnetObjectType = 33;
pub const BACnetObjectType_OBJECT_ACCESS_RIGHTS: BACnetObjectType = 34;
pub const BACnetObjectType_OBJECT_ACCESS_USER: BACnetObjectType = 35;
pub const BACnetObjectType_OBJECT_ACCESS_ZONE: BACnetObjectType = 36;
pub const BACnetObjectType_OBJECT_CREDENTIAL_DATA_INPUT: BACnetObjectType = 37;
pub const BACnetObjectType_OBJECT_NETWORK_SECURITY: BACnetObjectType = 38;
pub const BACnetObjectType_OBJECT_BITSTRING_VALUE: BACnetObjectType = 39;
pub const BACnetObjectType_OBJECT_CHARACTERSTRING_VALUE: BACnetObjectType = 40;
pub const BACnetObjectType_OBJECT_DATE_PATTERN_VALUE: BACnetObjectType = 41;
pub const BACnetObjectType_OBJECT_DATE_VALUE: BACnetObjectType = 42;
pub const BACnetObjectType_OBJECT_DATETIME_PATTERN_VALUE: BACnetObjectType = 43;
pub const BACnetObjectType_OBJECT_DATETIME_VALUE: BACnetObjectType = 44;
pub const BACnetObjectType_OBJECT_INTEGER_VALUE: BACnetObjectType = 45;
pub const BACnetObjectType_OBJECT_LARGE_ANALOG_VALUE: BACnetObjectType = 46;
pub const BACnetObjectType_OBJECT_OCTETSTRING_VALUE: BACnetObjectType = 47;
pub const BACnetObjectType_OBJECT_POSITIVE_INTEGER_VALUE: BACnetObjectType = 48;
pub const BACnetObjectType_OBJECT_TIME_PATTERN_VALUE: BACnetObjectType = 49;
pub const BACnetObjectType_OBJECT_TIME_VALUE: BACnetObjectType = 50;
pub const BACnetObjectType_OBJECT_NOTIFICATION_FORWARDER: BACnetObjectType = 51;
pub const BACnetObjectType_OBJECT_ALERT_ENROLLMENT: BACnetObjectType = 52;
pub const BACnetObjectType_OBJECT_CHANNEL: BACnetObjectType = 53;
pub const BACnetObjectType_OBJECT_LIGHTING_OUTPUT: BACnetObjectType = 54;
pub const BACnetObjectType_OBJECT_BINARY_LIGHTING_OUTPUT: BACnetObjectType = 55;
pub const BACnetObjectType_OBJECT_NETWORK_PORT: BACnetObjectType = 56;
pub const BACnetObjectType_OBJECT_ELEVATOR_GROUP: BACnetObjectType = 57;
pub const BACnetObjectType_OBJECT_ESCALATOR: BACnetObjectType = 58;
pub const BACnetObjectType_OBJECT_LIFT: BACnetObjectType = 59;
pub const BACnetObjectType_OBJECT_STAGING: BACnetObjectType = 60;
pub const BACnetObjectType_OBJECT_AUDIT_LOG: BACnetObjectType = 61;
pub const BACnetObjectType_OBJECT_AUDIT_REPORTER: BACnetObjectType = 62;
pub const BACnetObjectType_OBJECT_COLOR: BACnetObjectType = 63;
pub const BACnetObjectType_OBJECT_COLOR_TEMPERATURE: BACnetObjectType = 64;
pub const BACnetObjectType_BACNET_OBJECT_TYPE_LAST: BACnetObjectType = 64;
pub const BACnetObjectType_BACNET_OBJECT_TYPE_RESERVED_MAX: BACnetObjectType = 127;
pub const BACnetObjectType_OBJECT_PROPRIETARY_MIN: BACnetObjectType = 128;
pub const BACnetObjectType_OBJECT_PROPRIETARY_MAX: BACnetObjectType = 1023;
pub const BACnetObjectType_MAX_BACNET_OBJECT_TYPE: BACnetObjectType = 1024;
pub const BACnetObjectType_OBJECT_NONE: BACnetObjectType = 65535;
pub type BACnetObjectType = ::std::os::raw::c_uint;
pub use self::BACnetObjectType as BACNET_OBJECT_TYPE;
pub const BACNET_SEGMENTATION_SEGMENTATION_BOTH: BACNET_SEGMENTATION = 0;
pub const BACNET_SEGMENTATION_SEGMENTATION_TRANSMIT: BACNET_SEGMENTATION = 1;
pub const BACNET_SEGMENTATION_SEGMENTATION_RECEIVE: BACNET_SEGMENTATION = 2;
pub const BACNET_SEGMENTATION_SEGMENTATION_NONE: BACNET_SEGMENTATION = 3;
pub const BACNET_SEGMENTATION_MAX_BACNET_SEGMENTATION: BACNET_SEGMENTATION = 4;
pub type BACNET_SEGMENTATION = ::std::os::raw::c_uint;
pub const BACNET_VT_CLASS_VT_CLASS_DEFAULT: BACNET_VT_CLASS = 0;
pub const BACNET_VT_CLASS_VT_CLASS_ANSI_X34: BACNET_VT_CLASS = 1;
pub const BACNET_VT_CLASS_VT_CLASS_DEC_VT52: BACNET_VT_CLASS = 2;
pub const BACNET_VT_CLASS_VT_CLASS_DEC_VT100: BACNET_VT_CLASS = 3;
pub const BACNET_VT_CLASS_VT_CLASS_DEC_VT220: BACNET_VT_CLASS = 4;
pub const BACNET_VT_CLASS_VT_CLASS_HP_700_94: BACNET_VT_CLASS = 5;
pub const BACNET_VT_CLASS_VT_CLASS_IBM_3130: BACNET_VT_CLASS = 6;
pub const BACNET_VT_CLASS_VT_CLASS_PROPRIETARY_MIN: BACNET_VT_CLASS = 64;
pub const BACNET_VT_CLASS_VT_CLASS_PROPRIETARY_MAX: BACNET_VT_CLASS = 65535;
pub type BACNET_VT_CLASS = ::std::os::raw::c_uint;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_ANSI_X34: BACNET_CHARACTER_STRING_ENCODING = 0;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_UTF8: BACNET_CHARACTER_STRING_ENCODING = 0;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_MS_DBCS: BACNET_CHARACTER_STRING_ENCODING = 1;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_JISC_6226: BACNET_CHARACTER_STRING_ENCODING =
    2;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_UCS4: BACNET_CHARACTER_STRING_ENCODING = 3;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_UCS2: BACNET_CHARACTER_STRING_ENCODING = 4;
pub const BACNET_CHARACTER_STRING_ENCODING_CHARACTER_ISO8859: BACNET_CHARACTER_STRING_ENCODING = 5;
pub const BACNET_CHARACTER_STRING_ENCODING_MAX_CHARACTER_STRING_ENCODING:
    BACNET_CHARACTER_STRING_ENCODING = 6;
pub type BACNET_CHARACTER_STRING_ENCODING = ::std::os::raw::c_uint;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_NULL: BACNET_APPLICATION_TAG = 0;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_BOOLEAN: BACNET_APPLICATION_TAG = 1;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_UNSIGNED_INT: BACNET_APPLICATION_TAG = 2;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_SIGNED_INT: BACNET_APPLICATION_TAG = 3;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_REAL: BACNET_APPLICATION_TAG = 4;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DOUBLE: BACNET_APPLICATION_TAG = 5;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_OCTET_STRING: BACNET_APPLICATION_TAG = 6;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_CHARACTER_STRING: BACNET_APPLICATION_TAG =
    7;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_BIT_STRING: BACNET_APPLICATION_TAG = 8;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_ENUMERATED: BACNET_APPLICATION_TAG = 9;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DATE: BACNET_APPLICATION_TAG = 10;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_TIME: BACNET_APPLICATION_TAG = 11;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_OBJECT_ID: BACNET_APPLICATION_TAG = 12;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_RESERVE1: BACNET_APPLICATION_TAG = 13;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_RESERVE2: BACNET_APPLICATION_TAG = 14;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_RESERVE3: BACNET_APPLICATION_TAG = 15;
pub const BACNET_APPLICATION_TAG_MAX_BACNET_APPLICATION_TAG: BACNET_APPLICATION_TAG = 16;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_EMPTYLIST: BACNET_APPLICATION_TAG = 17;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_WEEKNDAY: BACNET_APPLICATION_TAG = 18;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DATERANGE: BACNET_APPLICATION_TAG = 19;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DATETIME: BACNET_APPLICATION_TAG = 20;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_TIMESTAMP: BACNET_APPLICATION_TAG = 21;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_ERROR: BACNET_APPLICATION_TAG = 22;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DEVICE_OBJECT_PROPERTY_REFERENCE:
    BACNET_APPLICATION_TAG = 23;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DEVICE_OBJECT_REFERENCE:
    BACNET_APPLICATION_TAG = 24;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_OBJECT_PROPERTY_REFERENCE:
    BACNET_APPLICATION_TAG = 25;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_DESTINATION: BACNET_APPLICATION_TAG = 26;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_RECIPIENT: BACNET_APPLICATION_TAG = 27;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_COV_SUBSCRIPTION: BACNET_APPLICATION_TAG =
    28;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_CALENDAR_ENTRY: BACNET_APPLICATION_TAG = 29;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_WEEKLY_SCHEDULE: BACNET_APPLICATION_TAG =
    30;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_SPECIAL_EVENT: BACNET_APPLICATION_TAG = 31;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_READ_ACCESS_SPECIFICATION:
    BACNET_APPLICATION_TAG = 32;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_LIGHTING_COMMAND: BACNET_APPLICATION_TAG =
    33;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_HOST_N_PORT: BACNET_APPLICATION_TAG = 34;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_XY_COLOR: BACNET_APPLICATION_TAG = 35;
pub const BACNET_APPLICATION_TAG_BACNET_APPLICATION_TAG_COLOR_COMMAND: BACNET_APPLICATION_TAG = 36;
pub type BACNET_APPLICATION_TAG = ::std::os::raw::c_uint;
pub const BACNET_PDU_TYPE_PDU_TYPE_CONFIRMED_SERVICE_REQUEST: BACNET_PDU_TYPE = 0;
pub const BACNET_PDU_TYPE_PDU_TYPE_UNCONFIRMED_SERVICE_REQUEST: BACNET_PDU_TYPE = 16;
pub const BACNET_PDU_TYPE_PDU_TYPE_SIMPLE_ACK: BACNET_PDU_TYPE = 32;
pub const BACNET_PDU_TYPE_PDU_TYPE_COMPLEX_ACK: BACNET_PDU_TYPE = 48;
pub const BACNET_PDU_TYPE_PDU_TYPE_SEGMENT_ACK: BACNET_PDU_TYPE = 64;
pub const BACNET_PDU_TYPE_PDU_TYPE_ERROR: BACNET_PDU_TYPE = 80;
pub const BACNET_PDU_TYPE_PDU_TYPE_REJECT: BACNET_PDU_TYPE = 96;
pub const BACNET_PDU_TYPE_PDU_TYPE_ABORT: BACNET_PDU_TYPE = 112;
pub type BACNET_PDU_TYPE = ::std::os::raw::c_uint;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_ACKNOWLEDGE_ALARM:
    BACnet_Confirmed_Service_Choice = 0;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_AUDIT_NOTIFICATION:
    BACnet_Confirmed_Service_Choice = 32;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_COV_NOTIFICATION:
    BACnet_Confirmed_Service_Choice = 1;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_COV_NOTIFICATION_MULTIPLE:
    BACnet_Confirmed_Service_Choice = 31;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_EVENT_NOTIFICATION:
    BACnet_Confirmed_Service_Choice = 2;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_GET_ALARM_SUMMARY:
    BACnet_Confirmed_Service_Choice = 3;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_GET_ENROLLMENT_SUMMARY:
    BACnet_Confirmed_Service_Choice = 4;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_GET_EVENT_INFORMATION:
    BACnet_Confirmed_Service_Choice = 29;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_LIFE_SAFETY_OPERATION:
    BACnet_Confirmed_Service_Choice = 27;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_SUBSCRIBE_COV:
    BACnet_Confirmed_Service_Choice = 5;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_SUBSCRIBE_COV_PROPERTY:
    BACnet_Confirmed_Service_Choice = 28;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_SUBSCRIBE_COV_PROPERTY_MULTIPLE:
    BACnet_Confirmed_Service_Choice = 30;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_ATOMIC_READ_FILE:
    BACnet_Confirmed_Service_Choice = 6;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_ATOMIC_WRITE_FILE:
    BACnet_Confirmed_Service_Choice = 7;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_ADD_LIST_ELEMENT:
    BACnet_Confirmed_Service_Choice = 8;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_REMOVE_LIST_ELEMENT:
    BACnet_Confirmed_Service_Choice = 9;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_CREATE_OBJECT:
    BACnet_Confirmed_Service_Choice = 10;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_DELETE_OBJECT:
    BACnet_Confirmed_Service_Choice = 11;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_READ_PROPERTY:
    BACnet_Confirmed_Service_Choice = 12;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_READ_PROP_CONDITIONAL:
    BACnet_Confirmed_Service_Choice = 13;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_READ_PROP_MULTIPLE:
    BACnet_Confirmed_Service_Choice = 14;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_READ_RANGE:
    BACnet_Confirmed_Service_Choice = 26;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_WRITE_PROPERTY:
    BACnet_Confirmed_Service_Choice = 15;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_WRITE_PROP_MULTIPLE:
    BACnet_Confirmed_Service_Choice = 16;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_AUDIT_LOG_QUERY:
    BACnet_Confirmed_Service_Choice = 33;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_DEVICE_COMMUNICATION_CONTROL:
    BACnet_Confirmed_Service_Choice = 17;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_PRIVATE_TRANSFER:
    BACnet_Confirmed_Service_Choice = 18;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_TEXT_MESSAGE:
    BACnet_Confirmed_Service_Choice = 19;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_REINITIALIZE_DEVICE:
    BACnet_Confirmed_Service_Choice = 20;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_VT_OPEN:
    BACnet_Confirmed_Service_Choice = 21;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_VT_CLOSE:
    BACnet_Confirmed_Service_Choice = 22;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_VT_DATA:
    BACnet_Confirmed_Service_Choice = 23;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_AUTHENTICATE:
    BACnet_Confirmed_Service_Choice = 24;
pub const BACnet_Confirmed_Service_Choice_SERVICE_CONFIRMED_REQUEST_KEY:
    BACnet_Confirmed_Service_Choice = 25;
pub const BACnet_Confirmed_Service_Choice_MAX_BACNET_CONFIRMED_SERVICE:
    BACnet_Confirmed_Service_Choice = 34;
pub type BACnet_Confirmed_Service_Choice = ::std::os::raw::c_uint;
pub use self::BACnet_Confirmed_Service_Choice as BACNET_CONFIRMED_SERVICE;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_I_AM:
    BACnet_Unconfirmed_Service_Choice = 0;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_I_HAVE:
    BACnet_Unconfirmed_Service_Choice = 1;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_COV_NOTIFICATION:
    BACnet_Unconfirmed_Service_Choice = 2;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_EVENT_NOTIFICATION:
    BACnet_Unconfirmed_Service_Choice = 3;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_PRIVATE_TRANSFER:
    BACnet_Unconfirmed_Service_Choice = 4;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_TEXT_MESSAGE:
    BACnet_Unconfirmed_Service_Choice = 5;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_TIME_SYNCHRONIZATION:
    BACnet_Unconfirmed_Service_Choice = 6;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_WHO_HAS:
    BACnet_Unconfirmed_Service_Choice = 7;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_WHO_IS:
    BACnet_Unconfirmed_Service_Choice = 8;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_UTC_TIME_SYNCHRONIZATION:
    BACnet_Unconfirmed_Service_Choice = 9;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_WRITE_GROUP:
    BACnet_Unconfirmed_Service_Choice = 10;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_COV_NOTIFICATION_MULTIPLE:
    BACnet_Unconfirmed_Service_Choice = 11;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_AUDIT_NOTIFICATION:
    BACnet_Unconfirmed_Service_Choice = 12;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_WHO_AM_I:
    BACnet_Unconfirmed_Service_Choice = 13;
pub const BACnet_Unconfirmed_Service_Choice_SERVICE_UNCONFIRMED_YOU_ARE:
    BACnet_Unconfirmed_Service_Choice = 14;
pub const BACnet_Unconfirmed_Service_Choice_MAX_BACNET_UNCONFIRMED_SERVICE:
    BACnet_Unconfirmed_Service_Choice = 15;
pub type BACnet_Unconfirmed_Service_Choice = ::std::os::raw::c_uint;
pub use self::BACnet_Unconfirmed_Service_Choice as BACNET_UNCONFIRMED_SERVICE;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_ACKNOWLEDGE_ALARM: BACnet_Services_Supported =
    0;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_CONFIRMED_COV_NOTIFICATION:
    BACnet_Services_Supported = 1;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_CONFIRMED_COV_NOTIFICATION_MULTIPLE:
    BACnet_Services_Supported = 42;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_CONFIRMED_EVENT_NOTIFICATION:
    BACnet_Services_Supported = 2;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_GET_ALARM_SUMMARY: BACnet_Services_Supported =
    3;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_GET_ENROLLMENT_SUMMARY:
    BACnet_Services_Supported = 4;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_GET_EVENT_INFORMATION:
    BACnet_Services_Supported = 39;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_SUBSCRIBE_COV: BACnet_Services_Supported = 5;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_SUBSCRIBE_COV_PROPERTY:
    BACnet_Services_Supported = 38;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_SUBSCRIBE_COV_PROPERTY_MULTIPLE:
    BACnet_Services_Supported = 41;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_LIFE_SAFETY_OPERATION:
    BACnet_Services_Supported = 37;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_CONFIRMED_AUDIT_NOTIFICATION:
    BACnet_Services_Supported = 44;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_AUDIT_LOG_QUERY: BACnet_Services_Supported =
    45;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_ATOMIC_READ_FILE: BACnet_Services_Supported =
    6;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_ATOMIC_WRITE_FILE: BACnet_Services_Supported =
    7;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_ADD_LIST_ELEMENT: BACnet_Services_Supported =
    8;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_REMOVE_LIST_ELEMENT:
    BACnet_Services_Supported = 9;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_CREATE_OBJECT: BACnet_Services_Supported = 10;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_DELETE_OBJECT: BACnet_Services_Supported = 11;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_READ_PROPERTY: BACnet_Services_Supported = 12;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_READ_PROP_CONDITIONAL:
    BACnet_Services_Supported = 13;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_READ_PROP_MULTIPLE:
    BACnet_Services_Supported = 14;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_READ_RANGE: BACnet_Services_Supported = 35;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_WRITE_PROPERTY: BACnet_Services_Supported =
    15;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_WRITE_PROP_MULTIPLE:
    BACnet_Services_Supported = 16;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_WRITE_GROUP: BACnet_Services_Supported = 40;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_DEVICE_COMMUNICATION_CONTROL:
    BACnet_Services_Supported = 17;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_PRIVATE_TRANSFER: BACnet_Services_Supported =
    18;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_TEXT_MESSAGE: BACnet_Services_Supported = 19;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_REINITIALIZE_DEVICE:
    BACnet_Services_Supported = 20;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_WHO_AM_I: BACnet_Services_Supported = 47;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_YOU_ARE: BACnet_Services_Supported = 48;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_VT_OPEN: BACnet_Services_Supported = 21;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_VT_CLOSE: BACnet_Services_Supported = 22;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_VT_DATA: BACnet_Services_Supported = 23;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_AUTHENTICATE: BACnet_Services_Supported = 24;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_REQUEST_KEY: BACnet_Services_Supported = 25;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_I_AM: BACnet_Services_Supported = 26;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_I_HAVE: BACnet_Services_Supported = 27;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UNCONFIRMED_COV_NOTIFICATION:
    BACnet_Services_Supported = 28;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UNCONFIRMED_COV_NOTIFICATION_MULTIPLE:
    BACnet_Services_Supported = 43;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UNCONFIRMED_EVENT_NOTIFICATION:
    BACnet_Services_Supported = 29;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UNCONFIRMED_PRIVATE_TRANSFER:
    BACnet_Services_Supported = 30;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UNCONFIRMED_TEXT_MESSAGE:
    BACnet_Services_Supported = 31;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_TIME_SYNCHRONIZATION:
    BACnet_Services_Supported = 32;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UTC_TIME_SYNCHRONIZATION:
    BACnet_Services_Supported = 36;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_WHO_HAS: BACnet_Services_Supported = 33;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_WHO_IS: BACnet_Services_Supported = 34;
pub const BACnet_Services_Supported_SERVICE_SUPPORTED_UNCONFIRMED_AUDIT_NOTIFICATION:
    BACnet_Services_Supported = 46;
pub const BACnet_Services_Supported_BACNET_SERVICES_SUPPORTED_MAX: BACnet_Services_Supported = 47;
pub type BACnet_Services_Supported = ::std::os::raw::c_uint;
pub use self::BACnet_Services_Supported as BACNET_SERVICES_SUPPORTED;
pub const BACNET_STATUS_FLAGS_STATUS_FLAG_IN_ALARM: BACNET_STATUS_FLAGS = 0;
pub const BACNET_STATUS_FLAGS_STATUS_FLAG_FAULT: BACNET_STATUS_FLAGS = 1;
pub const BACNET_STATUS_FLAGS_STATUS_FLAG_OVERRIDDEN: BACNET_STATUS_FLAGS = 2;
pub const BACNET_STATUS_FLAGS_STATUS_FLAG_OUT_OF_SERVICE: BACNET_STATUS_FLAGS = 3;
pub type BACNET_STATUS_FLAGS = ::std::os::raw::c_uint;
pub const BACNET_LOG_STATUS_LOG_STATUS_LOG_DISABLED: BACNET_LOG_STATUS = 0;
pub const BACNET_LOG_STATUS_LOG_STATUS_BUFFER_PURGED: BACNET_LOG_STATUS = 1;
pub const BACNET_LOG_STATUS_LOG_STATUS_LOG_INTERRUPTED: BACNET_LOG_STATUS = 2;
pub type BACNET_LOG_STATUS = ::std::os::raw::c_uint;
pub const BACNET_LOGGING_TYPE_LOGGING_TYPE_POLLED: BACNET_LOGGING_TYPE = 0;
pub const BACNET_LOGGING_TYPE_LOGGING_TYPE_COV: BACNET_LOGGING_TYPE = 1;
pub const BACNET_LOGGING_TYPE_LOGGING_TYPE_TRIGGERED: BACNET_LOGGING_TYPE = 2;
pub type BACNET_LOGGING_TYPE = ::std::os::raw::c_uint;
pub const BACNET_ACKNOWLEDGMENT_FILTER_ACKNOWLEDGMENT_FILTER_ALL: BACNET_ACKNOWLEDGMENT_FILTER = 0;
pub const BACNET_ACKNOWLEDGMENT_FILTER_ACKNOWLEDGMENT_FILTER_ACKED: BACNET_ACKNOWLEDGMENT_FILTER =
    1;
pub const BACNET_ACKNOWLEDGMENT_FILTER_ACKNOWLEDGMENT_FILTER_NOT_ACKED:
    BACNET_ACKNOWLEDGMENT_FILTER = 2;
pub type BACNET_ACKNOWLEDGMENT_FILTER = ::std::os::raw::c_uint;
pub const BACNET_EVENT_STATE_FILTER_EVENT_STATE_FILTER_OFFNORMAL: BACNET_EVENT_STATE_FILTER = 0;
pub const BACNET_EVENT_STATE_FILTER_EVENT_STATE_FILTER_FAULT: BACNET_EVENT_STATE_FILTER = 1;
pub const BACNET_EVENT_STATE_FILTER_EVENT_STATE_FILTER_NORMAL: BACNET_EVENT_STATE_FILTER = 2;
pub const BACNET_EVENT_STATE_FILTER_EVENT_STATE_FILTER_ALL: BACNET_EVENT_STATE_FILTER = 3;
pub const BACNET_EVENT_STATE_FILTER_EVENT_STATE_FILTER_ACTIVE: BACNET_EVENT_STATE_FILTER = 4;
pub type BACNET_EVENT_STATE_FILTER = ::std::os::raw::c_uint;
pub const BACNET_SELECTION_LOGIC_SELECTION_LOGIC_AND: BACNET_SELECTION_LOGIC = 0;
pub const BACNET_SELECTION_LOGIC_SELECTION_LOGIC_OR: BACNET_SELECTION_LOGIC = 1;
pub const BACNET_SELECTION_LOGIC_SELECTION_LOGIC_ALL: BACNET_SELECTION_LOGIC = 2;
pub type BACNET_SELECTION_LOGIC = ::std::os::raw::c_uint;
pub const BACNET_RELATION_SPECIFIER_RELATION_SPECIFIER_EQUAL: BACNET_RELATION_SPECIFIER = 0;
pub const BACNET_RELATION_SPECIFIER_RELATION_SPECIFIER_NOT_EQUAL: BACNET_RELATION_SPECIFIER = 1;
pub const BACNET_RELATION_SPECIFIER_RELATION_SPECIFIER_LESS_THAN: BACNET_RELATION_SPECIFIER = 2;
pub const BACNET_RELATION_SPECIFIER_RELATION_SPECIFIER_GREATER_THAN: BACNET_RELATION_SPECIFIER = 3;
pub const BACNET_RELATION_SPECIFIER_RELATION_SPECIFIER_LESS_THAN_OR_EQUAL:
    BACNET_RELATION_SPECIFIER = 4;
pub const BACNET_RELATION_SPECIFIER_RELATION_SPECIFIER_GREATER_THAN_OR_EQUAL:
    BACNET_RELATION_SPECIFIER = 5;
pub type BACNET_RELATION_SPECIFIER = ::std::os::raw::c_uint;
pub const BACNET_COMMUNICATION_ENABLE_DISABLE_COMMUNICATION_ENABLE:
    BACNET_COMMUNICATION_ENABLE_DISABLE = 0;
pub const BACNET_COMMUNICATION_ENABLE_DISABLE_COMMUNICATION_DISABLE:
    BACNET_COMMUNICATION_ENABLE_DISABLE = 1;
pub const BACNET_COMMUNICATION_ENABLE_DISABLE_COMMUNICATION_DISABLE_INITIATION:
    BACNET_COMMUNICATION_ENABLE_DISABLE = 2;
pub const BACNET_COMMUNICATION_ENABLE_DISABLE_MAX_BACNET_COMMUNICATION_ENABLE_DISABLE:
    BACNET_COMMUNICATION_ENABLE_DISABLE = 3;
pub type BACNET_COMMUNICATION_ENABLE_DISABLE = ::std::os::raw::c_uint;
pub const BACNET_MESSAGE_PRIORITY_MESSAGE_PRIORITY_NORMAL: BACNET_MESSAGE_PRIORITY = 0;
pub const BACNET_MESSAGE_PRIORITY_MESSAGE_PRIORITY_URGENT: BACNET_MESSAGE_PRIORITY = 1;
pub const BACNET_MESSAGE_PRIORITY_MESSAGE_PRIORITY_CRITICAL_EQUIPMENT: BACNET_MESSAGE_PRIORITY = 2;
pub const BACNET_MESSAGE_PRIORITY_MESSAGE_PRIORITY_LIFE_SAFETY: BACNET_MESSAGE_PRIORITY = 3;
pub type BACNET_MESSAGE_PRIORITY = ::std::os::raw::c_uint;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_WHO_IS_ROUTER_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 0;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_I_AM_ROUTER_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 1;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_I_COULD_BE_ROUTER_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 2;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_REJECT_MESSAGE_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 3;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_ROUTER_BUSY_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 4;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_ROUTER_AVAILABLE_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 5;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_INIT_RT_TABLE: BACNET_NETWORK_MESSAGE_TYPE =
    6;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_INIT_RT_TABLE_ACK:
    BACNET_NETWORK_MESSAGE_TYPE = 7;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_ESTABLISH_CONNECTION_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 8;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_DISCONNECT_CONNECTION_TO_NETWORK:
    BACNET_NETWORK_MESSAGE_TYPE = 9;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_CHALLENGE_REQUEST:
    BACNET_NETWORK_MESSAGE_TYPE = 10;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_SECURITY_PAYLOAD:
    BACNET_NETWORK_MESSAGE_TYPE = 11;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_SECURITY_RESPONSE:
    BACNET_NETWORK_MESSAGE_TYPE = 12;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_REQUEST_KEY_UPDATE:
    BACNET_NETWORK_MESSAGE_TYPE = 13;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_UPDATE_KEY_SET: BACNET_NETWORK_MESSAGE_TYPE =
    14;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_UPDATE_DISTRIBUTION_KEY:
    BACNET_NETWORK_MESSAGE_TYPE = 15;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_REQUEST_MASTER_KEY:
    BACNET_NETWORK_MESSAGE_TYPE = 16;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_SET_MASTER_KEY: BACNET_NETWORK_MESSAGE_TYPE =
    17;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_WHAT_IS_NETWORK_NUMBER:
    BACNET_NETWORK_MESSAGE_TYPE = 18;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_NETWORK_NUMBER_IS:
    BACNET_NETWORK_MESSAGE_TYPE = 19;
pub const BACNET_NETWORK_MESSAGE_TYPE_NETWORK_MESSAGE_INVALID: BACNET_NETWORK_MESSAGE_TYPE = 256;
pub type BACNET_NETWORK_MESSAGE_TYPE = ::std::os::raw::c_uint;
pub const BACNET_ABORT_REASON_ABORT_REASON_OTHER: BACNET_ABORT_REASON = 0;
pub const BACNET_ABORT_REASON_ABORT_REASON_BUFFER_OVERFLOW: BACNET_ABORT_REASON = 1;
pub const BACNET_ABORT_REASON_ABORT_REASON_INVALID_APDU_IN_THIS_STATE: BACNET_ABORT_REASON = 2;
pub const BACNET_ABORT_REASON_ABORT_REASON_PREEMPTED_BY_HIGHER_PRIORITY_TASK: BACNET_ABORT_REASON =
    3;
pub const BACNET_ABORT_REASON_ABORT_REASON_SEGMENTATION_NOT_SUPPORTED: BACNET_ABORT_REASON = 4;
pub const BACNET_ABORT_REASON_ABORT_REASON_SECURITY_ERROR: BACNET_ABORT_REASON = 5;
pub const BACNET_ABORT_REASON_ABORT_REASON_INSUFFICIENT_SECURITY: BACNET_ABORT_REASON = 6;
pub const BACNET_ABORT_REASON_MAX_BACNET_ABORT_REASON: BACNET_ABORT_REASON = 7;
pub const BACNET_ABORT_REASON_ABORT_REASON_PROPRIETARY_FIRST: BACNET_ABORT_REASON = 64;
pub const BACNET_ABORT_REASON_ABORT_REASON_PROPRIETARY_LAST: BACNET_ABORT_REASON = 255;
pub type BACNET_ABORT_REASON = ::std::os::raw::c_uint;
pub const BACNET_REJECT_REASON_REJECT_REASON_OTHER: BACNET_REJECT_REASON = 0;
pub const BACNET_REJECT_REASON_REJECT_REASON_BUFFER_OVERFLOW: BACNET_REJECT_REASON = 1;
pub const BACNET_REJECT_REASON_REJECT_REASON_INCONSISTENT_PARAMETERS: BACNET_REJECT_REASON = 2;
pub const BACNET_REJECT_REASON_REJECT_REASON_INVALID_PARAMETER_DATA_TYPE: BACNET_REJECT_REASON = 3;
pub const BACNET_REJECT_REASON_REJECT_REASON_INVALID_TAG: BACNET_REJECT_REASON = 4;
pub const BACNET_REJECT_REASON_REJECT_REASON_MISSING_REQUIRED_PARAMETER: BACNET_REJECT_REASON = 5;
pub const BACNET_REJECT_REASON_REJECT_REASON_PARAMETER_OUT_OF_RANGE: BACNET_REJECT_REASON = 6;
pub const BACNET_REJECT_REASON_REJECT_REASON_TOO_MANY_ARGUMENTS: BACNET_REJECT_REASON = 7;
pub const BACNET_REJECT_REASON_REJECT_REASON_UNDEFINED_ENUMERATION: BACNET_REJECT_REASON = 8;
pub const BACNET_REJECT_REASON_REJECT_REASON_UNRECOGNIZED_SERVICE: BACNET_REJECT_REASON = 9;
pub const BACNET_REJECT_REASON_MAX_BACNET_REJECT_REASON: BACNET_REJECT_REASON = 10;
pub const BACNET_REJECT_REASON_REJECT_REASON_PROPRIETARY_FIRST: BACNET_REJECT_REASON = 64;
pub const BACNET_REJECT_REASON_REJECT_REASON_PROPRIETARY_LAST: BACNET_REJECT_REASON = 255;
pub type BACNET_REJECT_REASON = ::std::os::raw::c_uint;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_DEVICE: BACNET_ERROR_CLASS = 0;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_OBJECT: BACNET_ERROR_CLASS = 1;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_PROPERTY: BACNET_ERROR_CLASS = 2;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_RESOURCES: BACNET_ERROR_CLASS = 3;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_SECURITY: BACNET_ERROR_CLASS = 4;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_SERVICES: BACNET_ERROR_CLASS = 5;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_VT: BACNET_ERROR_CLASS = 6;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_COMMUNICATION: BACNET_ERROR_CLASS = 7;
pub const BACNET_ERROR_CLASS_MAX_BACNET_ERROR_CLASS: BACNET_ERROR_CLASS = 8;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_PROPRIETARY_FIRST: BACNET_ERROR_CLASS = 64;
pub const BACNET_ERROR_CLASS_ERROR_CLASS_PROPRIETARY_LAST: BACNET_ERROR_CLASS = 65535;
pub type BACNET_ERROR_CLASS = ::std::os::raw::c_uint;
pub const BACNET_ERROR_CODE_ERROR_CODE_OTHER: BACNET_ERROR_CODE = 0;
pub const BACNET_ERROR_CODE_ERROR_CODE_DEVICE_BUSY: BACNET_ERROR_CODE = 3;
pub const BACNET_ERROR_CODE_ERROR_CODE_CONFIGURATION_IN_PROGRESS: BACNET_ERROR_CODE = 2;
pub const BACNET_ERROR_CODE_ERROR_CODE_OPERATIONAL_PROBLEM: BACNET_ERROR_CODE = 25;
pub const BACNET_ERROR_CODE_ERROR_CODE_DYNAMIC_CREATION_NOT_SUPPORTED: BACNET_ERROR_CODE = 4;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_OBJECTS_OF_SPECIFIED_TYPE: BACNET_ERROR_CODE = 17;
pub const BACNET_ERROR_CODE_ERROR_CODE_OBJECT_DELETION_NOT_PERMITTED: BACNET_ERROR_CODE = 23;
pub const BACNET_ERROR_CODE_ERROR_CODE_OBJECT_IDENTIFIER_ALREADY_EXISTS: BACNET_ERROR_CODE = 24;
pub const BACNET_ERROR_CODE_ERROR_CODE_READ_ACCESS_DENIED: BACNET_ERROR_CODE = 27;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_OBJECT: BACNET_ERROR_CODE = 31;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNSUPPORTED_OBJECT_TYPE: BACNET_ERROR_CODE = 36;
pub const BACNET_ERROR_CODE_ERROR_CODE_CHARACTER_SET_NOT_SUPPORTED: BACNET_ERROR_CODE = 41;
pub const BACNET_ERROR_CODE_ERROR_CODE_DATATYPE_NOT_SUPPORTED: BACNET_ERROR_CODE = 47;
pub const BACNET_ERROR_CODE_ERROR_CODE_INCONSISTENT_SELECTION_CRITERION: BACNET_ERROR_CODE = 8;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_ARRAY_INDEX: BACNET_ERROR_CODE = 42;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_DATA_TYPE: BACNET_ERROR_CODE = 9;
pub const BACNET_ERROR_CODE_ERROR_CODE_NOT_COV_PROPERTY: BACNET_ERROR_CODE = 44;
pub const BACNET_ERROR_CODE_ERROR_CODE_OPTIONAL_FUNCTIONALITY_NOT_SUPPORTED: BACNET_ERROR_CODE = 45;
pub const BACNET_ERROR_CODE_ERROR_CODE_PROPERTY_IS_NOT_AN_ARRAY: BACNET_ERROR_CODE = 50;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_PROPERTY: BACNET_ERROR_CODE = 32;
pub const BACNET_ERROR_CODE_ERROR_CODE_VALUE_OUT_OF_RANGE: BACNET_ERROR_CODE = 37;
pub const BACNET_ERROR_CODE_ERROR_CODE_WRITE_ACCESS_DENIED: BACNET_ERROR_CODE = 40;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_SPACE_FOR_OBJECT: BACNET_ERROR_CODE = 18;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_SPACE_TO_ADD_LIST_ELEMENT: BACNET_ERROR_CODE = 19;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_SPACE_TO_WRITE_PROPERTY: BACNET_ERROR_CODE = 20;
pub const BACNET_ERROR_CODE_ERROR_CODE_AUTHENTICATION_FAILED: BACNET_ERROR_CODE = 1;
pub const BACNET_ERROR_CODE_ERROR_CODE_INCOMPATIBLE_SECURITY_LEVELS: BACNET_ERROR_CODE = 6;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_OPERATOR_NAME: BACNET_ERROR_CODE = 12;
pub const BACNET_ERROR_CODE_ERROR_CODE_KEY_GENERATION_ERROR: BACNET_ERROR_CODE = 15;
pub const BACNET_ERROR_CODE_ERROR_CODE_PASSWORD_FAILURE: BACNET_ERROR_CODE = 26;
pub const BACNET_ERROR_CODE_ERROR_CODE_SECURITY_NOT_SUPPORTED: BACNET_ERROR_CODE = 28;
pub const BACNET_ERROR_CODE_ERROR_CODE_TIMEOUT: BACNET_ERROR_CODE = 30;
pub const BACNET_ERROR_CODE_ERROR_CODE_COV_SUBSCRIPTION_FAILED: BACNET_ERROR_CODE = 43;
pub const BACNET_ERROR_CODE_ERROR_CODE_DUPLICATE_NAME: BACNET_ERROR_CODE = 48;
pub const BACNET_ERROR_CODE_ERROR_CODE_DUPLICATE_OBJECT_ID: BACNET_ERROR_CODE = 49;
pub const BACNET_ERROR_CODE_ERROR_CODE_FILE_ACCESS_DENIED: BACNET_ERROR_CODE = 5;
pub const BACNET_ERROR_CODE_ERROR_CODE_INCONSISTENT_PARAMETERS: BACNET_ERROR_CODE = 7;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_CONFIGURATION_DATA: BACNET_ERROR_CODE = 46;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_FILE_ACCESS_METHOD: BACNET_ERROR_CODE = 10;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_FILE_START_POSITION: BACNET_ERROR_CODE = 11;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_PARAMETER_DATA_TYPE: BACNET_ERROR_CODE = 13;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_TIME_STAMP: BACNET_ERROR_CODE = 14;
pub const BACNET_ERROR_CODE_ERROR_CODE_MISSING_REQUIRED_PARAMETER: BACNET_ERROR_CODE = 16;
pub const BACNET_ERROR_CODE_ERROR_CODE_PROPERTY_IS_NOT_A_LIST: BACNET_ERROR_CODE = 22;
pub const BACNET_ERROR_CODE_ERROR_CODE_SERVICE_REQUEST_DENIED: BACNET_ERROR_CODE = 29;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_VT_CLASS: BACNET_ERROR_CODE = 34;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_VT_SESSION: BACNET_ERROR_CODE = 35;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_VT_SESSIONS_AVAILABLE: BACNET_ERROR_CODE = 21;
pub const BACNET_ERROR_CODE_ERROR_CODE_VT_SESSION_ALREADY_CLOSED: BACNET_ERROR_CODE = 38;
pub const BACNET_ERROR_CODE_ERROR_CODE_VT_SESSION_TERMINATION_FAILURE: BACNET_ERROR_CODE = 39;
pub const BACNET_ERROR_CODE_ERROR_CODE_RESERVED1: BACNET_ERROR_CODE = 33;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_BUFFER_OVERFLOW: BACNET_ERROR_CODE = 51;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_INVALID_APDU_IN_THIS_STATE: BACNET_ERROR_CODE = 52;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_PREEMPTED_BY_HIGHER_PRIORITY_TASK: BACNET_ERROR_CODE =
    53;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_SEGMENTATION_NOT_SUPPORTED: BACNET_ERROR_CODE = 54;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_PROPRIETARY: BACNET_ERROR_CODE = 55;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_OTHER: BACNET_ERROR_CODE = 56;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_TAG: BACNET_ERROR_CODE = 57;
pub const BACNET_ERROR_CODE_ERROR_CODE_NETWORK_DOWN: BACNET_ERROR_CODE = 58;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_BUFFER_OVERFLOW: BACNET_ERROR_CODE = 59;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_INCONSISTENT_PARAMETERS: BACNET_ERROR_CODE = 60;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_INVALID_PARAMETER_DATA_TYPE: BACNET_ERROR_CODE = 61;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_INVALID_TAG: BACNET_ERROR_CODE = 62;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_MISSING_REQUIRED_PARAMETER: BACNET_ERROR_CODE = 63;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_PARAMETER_OUT_OF_RANGE: BACNET_ERROR_CODE = 64;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_TOO_MANY_ARGUMENTS: BACNET_ERROR_CODE = 65;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_UNDEFINED_ENUMERATION: BACNET_ERROR_CODE = 66;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_UNRECOGNIZED_SERVICE: BACNET_ERROR_CODE = 67;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_PROPRIETARY: BACNET_ERROR_CODE = 68;
pub const BACNET_ERROR_CODE_ERROR_CODE_REJECT_OTHER: BACNET_ERROR_CODE = 69;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_DEVICE: BACNET_ERROR_CODE = 70;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_ROUTE: BACNET_ERROR_CODE = 71;
pub const BACNET_ERROR_CODE_ERROR_CODE_VALUE_NOT_INITIALIZED: BACNET_ERROR_CODE = 72;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_EVENT_STATE: BACNET_ERROR_CODE = 73;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_ALARM_CONFIGURED: BACNET_ERROR_CODE = 74;
pub const BACNET_ERROR_CODE_ERROR_CODE_LOG_BUFFER_FULL: BACNET_ERROR_CODE = 75;
pub const BACNET_ERROR_CODE_ERROR_CODE_LOGGED_VALUE_PURGED: BACNET_ERROR_CODE = 76;
pub const BACNET_ERROR_CODE_ERROR_CODE_NO_PROPERTY_SPECIFIED: BACNET_ERROR_CODE = 77;
pub const BACNET_ERROR_CODE_ERROR_CODE_NOT_CONFIGURED_FOR_TRIGGERED_LOGGING: BACNET_ERROR_CODE = 78;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_SUBSCRIPTION: BACNET_ERROR_CODE = 79;
pub const BACNET_ERROR_CODE_ERROR_CODE_PARAMETER_OUT_OF_RANGE: BACNET_ERROR_CODE = 80;
pub const BACNET_ERROR_CODE_ERROR_CODE_LIST_ELEMENT_NOT_FOUND: BACNET_ERROR_CODE = 81;
pub const BACNET_ERROR_CODE_ERROR_CODE_BUSY: BACNET_ERROR_CODE = 82;
pub const BACNET_ERROR_CODE_ERROR_CODE_COMMUNICATION_DISABLED: BACNET_ERROR_CODE = 83;
pub const BACNET_ERROR_CODE_ERROR_CODE_SUCCESS: BACNET_ERROR_CODE = 84;
pub const BACNET_ERROR_CODE_ERROR_CODE_ACCESS_DENIED: BACNET_ERROR_CODE = 85;
pub const BACNET_ERROR_CODE_ERROR_CODE_BAD_DESTINATION_ADDRESS: BACNET_ERROR_CODE = 86;
pub const BACNET_ERROR_CODE_ERROR_CODE_BAD_DESTINATION_DEVICE_ID: BACNET_ERROR_CODE = 87;
pub const BACNET_ERROR_CODE_ERROR_CODE_BAD_SIGNATURE: BACNET_ERROR_CODE = 88;
pub const BACNET_ERROR_CODE_ERROR_CODE_BAD_SOURCE_ADDRESS: BACNET_ERROR_CODE = 89;
pub const BACNET_ERROR_CODE_ERROR_CODE_BAD_TIMESTAMP: BACNET_ERROR_CODE = 90;
pub const BACNET_ERROR_CODE_ERROR_CODE_CANNOT_USE_KEY: BACNET_ERROR_CODE = 91;
pub const BACNET_ERROR_CODE_ERROR_CODE_CANNOT_VERIFY_MESSAGE_ID: BACNET_ERROR_CODE = 92;
pub const BACNET_ERROR_CODE_ERROR_CODE_CORRECT_KEY_REVISION: BACNET_ERROR_CODE = 93;
pub const BACNET_ERROR_CODE_ERROR_CODE_DESTINATION_DEVICE_ID_REQUIRED: BACNET_ERROR_CODE = 94;
pub const BACNET_ERROR_CODE_ERROR_CODE_DUPLICATE_MESSAGE: BACNET_ERROR_CODE = 95;
pub const BACNET_ERROR_CODE_ERROR_CODE_ENCRYPTION_NOT_CONFIGURED: BACNET_ERROR_CODE = 96;
pub const BACNET_ERROR_CODE_ERROR_CODE_ENCRYPTION_REQUIRED: BACNET_ERROR_CODE = 97;
pub const BACNET_ERROR_CODE_ERROR_CODE_INCORRECT_KEY: BACNET_ERROR_CODE = 98;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_KEY_DATA: BACNET_ERROR_CODE = 99;
pub const BACNET_ERROR_CODE_ERROR_CODE_KEY_UPDATE_IN_PROGRESS: BACNET_ERROR_CODE = 100;
pub const BACNET_ERROR_CODE_ERROR_CODE_MALFORMED_MESSAGE: BACNET_ERROR_CODE = 101;
pub const BACNET_ERROR_CODE_ERROR_CODE_NOT_KEY_SERVER: BACNET_ERROR_CODE = 102;
pub const BACNET_ERROR_CODE_ERROR_CODE_SECURITY_NOT_CONFIGURED: BACNET_ERROR_CODE = 103;
pub const BACNET_ERROR_CODE_ERROR_CODE_SOURCE_SECURITY_REQUIRED: BACNET_ERROR_CODE = 104;
pub const BACNET_ERROR_CODE_ERROR_CODE_TOO_MANY_KEYS: BACNET_ERROR_CODE = 105;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_AUTHENTICATION_TYPE: BACNET_ERROR_CODE = 106;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_KEY: BACNET_ERROR_CODE = 107;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_KEY_REVISION: BACNET_ERROR_CODE = 108;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_SOURCE_MESSAGE: BACNET_ERROR_CODE = 109;
pub const BACNET_ERROR_CODE_ERROR_CODE_NOT_ROUTER_TO_DNET: BACNET_ERROR_CODE = 110;
pub const BACNET_ERROR_CODE_ERROR_CODE_ROUTER_BUSY: BACNET_ERROR_CODE = 111;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_NETWORK_MESSAGE: BACNET_ERROR_CODE = 112;
pub const BACNET_ERROR_CODE_ERROR_CODE_MESSAGE_TOO_LONG: BACNET_ERROR_CODE = 113;
pub const BACNET_ERROR_CODE_ERROR_CODE_SECURITY_ERROR: BACNET_ERROR_CODE = 114;
pub const BACNET_ERROR_CODE_ERROR_CODE_ADDRESSING_ERROR: BACNET_ERROR_CODE = 115;
pub const BACNET_ERROR_CODE_ERROR_CODE_WRITE_BDT_FAILED: BACNET_ERROR_CODE = 116;
pub const BACNET_ERROR_CODE_ERROR_CODE_READ_BDT_FAILED: BACNET_ERROR_CODE = 117;
pub const BACNET_ERROR_CODE_ERROR_CODE_REGISTER_FOREIGN_DEVICE_FAILED: BACNET_ERROR_CODE = 118;
pub const BACNET_ERROR_CODE_ERROR_CODE_READ_FDT_FAILED: BACNET_ERROR_CODE = 119;
pub const BACNET_ERROR_CODE_ERROR_CODE_DELETE_FDT_ENTRY_FAILED: BACNET_ERROR_CODE = 120;
pub const BACNET_ERROR_CODE_ERROR_CODE_DISTRIBUTE_BROADCAST_FAILED: BACNET_ERROR_CODE = 121;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_FILE_SIZE: BACNET_ERROR_CODE = 122;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_APDU_TOO_LONG: BACNET_ERROR_CODE = 123;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_APPLICATION_EXCEEDED_REPLY_TIME: BACNET_ERROR_CODE =
    124;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_OUT_OF_RESOURCES: BACNET_ERROR_CODE = 125;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_TSM_TIMEOUT: BACNET_ERROR_CODE = 126;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_WINDOW_SIZE_OUT_OF_RANGE: BACNET_ERROR_CODE = 127;
pub const BACNET_ERROR_CODE_ERROR_CODE_FILE_FULL: BACNET_ERROR_CODE = 128;
pub const BACNET_ERROR_CODE_ERROR_CODE_INCONSISTENT_CONFIGURATION: BACNET_ERROR_CODE = 129;
pub const BACNET_ERROR_CODE_ERROR_CODE_INCONSISTENT_OBJECT_TYPE: BACNET_ERROR_CODE = 130;
pub const BACNET_ERROR_CODE_ERROR_CODE_INTERNAL_ERROR: BACNET_ERROR_CODE = 131;
pub const BACNET_ERROR_CODE_ERROR_CODE_NOT_CONFIGURED: BACNET_ERROR_CODE = 132;
pub const BACNET_ERROR_CODE_ERROR_CODE_OUT_OF_MEMORY: BACNET_ERROR_CODE = 133;
pub const BACNET_ERROR_CODE_ERROR_CODE_VALUE_TOO_LONG: BACNET_ERROR_CODE = 134;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_INSUFFICIENT_SECURITY: BACNET_ERROR_CODE = 135;
pub const BACNET_ERROR_CODE_ERROR_CODE_ABORT_SECURITY_ERROR: BACNET_ERROR_CODE = 136;
pub const BACNET_ERROR_CODE_ERROR_CODE_DUPLICATE_ENTRY: BACNET_ERROR_CODE = 137;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_VALUE_IN_THIS_STATE: BACNET_ERROR_CODE = 138;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_OPERATION_IN_THIS_STATE: BACNET_ERROR_CODE = 139;
pub const BACNET_ERROR_CODE_ERROR_CODE_LIST_ITEM_NOT_NUMBERED: BACNET_ERROR_CODE = 140;
pub const BACNET_ERROR_CODE_ERROR_CODE_LIST_ITEM_NOT_TIMESTAMPED: BACNET_ERROR_CODE = 141;
pub const BACNET_ERROR_CODE_ERROR_CODE_INVALID_DATA_ENCODING: BACNET_ERROR_CODE = 142;
pub const BACNET_ERROR_CODE_ERROR_CODE_BVLC_FUNCTION_UNKNOWN: BACNET_ERROR_CODE = 143;
pub const BACNET_ERROR_CODE_ERROR_CODE_BVLC_PROPRIETARY_FUNCTION_UNKNOWN: BACNET_ERROR_CODE = 144;
pub const BACNET_ERROR_CODE_ERROR_CODE_HEADER_ENCODING_ERROR: BACNET_ERROR_CODE = 145;
pub const BACNET_ERROR_CODE_ERROR_CODE_HEADER_NOT_UNDERSTOOD: BACNET_ERROR_CODE = 146;
pub const BACNET_ERROR_CODE_ERROR_CODE_MESSAGE_INCOMPLETE: BACNET_ERROR_CODE = 147;
pub const BACNET_ERROR_CODE_ERROR_CODE_NOT_A_BACNET_SC_HUB: BACNET_ERROR_CODE = 148;
pub const BACNET_ERROR_CODE_ERROR_CODE_PAYLOAD_EXPECTED: BACNET_ERROR_CODE = 149;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNEXPECTED_DATA: BACNET_ERROR_CODE = 150;
pub const BACNET_ERROR_CODE_ERROR_CODE_NODE_DUPLICATE_VMAC: BACNET_ERROR_CODE = 151;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_UNEXPECTED_RESPONSE_CODE: BACNET_ERROR_CODE = 152;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_NO_UPGRADE: BACNET_ERROR_CODE = 153;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_RESOURCE_NOT_LOCAL: BACNET_ERROR_CODE = 154;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_PROXY_AUTHENTICATION_FAILED: BACNET_ERROR_CODE = 155;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_RESPONSE_TIMEOUT: BACNET_ERROR_CODE = 156;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_RESPONSE_SYNTAX_ERROR: BACNET_ERROR_CODE = 157;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_RESPONSE_VALUE_ERROR: BACNET_ERROR_CODE = 158;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_RESPONSE_MISSING_HEADER: BACNET_ERROR_CODE = 159;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_WEBSOCKET_HEADER_ERROR: BACNET_ERROR_CODE = 160;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_UPGRADE_REQUIRED: BACNET_ERROR_CODE = 161;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_UPGRADE_ERROR: BACNET_ERROR_CODE = 162;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_TEMPORARY_UNAVAILABLE: BACNET_ERROR_CODE = 163;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_NOT_A_SERVER: BACNET_ERROR_CODE = 164;
pub const BACNET_ERROR_CODE_ERROR_CODE_HTTP_ERROR: BACNET_ERROR_CODE = 165;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_SCHEME_NOT_SUPPORTED: BACNET_ERROR_CODE = 166;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_UNKNOWN_CONTROL_MESSAGE: BACNET_ERROR_CODE = 167;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_CLOSE_ERROR: BACNET_ERROR_CODE = 168;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_CLOSED_BY_PEER: BACNET_ERROR_CODE = 169;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_ENDPOINT_LEAVES: BACNET_ERROR_CODE = 170;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_PROTOCOL_ERROR: BACNET_ERROR_CODE = 171;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_DATA_NOT_ACCEPTED: BACNET_ERROR_CODE = 172;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_CLOSED_ABNORMALLY: BACNET_ERROR_CODE = 173;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_DATA_INCONSISTENT: BACNET_ERROR_CODE = 174;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_DATA_AGAINST_POLICY: BACNET_ERROR_CODE = 175;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_FRAME_TOO_LONG: BACNET_ERROR_CODE = 176;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_EXTENSION_MISSING: BACNET_ERROR_CODE = 177;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_REQUEST_UNAVAILABLE: BACNET_ERROR_CODE = 178;
pub const BACNET_ERROR_CODE_ERROR_CODE_WEBSOCKET_ERROR: BACNET_ERROR_CODE = 179;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_CLIENT_CERTIFICATE_ERROR: BACNET_ERROR_CODE = 180;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_SERVER_CERTIFICATE_ERROR: BACNET_ERROR_CODE = 181;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_CLIENT_AUTHENTICATION_FAILED: BACNET_ERROR_CODE = 182;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_SERVER_AUTHENTICATION_FAILED: BACNET_ERROR_CODE = 183;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_CLIENT_CERTIFICATE_EXPIRED: BACNET_ERROR_CODE = 184;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_SERVER_CERTIFICATE_EXPIRED: BACNET_ERROR_CODE = 185;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_CLIENT_CERTIFICATE_REVOKED: BACNET_ERROR_CODE = 186;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_SERVER_CERTIFICATE_REVOKED: BACNET_ERROR_CODE = 187;
pub const BACNET_ERROR_CODE_ERROR_CODE_TLS_ERROR: BACNET_ERROR_CODE = 188;
pub const BACNET_ERROR_CODE_ERROR_CODE_DNS_UNAVAILABLE: BACNET_ERROR_CODE = 189;
pub const BACNET_ERROR_CODE_ERROR_CODE_DNS_NAME_RESOLUTION_FAILED: BACNET_ERROR_CODE = 190;
pub const BACNET_ERROR_CODE_ERROR_CODE_DNS_RESOLVER_FAILURE: BACNET_ERROR_CODE = 191;
pub const BACNET_ERROR_CODE_ERROR_CODE_DNS_ERROR: BACNET_ERROR_CODE = 192;
pub const BACNET_ERROR_CODE_ERROR_CODE_TCP_CONNECT_TIMEOUT: BACNET_ERROR_CODE = 193;
pub const BACNET_ERROR_CODE_ERROR_CODE_TCP_CONNECTION_REFUSED: BACNET_ERROR_CODE = 194;
pub const BACNET_ERROR_CODE_ERROR_CODE_TCP_CLOSED_BY_LOCAL: BACNET_ERROR_CODE = 195;
pub const BACNET_ERROR_CODE_ERROR_CODE_TCP_CLOSED_OTHER: BACNET_ERROR_CODE = 196;
pub const BACNET_ERROR_CODE_ERROR_CODE_TCP_ERROR: BACNET_ERROR_CODE = 197;
pub const BACNET_ERROR_CODE_ERROR_CODE_IP_ADDRESS_NOT_REACHABLE: BACNET_ERROR_CODE = 198;
pub const BACNET_ERROR_CODE_ERROR_CODE_IP_ERROR: BACNET_ERROR_CODE = 199;
pub const BACNET_ERROR_CODE_ERROR_CODE_CERTIFICATE_EXPIRED: BACNET_ERROR_CODE = 200;
pub const BACNET_ERROR_CODE_ERROR_CODE_CERTIFICATE_INVALID: BACNET_ERROR_CODE = 201;
pub const BACNET_ERROR_CODE_ERROR_CODE_CERTIFICATE_MALFORMED: BACNET_ERROR_CODE = 202;
pub const BACNET_ERROR_CODE_ERROR_CODE_CERTIFICATE_REVOKED: BACNET_ERROR_CODE = 203;
pub const BACNET_ERROR_CODE_ERROR_CODE_UNKNOWN_SECURITY_KEY: BACNET_ERROR_CODE = 204;
pub const BACNET_ERROR_CODE_ERROR_CODE_REFERENCED_PORT_IN_ERROR: BACNET_ERROR_CODE = 205;
pub const BACNET_ERROR_CODE_ERROR_CODE_RESERVED_MAX: BACNET_ERROR_CODE = 255;
pub const BACNET_ERROR_CODE_ERROR_CODE_PROPRIETARY_FIRST: BACNET_ERROR_CODE = 256;
pub const BACNET_ERROR_CODE_ERROR_CODE_PROPRIETARY_LAST: BACNET_ERROR_CODE = 65535;
pub type BACNET_ERROR_CODE = ::std::os::raw::c_uint;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_COLDSTART: BACNET_REINITIALIZED_STATE = 0;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_WARMSTART: BACNET_REINITIALIZED_STATE = 1;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_STARTBACKUP: BACNET_REINITIALIZED_STATE = 2;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_ENDBACKUP: BACNET_REINITIALIZED_STATE = 3;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_STARTRESTORE: BACNET_REINITIALIZED_STATE = 4;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_ENDRESTORE: BACNET_REINITIALIZED_STATE = 5;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_ABORTRESTORE: BACNET_REINITIALIZED_STATE = 6;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_ACTIVATE_CHANGES: BACNET_REINITIALIZED_STATE = 7;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_IDLE: BACNET_REINITIALIZED_STATE = 255;
pub const BACNET_REINITIALIZED_STATE_BACNET_REINIT_MAX: BACNET_REINITIALIZED_STATE = 255;
pub type BACNET_REINITIALIZED_STATE = ::std::os::raw::c_uint;
pub const BACnetNodeType_BACNET_NODE_UNKNOWN: BACnetNodeType = 0;
pub const BACnetNodeType_BACNET_NODE_SYSTEM: BACnetNodeType = 1;
pub const BACnetNodeType_BACNET_NODE_NETWORK: BACnetNodeType = 2;
pub const BACnetNodeType_BACNET_NODE_DEVICE: BACnetNodeType = 3;
pub const BACnetNodeType_BACNET_NODE_ORGANIZATIONAL: BACnetNodeType = 4;
pub const BACnetNodeType_BACNET_NODE_AREA: BACnetNodeType = 5;
pub const BACnetNodeType_BACNET_NODE_EQUIPMENT: BACnetNodeType = 6;
pub const BACnetNodeType_BACNET_NODE_POINT: BACnetNodeType = 7;
pub const BACnetNodeType_BACNET_NODE_COLLECTION: BACnetNodeType = 8;
pub const BACnetNodeType_BACNET_NODE_PROPERTY: BACnetNodeType = 9;
pub const BACnetNodeType_BACNET_NODE_FUNCTIONAL: BACnetNodeType = 10;
pub const BACnetNodeType_BACNET_NODE_OTHER: BACnetNodeType = 11;
pub type BACnetNodeType = ::std::os::raw::c_uint;
pub use self::BACnetNodeType as BACNET_NODE_TYPE;
pub const BACnetShedState_BACNET_SHED_INACTIVE: BACnetShedState = 0;
pub const BACnetShedState_BACNET_SHED_REQUEST_PENDING: BACnetShedState = 1;
pub const BACnetShedState_BACNET_SHED_COMPLIANT: BACnetShedState = 2;
pub const BACnetShedState_BACNET_SHED_NON_COMPLIANT: BACnetShedState = 3;
pub type BACnetShedState = ::std::os::raw::c_uint;
pub use self::BACnetShedState as BACNET_SHED_STATE;
pub const BACnetLightingOperation_BACNET_LIGHTS_NONE: BACnetLightingOperation = 0;
pub const BACnetLightingOperation_BACNET_LIGHTS_FADE_TO: BACnetLightingOperation = 1;
pub const BACnetLightingOperation_BACNET_LIGHTS_RAMP_TO: BACnetLightingOperation = 2;
pub const BACnetLightingOperation_BACNET_LIGHTS_STEP_UP: BACnetLightingOperation = 3;
pub const BACnetLightingOperation_BACNET_LIGHTS_STEP_DOWN: BACnetLightingOperation = 4;
pub const BACnetLightingOperation_BACNET_LIGHTS_STEP_ON: BACnetLightingOperation = 5;
pub const BACnetLightingOperation_BACNET_LIGHTS_STEP_OFF: BACnetLightingOperation = 6;
pub const BACnetLightingOperation_BACNET_LIGHTS_WARN: BACnetLightingOperation = 7;
pub const BACnetLightingOperation_BACNET_LIGHTS_WARN_OFF: BACnetLightingOperation = 8;
pub const BACnetLightingOperation_BACNET_LIGHTS_WARN_RELINQUISH: BACnetLightingOperation = 9;
pub const BACnetLightingOperation_BACNET_LIGHTS_STOP: BACnetLightingOperation = 10;
pub const BACnetLightingOperation_MAX_BACNET_LIGHTING_OPERATION: BACnetLightingOperation = 11;
pub const BACnetLightingOperation_BACNET_LIGHTS_PROPRIETARY_FIRST: BACnetLightingOperation = 256;
pub const BACnetLightingOperation_BACNET_LIGHTS_PROPRIETARY_LAST: BACnetLightingOperation = 65535;
pub type BACnetLightingOperation = ::std::os::raw::c_uint;
pub use self::BACnetLightingOperation as BACNET_LIGHTING_OPERATION;
pub const BACnetLightingInProgress_BACNET_LIGHTING_IDLE: BACnetLightingInProgress = 0;
pub const BACnetLightingInProgress_BACNET_LIGHTING_FADE_ACTIVE: BACnetLightingInProgress = 1;
pub const BACnetLightingInProgress_BACNET_LIGHTING_RAMP_ACTIVE: BACnetLightingInProgress = 2;
pub const BACnetLightingInProgress_BACNET_LIGHTING_NOT_CONTROLLED: BACnetLightingInProgress = 3;
pub const BACnetLightingInProgress_BACNET_LIGHTING_OTHER: BACnetLightingInProgress = 4;
pub const BACnetLightingInProgress_BACNET_LIGHTING_TRIM_ACTIVE: BACnetLightingInProgress = 5;
pub const BACnetLightingInProgress_MAX_BACNET_LIGHTING_IN_PROGRESS: BACnetLightingInProgress = 6;
pub type BACnetLightingInProgress = ::std::os::raw::c_uint;
pub use self::BACnetLightingInProgress as BACNET_LIGHTING_IN_PROGRESS;
pub const BACnetLightingTransition_BACNET_LIGHTING_TRANSITION_IDLE: BACnetLightingTransition = 0;
pub const BACnetLightingTransition_BACNET_LIGHTING_TRANSITION_FADE: BACnetLightingTransition = 1;
pub const BACnetLightingTransition_BACNET_LIGHTING_TRANSITION_RAMP: BACnetLightingTransition = 2;
pub const BACnetLightingTransition_MAX_BACNET_LIGHTING_TRANSITION: BACnetLightingTransition = 3;
pub const BACnetLightingTransition_BACNET_LIGHTING_TRANSITION_PROPRIETARY_FIRST:
    BACnetLightingTransition = 64;
pub const BACnetLightingTransition_BACNET_LIGHTING_TRANSITION_PROPRIETARY_LAST:
    BACnetLightingTransition = 255;
pub type BACnetLightingTransition = ::std::os::raw::c_uint;
pub use self::BACnetLightingTransition as BACNET_LIGHTING_TRANSITION;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_NONE: BACnetColorOperation = 0;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_FADE_TO_COLOR: BACnetColorOperation = 1;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_FADE_TO_CCT: BACnetColorOperation = 2;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_RAMP_TO_CCT: BACnetColorOperation = 3;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_STEP_UP_CCT: BACnetColorOperation = 4;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_STEP_DOWN_CCT: BACnetColorOperation = 5;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_STOP: BACnetColorOperation = 6;
pub const BACnetColorOperation_BACNET_COLOR_OPERATION_MAX: BACnetColorOperation = 7;
pub type BACnetColorOperation = ::std::os::raw::c_uint;
pub use self::BACnetColorOperation as BACNET_COLOR_OPERATION;
pub const BACnetColorOperationInProgress_BACNET_COLOR_OPERATION_IN_PROGRESS_IDLE:
    BACnetColorOperationInProgress = 0;
pub const BACnetColorOperationInProgress_BACNET_COLOR_OPERATION_IN_PROGRESS_FADE_ACTIVE:
    BACnetColorOperationInProgress = 1;
pub const BACnetColorOperationInProgress_BACNET_COLOR_OPERATION_IN_PROGRESS_RAMP_ACTIVE:
    BACnetColorOperationInProgress = 2;
pub const BACnetColorOperationInProgress_BACNET_COLOR_OPERATION_IN_PROGRESS_NOT_CONTROLLED:
    BACnetColorOperationInProgress = 3;
pub const BACnetColorOperationInProgress_BACNET_COLOR_OPERATION_IN_PROGRESS_OTHER:
    BACnetColorOperationInProgress = 4;
pub const BACnetColorOperationInProgress_BACNET_COLOR_OPERATION_IN_PROGRESS_MAX:
    BACnetColorOperationInProgress = 5;
pub type BACnetColorOperationInProgress = ::std::os::raw::c_uint;
pub use self::BACnetColorOperationInProgress as BACNET_COLOR_OPERATION_IN_PROGRESS;
pub const BACnetColorTransition_BACNET_COLOR_TRANSITION_NONE: BACnetColorTransition = 0;
pub const BACnetColorTransition_BACNET_COLOR_TRANSITION_FADE: BACnetColorTransition = 1;
pub const BACnetColorTransition_BACNET_COLOR_TRANSITION_RAMP: BACnetColorTransition = 2;
pub const BACnetColorTransition_BACNET_COLOR_TRANSITION_MAX: BACnetColorTransition = 3;
pub type BACnetColorTransition = ::std::os::raw::c_uint;
pub use self::BACnetColorTransition as BACNET_COLOR_TRANSITION;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_MONDAY: BACnetDaysOfWeek = 0;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_TUESDAY: BACnetDaysOfWeek = 1;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_WEDNESDAY: BACnetDaysOfWeek = 2;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_THURSDAY: BACnetDaysOfWeek = 3;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_FRIDAY: BACnetDaysOfWeek = 4;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_SATURDAY: BACnetDaysOfWeek = 5;
pub const BACnetDaysOfWeek_BACNET_DAYS_OF_WEEK_SUNDAY: BACnetDaysOfWeek = 6;
pub const BACnetDaysOfWeek_MAX_BACNET_DAYS_OF_WEEK: BACnetDaysOfWeek = 7;
pub type BACnetDaysOfWeek = ::std::os::raw::c_uint;
pub use self::BACnetDaysOfWeek as BACNET_DAYS_OF_WEEK;
pub const BACnetEventTransitionBits_TRANSITION_TO_OFFNORMAL: BACnetEventTransitionBits = 0;
pub const BACnetEventTransitionBits_TRANSITION_TO_FAULT: BACnetEventTransitionBits = 1;
pub const BACnetEventTransitionBits_TRANSITION_TO_NORMAL: BACnetEventTransitionBits = 2;
pub const BACnetEventTransitionBits_MAX_BACNET_EVENT_TRANSITION: BACnetEventTransitionBits = 3;
pub type BACnetEventTransitionBits = ::std::os::raw::c_uint;
pub use self::BACnetEventTransitionBits as BACNET_EVENT_TRANSITION_BITS;
pub const BACnetEventTransitionMask_TRANSITION_TO_OFFNORMAL_MASKED: BACnetEventTransitionMask = 1;
pub const BACnetEventTransitionMask_TRANSITION_TO_FAULT_MASKED: BACnetEventTransitionMask = 2;
pub const BACnetEventTransitionMask_TRANSITION_TO_NORMAL_MASKED: BACnetEventTransitionMask = 4;
pub type BACnetEventTransitionMask = ::std::os::raw::c_uint;
pub use self::BACnetEventTransitionMask as BACNET_EVENT_TRANSITION_MASK;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_NORMAL: BACNET_DOOR_ALARM_STATE = 0;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_ALARM: BACNET_DOOR_ALARM_STATE = 1;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_DOOR_OPEN_TOO_LONG: BACNET_DOOR_ALARM_STATE = 2;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_FORCED_OPEN: BACNET_DOOR_ALARM_STATE = 3;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_TAMPER: BACNET_DOOR_ALARM_STATE = 4;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_DOOR_FAULT: BACNET_DOOR_ALARM_STATE = 5;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_LOCK_DOWN: BACNET_DOOR_ALARM_STATE = 6;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_FREE_ACCESS: BACNET_DOOR_ALARM_STATE = 7;
pub const BACNET_DOOR_ALARM_STATE_DOOR_ALARM_STATE_EGRESS_OPEN: BACNET_DOOR_ALARM_STATE = 8;
pub type BACNET_DOOR_ALARM_STATE = ::std::os::raw::c_uint;
pub const BACNET_DOOR_SECURED_STATUS_DOOR_SECURED_STATUS_SECURED: BACNET_DOOR_SECURED_STATUS = 0;
pub const BACNET_DOOR_SECURED_STATUS_DOOR_SECURED_STATUS_UNSECURED: BACNET_DOOR_SECURED_STATUS = 1;
pub const BACNET_DOOR_SECURED_STATUS_DOOR_SECURED_STATUS_UNKNOWN: BACNET_DOOR_SECURED_STATUS = 2;
pub type BACNET_DOOR_SECURED_STATUS = ::std::os::raw::c_uint;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_CLOSED: BACNET_DOOR_STATUS = 0;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_OPENED: BACNET_DOOR_STATUS = 1;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_UNKNOWN: BACNET_DOOR_STATUS = 2;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_DOOR_FAULT: BACNET_DOOR_STATUS = 3;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_UNUSED: BACNET_DOOR_STATUS = 4;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_NONE: BACNET_DOOR_STATUS = 5;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_CLOSING: BACNET_DOOR_STATUS = 6;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_OPENING: BACNET_DOOR_STATUS = 7;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_SAFETY_LOCKED: BACNET_DOOR_STATUS = 8;
pub const BACNET_DOOR_STATUS_DOOR_STATUS_LIMITED_OPENED: BACNET_DOOR_STATUS = 9;
pub type BACNET_DOOR_STATUS = ::std::os::raw::c_uint;
pub const BACNET_DOOR_VALUE_DOOR_VALUE_LOCK: BACNET_DOOR_VALUE = 0;
pub const BACNET_DOOR_VALUE_DOOR_VALUE_UNLOCK: BACNET_DOOR_VALUE = 1;
pub const BACNET_DOOR_VALUE_DOOR_VALUE_PULSE_UNLOCK: BACNET_DOOR_VALUE = 2;
pub const BACNET_DOOR_VALUE_DOOR_VALUE_EXTENDED_PULSE_UNLOCK: BACNET_DOOR_VALUE = 3;
pub type BACNET_DOOR_VALUE = ::std::os::raw::c_uint;
pub const BACNET_LOCK_STATUS_LOCK_STATUS_LOCKED: BACNET_LOCK_STATUS = 0;
pub const BACNET_LOCK_STATUS_LOCK_STATUS_UNLOCKED: BACNET_LOCK_STATUS = 1;
pub const BACNET_LOCK_STATUS_LOCK_STATUS_LOCK_FAULT: BACNET_LOCK_STATUS = 2;
pub const BACNET_LOCK_STATUS_LOCK_STATUS_UNUSED: BACNET_LOCK_STATUS = 3;
pub const BACNET_LOCK_STATUS_LOCK_STATUS_UNKNOWN: BACNET_LOCK_STATUS = 4;
pub type BACNET_LOCK_STATUS = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_NONE: BACNET_ACCESS_EVENT = 0;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_GRANTED: BACNET_ACCESS_EVENT = 1;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_MUSTER: BACNET_ACCESS_EVENT = 2;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_PASSBACK_DETECTED: BACNET_ACCESS_EVENT = 3;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DURESS: BACNET_ACCESS_EVENT = 4;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_TRACE: BACNET_ACCESS_EVENT = 5;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_LOCKOUT_MAX_ATTEMPTS: BACNET_ACCESS_EVENT = 6;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_LOCKOUT_OTHER: BACNET_ACCESS_EVENT = 7;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_LOCKOUT_RELINQUISHED: BACNET_ACCESS_EVENT = 8;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_LOCKED_BY_HIGHER_AUTHORITY: BACNET_ACCESS_EVENT = 9;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_OUT_OF_SERVICE: BACNET_ACCESS_EVENT = 10;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_OUT_OF_SERVICE_RELINQUISHED: BACNET_ACCESS_EVENT = 11;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_ACCOMPANIMENT_BY: BACNET_ACCESS_EVENT = 12;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_AUTHENTICATION_FACTOR_READ: BACNET_ACCESS_EVENT = 13;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_AUTHORIZATION_DELAYED: BACNET_ACCESS_EVENT = 14;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_VERIFICATION_REQUIRED: BACNET_ACCESS_EVENT = 15;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_DENY_ALL: BACNET_ACCESS_EVENT = 128;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_UNKNOWN_CREDENTIAL: BACNET_ACCESS_EVENT = 129;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_UNAVAILABLE: BACNET_ACCESS_EVENT =
    130;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_TIMEOUT:
    BACNET_ACCESS_EVENT = 131;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_INCORRECT_AUTHENTICATION_FACTOR:
    BACNET_ACCESS_EVENT = 132;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_ZONE_NO_ACCESS_RIGHTS: BACNET_ACCESS_EVENT = 133;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_POINT_NO_ACCESS_RIGHTS: BACNET_ACCESS_EVENT = 134;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_NO_ACCESS_RIGHTS: BACNET_ACCESS_EVENT = 135;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_OUT_OF_TIME_RANGE: BACNET_ACCESS_EVENT = 136;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_THREAT_LEVEL: BACNET_ACCESS_EVENT = 137;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_PASSBACK: BACNET_ACCESS_EVENT = 138;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_UNEXPECTED_LOCATION_USAGE: BACNET_ACCESS_EVENT =
    139;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_MAX_ATTEMPTS: BACNET_ACCESS_EVENT = 140;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_LOWER_OCCUPANCY_LIMIT: BACNET_ACCESS_EVENT = 141;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_UPPER_OCCUPANCY_LIMIT: BACNET_ACCESS_EVENT = 142;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_LOST: BACNET_ACCESS_EVENT =
    143;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_STOLEN:
    BACNET_ACCESS_EVENT = 144;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_DAMAGED:
    BACNET_ACCESS_EVENT = 145;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_DESTROYED:
    BACNET_ACCESS_EVENT = 146;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_DISABLED:
    BACNET_ACCESS_EVENT = 147;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_AUTHENTICATION_FACTOR_ERROR: BACNET_ACCESS_EVENT =
    148;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_UNASSIGNED: BACNET_ACCESS_EVENT = 149;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_NOT_PROVISIONED: BACNET_ACCESS_EVENT =
    150;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_NOT_YET_ACTIVE: BACNET_ACCESS_EVENT =
    151;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_EXPIRED: BACNET_ACCESS_EVENT = 152;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_MANUAL_DISABLE: BACNET_ACCESS_EVENT =
    153;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_LOCKOUT: BACNET_ACCESS_EVENT = 154;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_MAX_DAYS: BACNET_ACCESS_EVENT = 155;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_MAX_USES: BACNET_ACCESS_EVENT = 156;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_INACTIVITY: BACNET_ACCESS_EVENT = 157;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_CREDENTIAL_DISABLED: BACNET_ACCESS_EVENT = 158;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_NO_ACCOMPANIMENT: BACNET_ACCESS_EVENT = 159;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_INCORRECT_ACCOMPANIMENT: BACNET_ACCESS_EVENT =
    160;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_LOCKOUT: BACNET_ACCESS_EVENT = 161;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_VERIFICATION_FAILED: BACNET_ACCESS_EVENT = 162;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_VERIFICATION_TIMEOUT: BACNET_ACCESS_EVENT = 163;
pub const BACNET_ACCESS_EVENT_ACCESS_EVENT_DENIED_OTHER: BACNET_ACCESS_EVENT = 164;
pub type BACNET_ACCESS_EVENT = ::std::os::raw::c_uint;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_NOT_READY:
    BACNET_AUTHENTICATION_STATUS = 0;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_READY: BACNET_AUTHENTICATION_STATUS =
    1;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_DISABLED:
    BACNET_AUTHENTICATION_STATUS = 2;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_WAITING_FOR_AUTHENTICATION_FACTOR:
    BACNET_AUTHENTICATION_STATUS = 3;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_WAITING_FOR_ACCOMPANIMENT:
    BACNET_AUTHENTICATION_STATUS = 4;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_WAITING_FOR_VERIFICATION:
    BACNET_AUTHENTICATION_STATUS = 5;
pub const BACNET_AUTHENTICATION_STATUS_AUTHENTICATION_STATUS_IN_PROGRESS:
    BACNET_AUTHENTICATION_STATUS = 6;
pub type BACNET_AUTHENTICATION_STATUS = ::std::os::raw::c_uint;
pub const BACNET_AUTHORIZATION_MODE_AUTHORIZATION_MODE_AUTHORIZE: BACNET_AUTHORIZATION_MODE = 0;
pub const BACNET_AUTHORIZATION_MODE_AUTHORIZATION_MODE_GRANT_ACTIVE: BACNET_AUTHORIZATION_MODE = 1;
pub const BACNET_AUTHORIZATION_MODE_AUTHORIZATION_MODE_DENY_ALL: BACNET_AUTHORIZATION_MODE = 2;
pub const BACNET_AUTHORIZATION_MODE_AUTHORIZATION_MODE_VERIFICATION_REQUIRED:
    BACNET_AUTHORIZATION_MODE = 3;
pub const BACNET_AUTHORIZATION_MODE_AUTHORIZATION_MODE_AUTHORIZATION_DELAYED:
    BACNET_AUTHORIZATION_MODE = 4;
pub const BACNET_AUTHORIZATION_MODE_AUTHORIZATION_MODE_NONE: BACNET_AUTHORIZATION_MODE = 5;
pub type BACNET_AUTHORIZATION_MODE = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_PASSBACK_MODE_ACCESS_PASSBACK_MODE_PASSBACK_OFF:
    BACNET_ACCESS_PASSBACK_MODE = 0;
pub const BACNET_ACCESS_PASSBACK_MODE_ACCESS_PASSBACK_MODE_HARD_PASSBACK:
    BACNET_ACCESS_PASSBACK_MODE = 1;
pub const BACNET_ACCESS_PASSBACK_MODE_ACCESS_PASSBACK_MODE_SOFT_PASSBACK:
    BACNET_ACCESS_PASSBACK_MODE = 2;
pub type BACNET_ACCESS_PASSBACK_MODE = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_NORMAL:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 0;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_BELOW_LOWER_LIMIT:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 1;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_AT_LOWER_LIMIT:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 2;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_AT_UPPER_LIMIT:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 3;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_ABOVE_UPPER_LIMIT:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 4;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_DISABLED:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 5;
pub const BACNET_ACCESS_ZONE_OCCUPANCY_STATE_ACCESS_ZONE_OCCUPANCY_STATE_NOT_SUPPORTED:
    BACNET_ACCESS_ZONE_OCCUPANCY_STATE = 6;
pub type BACNET_ACCESS_ZONE_OCCUPANCY_STATE = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_USER_TYPE_ACCESS_USER_TYPE_ASSET: BACNET_ACCESS_USER_TYPE = 0;
pub const BACNET_ACCESS_USER_TYPE_ACCESS_USER_TYPE_GROUP: BACNET_ACCESS_USER_TYPE = 1;
pub const BACNET_ACCESS_USER_TYPE_ACCESS_USER_TYPE_PERSON: BACNET_ACCESS_USER_TYPE = 2;
pub type BACNET_ACCESS_USER_TYPE = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_NONE:
    BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 0;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_DISABLED : BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 1 ;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_DISABLED_LOST : BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 2 ;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_DISABLED_STOLEN : BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 3 ;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_DISABLED_DAMAGED : BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 4 ;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_DISABLED_DESTROYED : BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 5 ;
pub const BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE_ACCESS_AUTHENTICATION_FACTOR_DISABLE_MAX:
    BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = 6;
pub type BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE = ::std::os::raw::c_uint;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_PASSBACK:
    BACNET_AUTHORIZATION_EXEMPTION = 0;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_OCCUPANCY_CHECK:
    BACNET_AUTHORIZATION_EXEMPTION = 1;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_ACCESS_RIGHTS:
    BACNET_AUTHORIZATION_EXEMPTION = 2;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_LOCKOUT:
    BACNET_AUTHORIZATION_EXEMPTION = 3;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_DENY:
    BACNET_AUTHORIZATION_EXEMPTION = 4;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_VERIFICATION:
    BACNET_AUTHORIZATION_EXEMPTION = 5;
pub const BACNET_AUTHORIZATION_EXEMPTION_AUTHORIZATION_EXEMPTION_AUTHORIZATION_DELAY:
    BACNET_AUTHORIZATION_EXEMPTION = 6;
pub type BACNET_AUTHORIZATION_EXEMPTION = ::std::os::raw::c_uint;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_UNKNOWN_ERROR:
    BACNET_NETWORK_REJECT_REASONS = 0;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_NO_ROUTE: BACNET_NETWORK_REJECT_REASONS = 1;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_ROUTER_BUSY: BACNET_NETWORK_REJECT_REASONS =
    2;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_UNKNOWN_MESSAGE_TYPE:
    BACNET_NETWORK_REJECT_REASONS = 3;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_MESSAGE_TOO_LONG:
    BACNET_NETWORK_REJECT_REASONS = 4;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_BACNET_SECURITY:
    BACNET_NETWORK_REJECT_REASONS = 5;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_BAD_ADDRESS: BACNET_NETWORK_REJECT_REASONS =
    6;
pub const BACNET_NETWORK_REJECT_REASONS_NETWORK_REJECT_REASON_INVALID:
    BACNET_NETWORK_REJECT_REASONS = 7;
pub type BACNET_NETWORK_REJECT_REASONS = ::std::os::raw::c_uint;
pub const BACnetWriteStatus_BACNET_WRITE_STATUS_IDLE: BACnetWriteStatus = 0;
pub const BACnetWriteStatus_BACNET_WRITE_STATUS_IN_PROGRESS: BACnetWriteStatus = 1;
pub const BACnetWriteStatus_BACNET_WRITE_STATUS_SUCCESSFUL: BACnetWriteStatus = 2;
pub const BACnetWriteStatus_BACNET_WRITE_STATUS_FAILED: BACnetWriteStatus = 3;
pub type BACnetWriteStatus = ::std::os::raw::c_uint;
pub use self::BACnetWriteStatus as BACNET_WRITE_STATUS;
pub const BACNET_PORT_TYPE_PORT_TYPE_ETHERNET: BACNET_PORT_TYPE = 0;
pub const BACNET_PORT_TYPE_PORT_TYPE_ARCNET: BACNET_PORT_TYPE = 1;
pub const BACNET_PORT_TYPE_PORT_TYPE_MSTP: BACNET_PORT_TYPE = 2;
pub const BACNET_PORT_TYPE_PORT_TYPE_PTP: BACNET_PORT_TYPE = 3;
pub const BACNET_PORT_TYPE_PORT_TYPE_LONTALK: BACNET_PORT_TYPE = 4;
pub const BACNET_PORT_TYPE_PORT_TYPE_BIP: BACNET_PORT_TYPE = 5;
pub const BACNET_PORT_TYPE_PORT_TYPE_ZIGBEE: BACNET_PORT_TYPE = 6;
pub const BACNET_PORT_TYPE_PORT_TYPE_VIRTUAL: BACNET_PORT_TYPE = 7;
pub const BACNET_PORT_TYPE_PORT_TYPE_NON_BACNET: BACNET_PORT_TYPE = 8;
pub const BACNET_PORT_TYPE_PORT_TYPE_BIP6: BACNET_PORT_TYPE = 9;
pub const BACNET_PORT_TYPE_PORT_TYPE_SERIAL: BACNET_PORT_TYPE = 10;
pub const BACNET_PORT_TYPE_PORT_TYPE_BSC: BACNET_PORT_TYPE = 11;
pub const BACNET_PORT_TYPE_PORT_TYPE_RESERVED_FIRST: BACNET_PORT_TYPE = 12;
pub const BACNET_PORT_TYPE_PORT_TYPE_RESERVED_LAST: BACNET_PORT_TYPE = 63;
pub const BACNET_PORT_TYPE_PORT_TYPE_PROPRIETARY_FIRST: BACNET_PORT_TYPE = 64;
pub const BACNET_PORT_TYPE_PORT_TYPE_BSC_INTERIM: BACNET_PORT_TYPE = 64;
pub const BACNET_PORT_TYPE_PORT_TYPE_PROPRIETARY_LAST: BACNET_PORT_TYPE = 255;
pub const BACNET_PORT_TYPE_PORT_TYPE_MAX: BACNET_PORT_TYPE = 255;
pub type BACNET_PORT_TYPE = ::std::os::raw::c_uint;
pub const BACNET_PORT_QUALITY_PORT_QUALITY_UNKNOWN: BACNET_PORT_QUALITY = 0;
pub const BACNET_PORT_QUALITY_PORT_QUALITY_LEARNED: BACNET_PORT_QUALITY = 1;
pub const BACNET_PORT_QUALITY_PORT_QUALITY_LEARNED_CONFIGURED: BACNET_PORT_QUALITY = 2;
pub const BACNET_PORT_QUALITY_PORT_QUALITY_CONFIGURED: BACNET_PORT_QUALITY = 3;
pub type BACNET_PORT_QUALITY = ::std::os::raw::c_uint;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_IDLE: BACNET_PORT_COMMAND = 0;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_DISCARD_CHANGES: BACNET_PORT_COMMAND = 1;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RENEW_FD_REGISTRATION: BACNET_PORT_COMMAND = 2;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RESTART_SLAVE_DISCOVERY: BACNET_PORT_COMMAND = 3;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RENEW_DHCP: BACNET_PORT_COMMAND = 4;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RESTART_AUTONEGOTIATION: BACNET_PORT_COMMAND = 5;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_DISCONNECT: BACNET_PORT_COMMAND = 6;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RESTART_PORT: BACNET_PORT_COMMAND = 7;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_GENERATE_CSR_FILE: BACNET_PORT_COMMAND = 8;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_VALIDATE_CHANGES: BACNET_PORT_COMMAND = 9;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RESERVED_FIRST: BACNET_PORT_COMMAND = 10;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_RESERVED_LAST: BACNET_PORT_COMMAND = 127;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_PROPRIETARY_FIRST: BACNET_PORT_COMMAND = 128;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_PROPRIETARY_LAST: BACNET_PORT_COMMAND = 255;
pub const BACNET_PORT_COMMAND_PORT_COMMAND_MAX: BACNET_PORT_COMMAND = 255;
pub type BACNET_PORT_COMMAND = ::std::os::raw::c_uint;
pub const BACNET_SECURITY_LEVEL_BACNET_SECURITY_LEVEL_INCAPABLE: BACNET_SECURITY_LEVEL = 0;
pub const BACNET_SECURITY_LEVEL_BACNET_SECURITY_LEVEL_PLAIN: BACNET_SECURITY_LEVEL = 1;
pub const BACNET_SECURITY_LEVEL_BACNET_SECURITY_LEVEL_SIGNED: BACNET_SECURITY_LEVEL = 2;
pub const BACNET_SECURITY_LEVEL_BACNET_SECURITY_LEVEL_ENCRYPTED: BACNET_SECURITY_LEVEL = 3;
pub const BACNET_SECURITY_LEVEL_BACNET_SECURITY_LEVEL_SIGNED_END_TO_END: BACNET_SECURITY_LEVEL = 4;
pub const BACNET_SECURITY_LEVEL_BACNET_SECURITY_LEVEL_ENCRYPTED_END_TO_END: BACNET_SECURITY_LEVEL =
    5;
pub type BACNET_SECURITY_LEVEL = ::std::os::raw::c_uint;
pub const BACNET_SECURITY_POLICY_BACNET_SECURITY_POLICY_PLAIN_NOT_TRUSTED: BACNET_SECURITY_POLICY =
    0;
pub const BACNET_SECURITY_POLICY_BACNET_SECURITY_POLICY_PLAIN_TRUSTED: BACNET_SECURITY_POLICY = 1;
pub const BACNET_SECURITY_POLICY_BACNET_SECURITY_POLICY_SIGNED_TRUSTED: BACNET_SECURITY_POLICY = 2;
pub const BACNET_SECURITY_POLICY_BACNET_SECURITY_POLICY_ENCRYPTED_TRUSTED: BACNET_SECURITY_POLICY =
    3;
pub type BACNET_SECURITY_POLICY = ::std::os::raw::c_uint;
pub const BACNET_KEY_IDENTIFIER_ALGORITHM_KIA_AES_MD5: BACNET_KEY_IDENTIFIER_ALGORITHM = 0;
pub const BACNET_KEY_IDENTIFIER_ALGORITHM_KIA_AES_SHA256: BACNET_KEY_IDENTIFIER_ALGORITHM = 1;
pub const BACNET_KEY_IDENTIFIER_ALGORITHM_KIA_MAX_KEY_IDENTIFIER_ALGORITHM:
    BACNET_KEY_IDENTIFIER_ALGORITHM = 255;
pub type BACNET_KEY_IDENTIFIER_ALGORITHM = ::std::os::raw::c_uint;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_NOT_USED: BACNET_KEY_IDENTIFIER_KEY_NUMBER = 0;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_DEVICE_MASTER: BACNET_KEY_IDENTIFIER_KEY_NUMBER = 1;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_DISTRIBUTION: BACNET_KEY_IDENTIFIER_KEY_NUMBER = 2;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_INSTALLATION: BACNET_KEY_IDENTIFIER_KEY_NUMBER = 3;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_GENERAL_NETWORK_ACCESS:
    BACNET_KEY_IDENTIFIER_KEY_NUMBER = 4;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_USER_AUTHENTICATED:
    BACNET_KEY_IDENTIFIER_KEY_NUMBER = 5;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_MIN_APPLICATION_SPECIFIC:
    BACNET_KEY_IDENTIFIER_KEY_NUMBER = 6;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_MAX_APPLICATION_SPECIFIC:
    BACNET_KEY_IDENTIFIER_KEY_NUMBER = 127;
pub const BACNET_KEY_IDENTIFIER_KEY_NUMBER_KIKN_MAX_KEY_IDENTIFIER_KEY_NUMBER:
    BACNET_KEY_IDENTIFIER_KEY_NUMBER = 255;
pub type BACNET_KEY_IDENTIFIER_KEY_NUMBER = ::std::os::raw::c_uint;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_SUCCESS: BACNET_SECURITY_RESPONSE_CODE = 0;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_ACCESS_DENIED: BACNET_SECURITY_RESPONSE_CODE = 1;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_BAD_DESTINATION_ADDRESS:
    BACNET_SECURITY_RESPONSE_CODE = 2;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_BAD_DESTINATION_DEVICE_ID:
    BACNET_SECURITY_RESPONSE_CODE = 3;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_BAD_SIGNATURE: BACNET_SECURITY_RESPONSE_CODE = 4;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_BAD_SOURCE_ADDRESS: BACNET_SECURITY_RESPONSE_CODE =
    5;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_BAD_TIMESTAMP: BACNET_SECURITY_RESPONSE_CODE = 6;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_CANNOT_USE_KEY: BACNET_SECURITY_RESPONSE_CODE = 7;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_CANNOT_VERIFY_MESSAGE_ID:
    BACNET_SECURITY_RESPONSE_CODE = 8;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_CORRECT_KEY_REVISION:
    BACNET_SECURITY_RESPONSE_CODE = 9;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_DESTINATION_DEVICE_ID_REQUIRED:
    BACNET_SECURITY_RESPONSE_CODE = 10;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_DUPLICATE_MESSAGE: BACNET_SECURITY_RESPONSE_CODE =
    11;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_ENCRYPTION_NOT_CONFIGURED:
    BACNET_SECURITY_RESPONSE_CODE = 12;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_ENCRYPTION_REQUIRED:
    BACNET_SECURITY_RESPONSE_CODE = 13;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_INCORRECT_KEY: BACNET_SECURITY_RESPONSE_CODE = 14;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_INVALID_KEY_DATA: BACNET_SECURITY_RESPONSE_CODE =
    15;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_KEY_UPDATE_IN_PROGRESS:
    BACNET_SECURITY_RESPONSE_CODE = 16;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_MALFORMED_MESSAGE: BACNET_SECURITY_RESPONSE_CODE =
    17;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_NOT_KEY_SERVER: BACNET_SECURITY_RESPONSE_CODE = 18;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_SECURITY_NOT_CONFIGURED:
    BACNET_SECURITY_RESPONSE_CODE = 19;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_SOURCE_SECURITY_REQUIRED:
    BACNET_SECURITY_RESPONSE_CODE = 20;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_TOO_MANY_KEYS: BACNET_SECURITY_RESPONSE_CODE = 21;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_UNKNOWN_AUTHENTICATION_TYPE:
    BACNET_SECURITY_RESPONSE_CODE = 22;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_UNKNOWN_KEY: BACNET_SECURITY_RESPONSE_CODE = 23;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_UNKNOWN_KEY_REVISION:
    BACNET_SECURITY_RESPONSE_CODE = 24;
pub const BACNET_SECURITY_RESPONSE_CODE_SEC_RESP_UNKNOWN_SOURCE_MESSAGE:
    BACNET_SECURITY_RESPONSE_CODE = 25;
pub type BACNET_SECURITY_RESPONSE_CODE = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_ACCESS_CREDENTIAL_DISABLE_NONE:
    BACNET_ACCESS_CREDENTIAL_DISABLE = 0;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_ACCESS_CREDENTIAL_DISABLE:
    BACNET_ACCESS_CREDENTIAL_DISABLE = 1;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_ACCESS_CREDENTIAL_DISABLE_MANUAL:
    BACNET_ACCESS_CREDENTIAL_DISABLE = 2;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_ACCESS_CREDENTIAL_DISABLE_LOCKOUT:
    BACNET_ACCESS_CREDENTIAL_DISABLE = 3;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_ACCESS_CREDENTIAL_DISABLE_MAX:
    BACNET_ACCESS_CREDENTIAL_DISABLE = 4;
pub type BACNET_ACCESS_CREDENTIAL_DISABLE = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 0;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_NEEDS_PROVISIONING:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 1;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_UNASSIGNED:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 2;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_NOT_YET_ACTIVE:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 3;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_EXPIRED:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 4;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_LOCKOUT:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 5;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_MAX_DAYS:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 6;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_MAX_USES:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 7;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_INACTIVITY:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 8;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_MANUAL:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 9;
pub const BACNET_ACCESS_CREDENTIAL_DISABLE_REASON_CREDENTIAL_DISABLED_MAX:
    BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = 10;
pub type BACNET_ACCESS_CREDENTIAL_DISABLE_REASON = ::std::os::raw::c_uint;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_NONE:
    BACNET_AUTHENTICATION_DISABLE_REASON = 0;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_DISABLED:
    BACNET_AUTHENTICATION_DISABLE_REASON = 1;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_DISABLED_LOST:
    BACNET_AUTHENTICATION_DISABLE_REASON = 2;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_DISABLED_STOLEN:
    BACNET_AUTHENTICATION_DISABLE_REASON = 3;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_DISABLED_DAMAGED:
    BACNET_AUTHENTICATION_DISABLE_REASON = 4;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_DISABLED_DESTROYED:
    BACNET_AUTHENTICATION_DISABLE_REASON = 5;
pub const BACNET_AUTHENTICATION_DISABLE_REASON_AUTHENTICATION_DISABLED_MAX:
    BACNET_AUTHENTICATION_DISABLE_REASON = 6;
pub type BACNET_AUTHENTICATION_DISABLE_REASON = ::std::os::raw::c_uint;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_UNDEFINED:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 0;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_ERROR:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 1;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_CUSTOM:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 2;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_SIMPLE_NUMBER16:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 3;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_SIMPLE_NUMBER32:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 4;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_SIMPLE_NUMBER56:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 5;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_SIMPLE_ALPHA_NUMERIC:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 6;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_ABA_TRACK2:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 7;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_WIEGAND26:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 8;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_WIEGAND37:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 9;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_WIEGAND37_FACILITY:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 10;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_FACILITY16_CARD32:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 11;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_FACILITY32_CARD32:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 12;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_FASC_N:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 13;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_FASC_N_BCD:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 14;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_FASC_N_LARGE:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 15;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_FASC_N_LARGE_BCD:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 16;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_GSA75:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 17;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_CHUID:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 18;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_CHUID_FULL:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 19;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_GUID:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 20;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_CBEFF_A:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 21;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_CBEFF_B:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 22;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_CBEFF_C:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 23;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_USER_PASSWORD:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 24;
pub const BACNET_AUTHENTICATION_FACTOR_TYPE_AUTHENTICATION_FACTOR_MAX:
    BACNET_AUTHENTICATION_FACTOR_TYPE = 25;
pub type BACNET_AUTHENTICATION_FACTOR_TYPE = ::std::os::raw::c_uint;
pub const BACnetProtocolLevel_T_BACNET_PROTOCOL_LEVEL_PHYSICAL: BACnetProtocolLevel_T = 0;
pub const BACnetProtocolLevel_T_BACNET_PROTOCOL_LEVEL_PROTOCOL: BACnetProtocolLevel_T = 1;
pub const BACnetProtocolLevel_T_BACNET_PROTOCOL_LEVEL_BACNET_APPLICATION: BACnetProtocolLevel_T = 2;
pub const BACnetProtocolLevel_T_BACNET_PROTOCOL_LEVEL_NON_BACNET_APPLICATION:
    BACnetProtocolLevel_T = 3;
pub type BACnetProtocolLevel_T = ::std::os::raw::c_uint;
pub use self::BACnetProtocolLevel_T as BACNET_PROTOCOL_LEVEL;
pub const BACnetIPMode_T_BACNET_IP_MODE_NORMAL: BACnetIPMode_T = 0;
pub const BACnetIPMode_T_BACNET_IP_MODE_FOREIGN: BACnetIPMode_T = 1;
pub const BACnetIPMode_T_BACNET_IP_MODE_BBMD: BACnetIPMode_T = 2;
pub type BACnetIPMode_T = ::std::os::raw::c_uint;
pub use self::BACnetIPMode_T as BACNET_IP_MODE;
extern "C" {
    pub fn abort_convert_error_code(error_code: BACNET_ERROR_CODE) -> BACNET_ABORT_REASON;
}
extern "C" {
    pub fn abort_convert_to_error_code(abort_code: BACNET_ABORT_REASON) -> BACNET_ERROR_CODE;
}
extern "C" {
    pub fn abort_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        abort_reason: u8,
        server: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        abort_reason: *mut u8,
    ) -> ::std::os::raw::c_int;
}
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type BACNET_UNSIGNED_INTEGER = u64;
extern "C" {
    pub fn encode_unsigned16(apdu: *mut u8, value: u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned16(apdu: *mut u8, value: *mut u16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_unsigned24(apdu: *mut u8, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned24(apdu: *mut u8, value: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_unsigned32(apdu: *mut u8, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned32(apdu: *mut u8, value: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_unsigned40(buffer: *mut u8, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned40(buffer: *mut u8, value: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_unsigned48(buffer: *mut u8, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned48(buffer: *mut u8, value: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_unsigned56(buffer: *mut u8, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned56(buffer: *mut u8, value: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_unsigned64(buffer: *mut u8, value: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned64(buffer: *mut u8, value: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_unsigned_length(value: BACNET_UNSIGNED_INTEGER) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_signed_length(value: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_signed8(apdu: *mut u8, value: i8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_signed8(apdu: *mut u8, value: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_signed16(apdu: *mut u8, value: i16) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_signed16(apdu: *mut u8, value: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_signed24(apdu: *mut u8, value: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_signed24(apdu: *mut u8, value: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_signed32(apdu: *mut u8, value: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_signed32(apdu: *mut u8, value: *mut i32) -> ::std::os::raw::c_int;
}
pub type BACNET_ARRAY_INDEX = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Device_Address {
    pub mac_len: u8,
    pub mac: [u8; 7usize],
    pub net: u16,
    pub len: u8,
    pub adr: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_BACnet_Device_Address() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Device_Address> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Device_Address>(),
        18usize,
        concat!("Size of: ", stringify!(BACnet_Device_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Device_Address>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_Device_Address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mac_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Device_Address),
            "::",
            stringify!(mac_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Device_Address),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).net) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Device_Address),
            "::",
            stringify!(net)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Device_Address),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adr) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Device_Address),
            "::",
            stringify!(adr)
        )
    );
}
pub type BACNET_ADDRESS = BACnet_Device_Address;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_MAC_Address {
    pub len: u8,
    pub adr: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_BACnet_MAC_Address() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_MAC_Address> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_MAC_Address>(),
        8usize,
        concat!("Size of: ", stringify!(BACnet_MAC_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_MAC_Address>(),
        1usize,
        concat!("Alignment of ", stringify!(BACnet_MAC_Address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_MAC_Address),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adr) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_MAC_Address),
            "::",
            stringify!(adr)
        )
    );
}
pub type BACNET_MAC_ADDRESS = BACnet_MAC_Address;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Object_Id {
    pub type_: BACNET_OBJECT_TYPE,
    pub instance: u32,
}
#[test]
fn bindgen_test_layout_BACnet_Object_Id() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Object_Id> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Object_Id>(),
        8usize,
        concat!("Size of: ", stringify!(BACnet_Object_Id))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Object_Id>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_Object_Id))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Id),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Id),
            "::",
            stringify!(instance)
        )
    );
}
pub type BACNET_OBJECT_ID = BACnet_Object_Id;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Bit_String {
    pub bits_used: u8,
    pub value: [u8; 15usize],
}
#[test]
fn bindgen_test_layout_BACnet_Bit_String() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Bit_String> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Bit_String>(),
        16usize,
        concat!("Size of: ", stringify!(BACnet_Bit_String))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Bit_String>(),
        1usize,
        concat!("Alignment of ", stringify!(BACnet_Bit_String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bits_used) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Bit_String),
            "::",
            stringify!(bits_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Bit_String),
            "::",
            stringify!(value)
        )
    );
}
pub type BACNET_BIT_STRING = BACnet_Bit_String;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Character_String {
    pub length: usize,
    pub encoding: u8,
    pub value: [::std::os::raw::c_char; 1470usize],
}
#[test]
fn bindgen_test_layout_BACnet_Character_String() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Character_String> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Character_String>(),
        1480usize,
        concat!("Size of: ", stringify!(BACnet_Character_String))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Character_String>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Character_String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Character_String),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoding) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Character_String),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Character_String),
            "::",
            stringify!(value)
        )
    );
}
pub type BACNET_CHARACTER_STRING = BACnet_Character_String;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Octet_String {
    pub length: usize,
    pub value: [u8; 1470usize],
}
#[test]
fn bindgen_test_layout_BACnet_Octet_String() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Octet_String> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Octet_String>(),
        1480usize,
        concat!("Size of: ", stringify!(BACnet_Octet_String))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Octet_String>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Octet_String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Octet_String),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Octet_String),
            "::",
            stringify!(value)
        )
    );
}
pub type BACNET_OCTET_STRING = BACnet_Octet_String;
extern "C" {
    pub fn bitstring_init(bit_string: *mut BACNET_BIT_STRING);
}
extern "C" {
    pub fn bitstring_set_bit(bit_string: *mut BACNET_BIT_STRING, bit_number: u8, value: bool);
}
extern "C" {
    pub fn bitstring_bit(bit_string: *mut BACNET_BIT_STRING, bit_number: u8) -> bool;
}
extern "C" {
    pub fn bitstring_bits_used(bit_string: *mut BACNET_BIT_STRING) -> u8;
}
extern "C" {
    pub fn bitstring_bytes_used(bit_string: *mut BACNET_BIT_STRING) -> u8;
}
extern "C" {
    pub fn bitstring_bits_capacity(bit_string: *mut BACNET_BIT_STRING) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bitstring_octet(bit_string: *mut BACNET_BIT_STRING, octet_index: u8) -> u8;
}
extern "C" {
    pub fn bitstring_set_octet(bit_string: *mut BACNET_BIT_STRING, index: u8, octet: u8) -> bool;
}
extern "C" {
    pub fn bitstring_set_bits_used(
        bit_string: *mut BACNET_BIT_STRING,
        bytes_used: u8,
        unused_bits: u8,
    ) -> bool;
}
extern "C" {
    pub fn bitstring_copy(dest: *mut BACNET_BIT_STRING, src: *mut BACNET_BIT_STRING) -> bool;
}
extern "C" {
    pub fn bitstring_same(
        bitstring1: *mut BACNET_BIT_STRING,
        bitstring2: *mut BACNET_BIT_STRING,
    ) -> bool;
}
extern "C" {
    pub fn bitstring_init_ascii(
        bit_string: *mut BACNET_BIT_STRING,
        ascii: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_init(
        char_string: *mut BACNET_CHARACTER_STRING,
        encoding: u8,
        value: *const ::std::os::raw::c_char,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_init_ansi(
        char_string: *mut BACNET_CHARACTER_STRING,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_init_ansi_safe(
        char_string: *mut BACNET_CHARACTER_STRING,
        value: *const ::std::os::raw::c_char,
        tmax: usize,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_copy(
        dest: *mut BACNET_CHARACTER_STRING,
        src: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_ansi_copy(
        dest: *mut ::std::os::raw::c_char,
        dest_max_len: usize,
        src: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_same(
        dest: *mut BACNET_CHARACTER_STRING,
        src: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_ansi_same(
        dest: *mut BACNET_CHARACTER_STRING,
        src: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_append(
        char_string: *mut BACNET_CHARACTER_STRING,
        value: *const ::std::os::raw::c_char,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_truncate(
        char_string: *mut BACNET_CHARACTER_STRING,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_set_encoding(
        char_string: *mut BACNET_CHARACTER_STRING,
        encoding: u8,
    ) -> bool;
}
extern "C" {
    pub fn characterstring_value(
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn characterstring_length(char_string: *mut BACNET_CHARACTER_STRING) -> usize;
}
extern "C" {
    pub fn characterstring_encoding(char_string: *mut BACNET_CHARACTER_STRING) -> u8;
}
extern "C" {
    pub fn characterstring_capacity(char_string: *mut BACNET_CHARACTER_STRING) -> usize;
}
extern "C" {
    pub fn characterstring_printable(char_string: *mut BACNET_CHARACTER_STRING) -> bool;
}
extern "C" {
    pub fn characterstring_valid(char_string: *mut BACNET_CHARACTER_STRING) -> bool;
}
extern "C" {
    pub fn utf8_isvalid(str_: *const ::std::os::raw::c_char, length: usize) -> bool;
}
extern "C" {
    pub fn octetstring_init(
        octet_string: *mut BACNET_OCTET_STRING,
        value: *mut u8,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn octetstring_init_ascii_hex(
        octet_string: *mut BACNET_OCTET_STRING,
        ascii_hex: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn octetstring_copy(dest: *mut BACNET_OCTET_STRING, src: *mut BACNET_OCTET_STRING) -> bool;
}
extern "C" {
    pub fn octetstring_copy_value(
        dest: *mut u8,
        length: usize,
        src: *mut BACNET_OCTET_STRING,
    ) -> usize;
}
extern "C" {
    pub fn octetstring_append(
        octet_string: *mut BACNET_OCTET_STRING,
        value: *mut u8,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn octetstring_truncate(octet_string: *mut BACNET_OCTET_STRING, length: usize) -> bool;
}
extern "C" {
    pub fn octetstring_value(octet_string: *mut BACNET_OCTET_STRING) -> *mut u8;
}
extern "C" {
    pub fn octetstring_length(octet_string: *mut BACNET_OCTET_STRING) -> usize;
}
extern "C" {
    pub fn octetstring_capacity(octet_string: *mut BACNET_OCTET_STRING) -> usize;
}
extern "C" {
    pub fn octetstring_value_same(
        octet_string1: *mut BACNET_OCTET_STRING,
        octet_string2: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
pub const BACnet_Weekday_BACNET_WEEKDAY_MONDAY: BACnet_Weekday = 1;
pub const BACnet_Weekday_BACNET_WEEKDAY_TUESDAY: BACnet_Weekday = 2;
pub const BACnet_Weekday_BACNET_WEEKDAY_WEDNESDAY: BACnet_Weekday = 3;
pub const BACnet_Weekday_BACNET_WEEKDAY_THURSDAY: BACnet_Weekday = 4;
pub const BACnet_Weekday_BACNET_WEEKDAY_FRIDAY: BACnet_Weekday = 5;
pub const BACnet_Weekday_BACNET_WEEKDAY_SATURDAY: BACnet_Weekday = 6;
pub const BACnet_Weekday_BACNET_WEEKDAY_SUNDAY: BACnet_Weekday = 7;
pub type BACnet_Weekday = ::std::os::raw::c_uint;
pub use self::BACnet_Weekday as BACNET_WEEKDAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Date {
    pub year: u16,
    pub month: u8,
    pub day: u8,
    pub wday: u8,
}
#[test]
fn bindgen_test_layout_BACnet_Date() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Date> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Date>(),
        6usize,
        concat!("Size of: ", stringify!(BACnet_Date))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Date>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_Date))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Date),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Date),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Date),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wday) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Date),
            "::",
            stringify!(wday)
        )
    );
}
pub type BACNET_DATE = BACnet_Date;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Time {
    pub hour: u8,
    pub min: u8,
    pub sec: u8,
    pub hundredths: u8,
}
#[test]
fn bindgen_test_layout_BACnet_Time() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Time> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Time>(),
        4usize,
        concat!("Size of: ", stringify!(BACnet_Time))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Time>(),
        1usize,
        concat!("Alignment of ", stringify!(BACnet_Time))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Time),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Time),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Time),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hundredths) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Time),
            "::",
            stringify!(hundredths)
        )
    );
}
pub type BACNET_TIME = BACnet_Time;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_DateTime {
    pub date: BACNET_DATE,
    pub time: BACNET_TIME,
}
#[test]
fn bindgen_test_layout_BACnet_DateTime() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_DateTime> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_DateTime>(),
        10usize,
        concat!("Size of: ", stringify!(BACnet_DateTime))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_DateTime>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_DateTime))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_DateTime),
            "::",
            stringify!(date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_DateTime),
            "::",
            stringify!(time)
        )
    );
}
pub type BACNET_DATE_TIME = BACnet_DateTime;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Date_Range {
    pub startdate: BACNET_DATE,
    pub enddate: BACNET_DATE,
}
#[test]
fn bindgen_test_layout_BACnet_Date_Range() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Date_Range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Date_Range>(),
        12usize,
        concat!("Size of: ", stringify!(BACnet_Date_Range))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Date_Range>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_Date_Range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).startdate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Date_Range),
            "::",
            stringify!(startdate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enddate) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Date_Range),
            "::",
            stringify!(enddate)
        )
    );
}
pub type BACNET_DATE_RANGE = BACnet_Date_Range;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Weeknday {
    pub month: u8,
    pub weekofmonth: u8,
    pub dayofweek: u8,
}
#[test]
fn bindgen_test_layout_BACnet_Weeknday() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Weeknday> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Weeknday>(),
        3usize,
        concat!("Size of: ", stringify!(BACnet_Weeknday))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Weeknday>(),
        1usize,
        concat!("Alignment of ", stringify!(BACnet_Weeknday))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Weeknday),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weekofmonth) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Weeknday),
            "::",
            stringify!(weekofmonth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dayofweek) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Weeknday),
            "::",
            stringify!(dayofweek)
        )
    );
}
pub type BACNET_WEEKNDAY = BACnet_Weeknday;
pub type bacnet_time_t = u64;
extern "C" {
    pub fn datetime_set_date(bdate: *mut BACNET_DATE, year: u16, month: u8, day: u8);
}
extern "C" {
    pub fn datetime_set_time(
        btime: *mut BACNET_TIME,
        hour: u8,
        minute: u8,
        seconds: u8,
        hundredths: u8,
    );
}
extern "C" {
    pub fn datetime_set(
        bdatetime: *mut BACNET_DATE_TIME,
        bdate: *mut BACNET_DATE,
        btime: *mut BACNET_TIME,
    );
}
extern "C" {
    pub fn datetime_set_values(
        bdatetime: *mut BACNET_DATE_TIME,
        year: u16,
        month: u8,
        day: u8,
        hour: u8,
        minute: u8,
        seconds: u8,
        hundredths: u8,
    );
}
extern "C" {
    pub fn datetime_hms_to_seconds_since_midnight(hours: u8, minutes: u8, seconds: u8) -> u32;
}
extern "C" {
    pub fn datetime_hm_to_minutes_since_midnight(hours: u8, minutes: u8) -> u16;
}
extern "C" {
    pub fn datetime_hms_from_seconds_since_midnight(
        seconds: u32,
        pHours: *mut u8,
        pMinutes: *mut u8,
        pSeconds: *mut u8,
    );
}
extern "C" {
    pub fn datetime_is_valid(bdate: *mut BACNET_DATE, btime: *mut BACNET_TIME) -> bool;
}
extern "C" {
    pub fn datetime_time_is_valid(btime: *mut BACNET_TIME) -> bool;
}
extern "C" {
    pub fn datetime_date_is_valid(bdate: *mut BACNET_DATE) -> bool;
}
extern "C" {
    pub fn datetime_ymd_from_days_since_epoch(
        days: u32,
        pYear: *mut u16,
        pMonth: *mut u8,
        pDay: *mut u8,
    );
}
extern "C" {
    pub fn datetime_days_since_epoch(bdate: *mut BACNET_DATE) -> u32;
}
extern "C" {
    pub fn datetime_days_since_epoch_into_date(days: u32, bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_day_of_year(bdate: *mut BACNET_DATE) -> u32;
}
extern "C" {
    pub fn datetime_ymd_to_days_since_epoch(year: u16, month: u8, day: u8) -> u32;
}
extern "C" {
    pub fn datetime_day_of_year_into_date(days: u32, year: u16, bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_is_leap_year(year: u16) -> bool;
}
extern "C" {
    pub fn datetime_month_days(year: u16, month: u8) -> u8;
}
extern "C" {
    pub fn datetime_day_of_week(year: u16, month: u8, day: u8) -> u8;
}
extern "C" {
    pub fn datetime_ymd_is_valid(year: u16, month: u8, day: u8) -> bool;
}
extern "C" {
    pub fn datetime_ymd_day_of_year(year: u16, month: u8, day: u8) -> u32;
}
extern "C" {
    pub fn datetime_seconds_since_midnight_into_time(seconds: u32, btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_seconds_since_midnight(btime: *mut BACNET_TIME) -> u32;
}
extern "C" {
    pub fn datetime_minutes_since_midnight(btime: *mut BACNET_TIME) -> u16;
}
extern "C" {
    pub fn datetime_compare_date(
        date1: *mut BACNET_DATE,
        date2: *mut BACNET_DATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_compare_time(
        time1: *mut BACNET_TIME,
        time2: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_compare(
        datetime1: *mut BACNET_DATE_TIME,
        datetime2: *mut BACNET_DATE_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_wildcard_compare_date(
        date1: *mut BACNET_DATE,
        date2: *mut BACNET_DATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_wildcard_compare_time(
        time1: *mut BACNET_TIME,
        time2: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_wildcard_compare(
        datetime1: *mut BACNET_DATE_TIME,
        datetime2: *mut BACNET_DATE_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_copy_date(dest: *mut BACNET_DATE, src: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_copy_time(dest: *mut BACNET_TIME, src: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_copy(dest: *mut BACNET_DATE_TIME, src: *mut BACNET_DATE_TIME);
}
extern "C" {
    pub fn datetime_add_minutes(bdatetime: *mut BACNET_DATE_TIME, minutes: i32);
}
extern "C" {
    pub fn datetime_seconds_since_epoch(bdatetime: *mut BACNET_DATE_TIME) -> bacnet_time_t;
}
extern "C" {
    pub fn datetime_since_epoch_seconds(bdatetime: *mut BACNET_DATE_TIME, seconds: bacnet_time_t);
}
extern "C" {
    pub fn datetime_seconds_since_epoch_max() -> bacnet_time_t;
}
extern "C" {
    pub fn datetime_wildcard_year(bdate: *mut BACNET_DATE) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_year_set(bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_wildcard_month(bdate: *mut BACNET_DATE) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_month_set(bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_wildcard_day(bdate: *mut BACNET_DATE) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_day_set(bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_wildcard_weekday(bdate: *mut BACNET_DATE) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_weekday_set(bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_wildcard_hour(btime: *mut BACNET_TIME) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_hour_set(btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_wildcard_minute(btime: *mut BACNET_TIME) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_minute_set(btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_wildcard_second(btime: *mut BACNET_TIME) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_second_set(btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_wildcard_hundredths(btime: *mut BACNET_TIME) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_hundredths_set(btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_wildcard(bdatetime: *mut BACNET_DATE_TIME) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_present(bdatetime: *mut BACNET_DATE_TIME) -> bool;
}
extern "C" {
    pub fn datetime_wildcard_set(bdatetime: *mut BACNET_DATE_TIME);
}
extern "C" {
    pub fn datetime_date_wildcard_set(bdate: *mut BACNET_DATE);
}
extern "C" {
    pub fn datetime_time_wildcard_set(btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn datetime_local_to_utc(
        utc_time: *mut BACNET_DATE_TIME,
        local_time: *mut BACNET_DATE_TIME,
        utc_offset_minutes: i16,
        dst_adjust_minutes: i8,
    ) -> bool;
}
extern "C" {
    pub fn datetime_utc_to_local(
        local_time: *mut BACNET_DATE_TIME,
        utc_time: *mut BACNET_DATE_TIME,
        utc_offset_minutes: i16,
        dst_adjust_minutes: i8,
    ) -> bool;
}
extern "C" {
    pub fn datetime_date_init_ascii(
        bdate: *mut BACNET_DATE,
        ascii: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn datetime_time_init_ascii(
        btime: *mut BACNET_TIME,
        ascii: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn bacapp_encode_datetime(
        apdu: *mut u8,
        value: *mut BACNET_DATE_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_datetime(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_DATE_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_datetime(
        apdu: *mut u8,
        value: *mut BACNET_DATE_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_datetime(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_DATE_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datetime_local(
        bdate: *mut BACNET_DATE,
        btime: *mut BACNET_TIME,
        utc_offset_minutes: *mut i16,
        dst_active: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn datetime_init();
}
pub const BACnet_Recipient_Tag_BACNET_RECIPIENT_TAG_DEVICE: BACnet_Recipient_Tag = 0;
pub const BACnet_Recipient_Tag_BACNET_RECIPIENT_TAG_ADDRESS: BACnet_Recipient_Tag = 1;
pub const BACnet_Recipient_Tag_BACNET_RECIPIENT_TAG_MAX: BACnet_Recipient_Tag = 2;
pub type BACnet_Recipient_Tag = ::std::os::raw::c_uint;
pub use self::BACnet_Recipient_Tag as BACNET_RECIPIENT_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Recipient {
    pub tag: u8,
    pub type_: BACnet_Recipient__bindgen_ty_1,
}
#[doc = "  BACnetRecipient ::= CHOICE {\n      device [0] BACnetObjectIdentifier,\n      address [1] BACnetAddress\n  }"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Recipient__bindgen_ty_1 {
    pub device: BACNET_OBJECT_ID,
    pub address: BACNET_ADDRESS,
}
#[test]
fn bindgen_test_layout_BACnet_Recipient__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Recipient__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Recipient__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(BACnet_Recipient__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Recipient__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_Recipient__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient__bindgen_ty_1),
            "::",
            stringify!(address)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Recipient() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Recipient> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Recipient>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_Recipient))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Recipient>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_Recipient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient),
            "::",
            stringify!(type_)
        )
    );
}
pub type BACNET_RECIPIENT = BACnet_Recipient;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Destination {
    #[doc = "  BACnetDestination ::= SEQUENCE {\n      valid-days                      BACnetDaysOfWeek,\n      from-time                       Time,\n      to-time                         Time,\n      recipient                       BACnetRecipient,\n      process-identifier              Unsigned32,\n      issue-confirmed-notifications   BOOLEAN,\n      transitions                     BACnetEventTransitionBits\n  }"]
    pub ValidDays: BACNET_BIT_STRING,
    pub FromTime: BACNET_TIME,
    pub ToTime: BACNET_TIME,
    pub Recipient: BACNET_RECIPIENT,
    pub ProcessIdentifier: u32,
    pub ConfirmedNotify: bool,
    pub Transitions: BACNET_BIT_STRING,
}
#[test]
fn bindgen_test_layout_BACnet_Destination() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Destination> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Destination>(),
        72usize,
        concat!("Size of: ", stringify!(BACnet_Destination))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Destination>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_Destination))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ValidDays) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(ValidDays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FromTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(FromTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ToTime) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(ToTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Recipient) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(Recipient)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessIdentifier) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(ProcessIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConfirmedNotify) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(ConfirmedNotify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Transitions) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Destination),
            "::",
            stringify!(Transitions)
        )
    );
}
pub type BACNET_DESTINATION = BACnet_Destination;
extern "C" {
    pub fn bacnet_destination_encode(
        apdu: *mut u8,
        destination: *mut BACNET_DESTINATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_destination_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        destination: *mut BACNET_DESTINATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_destination_decode(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_int,
        destination: *mut BACNET_DESTINATION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_destination_default_init(destination: *mut BACNET_DESTINATION);
}
extern "C" {
    pub fn bacnet_destination_default(destination: *mut BACNET_DESTINATION) -> bool;
}
extern "C" {
    pub fn bacnet_destination_same(
        dest1: *mut BACNET_DESTINATION,
        dest2: *mut BACNET_DESTINATION,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_destination_copy(dest: *mut BACNET_DESTINATION, src: *mut BACNET_DESTINATION);
}
extern "C" {
    pub fn bacnet_recipient_copy(dest: *mut BACNET_RECIPIENT, src: *mut BACNET_RECIPIENT);
}
extern "C" {
    pub fn bacnet_recipient_same(r1: *mut BACNET_RECIPIENT, r2: *mut BACNET_RECIPIENT) -> bool;
}
extern "C" {
    pub fn bacnet_recipient_device_wildcard(recipient: *mut BACNET_RECIPIENT) -> bool;
}
extern "C" {
    pub fn bacnet_recipient_device_valid(recipient: *mut BACNET_RECIPIENT) -> bool;
}
extern "C" {
    pub fn bacnet_destination_to_ascii(
        bacdest: *const BACNET_DESTINATION,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_destination_from_ascii(
        bacdest: *mut BACNET_DESTINATION,
        buf: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnetLightingCommand {
    pub operation: BACNET_LIGHTING_OPERATION,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub target_level: f32,
    pub ramp_rate: f32,
    pub step_increment: f32,
    pub fade_time: u32,
    pub priority: u8,
}
#[test]
fn bindgen_test_layout_BACnetLightingCommand() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetLightingCommand> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetLightingCommand>(),
        28usize,
        concat!("Size of: ", stringify!(BACnetLightingCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetLightingCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnetLightingCommand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetLightingCommand),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_level) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetLightingCommand),
            "::",
            stringify!(target_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ramp_rate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetLightingCommand),
            "::",
            stringify!(ramp_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_increment) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetLightingCommand),
            "::",
            stringify!(step_increment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fade_time) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetLightingCommand),
            "::",
            stringify!(fade_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetLightingCommand),
            "::",
            stringify!(priority)
        )
    );
}
impl BACnetLightingCommand {
    #[inline]
    pub fn use_target_level(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_target_level(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_ramp_rate(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_ramp_rate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_step_increment(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_step_increment(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_fade_time(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_fade_time(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_priority(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_priority(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_target_level: bool,
        use_ramp_rate: bool,
        use_step_increment: bool,
        use_fade_time: bool,
        use_priority: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_target_level: u8 = unsafe { ::std::mem::transmute(use_target_level) };
            use_target_level as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let use_ramp_rate: u8 = unsafe { ::std::mem::transmute(use_ramp_rate) };
            use_ramp_rate as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let use_step_increment: u8 = unsafe { ::std::mem::transmute(use_step_increment) };
            use_step_increment as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let use_fade_time: u8 = unsafe { ::std::mem::transmute(use_fade_time) };
            use_fade_time as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let use_priority: u8 = unsafe { ::std::mem::transmute(use_priority) };
            use_priority as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type BACNET_LIGHTING_COMMAND = BACnetLightingCommand;
#[doc = " BACnetxyColor::= SEQUENCE {\n      x-coordinate REAL, --(0.0 to 1.0)\n      y-coordinate REAL --(0.0 to 1.0)\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnetXYColor {
    pub x_coordinate: f32,
    pub y_coordinate: f32,
}
#[test]
fn bindgen_test_layout_BACnetXYColor() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetXYColor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetXYColor>(),
        8usize,
        concat!("Size of: ", stringify!(BACnetXYColor))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetXYColor>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnetXYColor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_coordinate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetXYColor),
            "::",
            stringify!(x_coordinate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_coordinate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetXYColor),
            "::",
            stringify!(y_coordinate)
        )
    );
}
#[doc = " BACnetxyColor::= SEQUENCE {\n      x-coordinate REAL, --(0.0 to 1.0)\n      y-coordinate REAL --(0.0 to 1.0)\n }"]
pub type BACNET_XY_COLOR = BACnetXYColor;
#[doc = "  BACnetColorCommand ::= SEQUENCE {\n      operation      [0] BACnetColorOperation,\n      target-color   [1] BACnetxyColor OPTIONAL,\n      target-color-temperature [2] Unsigned OPTIONAL,\n      fade-time      [3] Unsigned (100.. 86400000) OPTIONAL,\n      ramp-rate      [4] Unsigned (1..30000) OPTIONAL,\n      step-increment [5] Unsigned (1..30000) OPTIONAL\n  }"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnetColorCommand {
    pub operation: BACNET_COLOR_OPERATION,
    pub target: BACnetColorCommand__bindgen_ty_1,
    pub transit: BACnetColorCommand__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnetColorCommand__bindgen_ty_1 {
    pub color: BACNET_XY_COLOR,
    pub color_temperature: u16,
}
#[test]
fn bindgen_test_layout_BACnetColorCommand__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetColorCommand__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetColorCommand__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(BACnetColorCommand__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetColorCommand__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnetColorCommand__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand__bindgen_ty_1),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_temperature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand__bindgen_ty_1),
            "::",
            stringify!(color_temperature)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnetColorCommand__bindgen_ty_2 {
    pub fade_time: u32,
    pub ramp_rate: u16,
    pub step_increment: u16,
}
#[test]
fn bindgen_test_layout_BACnetColorCommand__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetColorCommand__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetColorCommand__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(BACnetColorCommand__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetColorCommand__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnetColorCommand__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fade_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand__bindgen_ty_2),
            "::",
            stringify!(fade_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ramp_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand__bindgen_ty_2),
            "::",
            stringify!(ramp_rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step_increment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand__bindgen_ty_2),
            "::",
            stringify!(step_increment)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnetColorCommand() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetColorCommand> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetColorCommand>(),
        16usize,
        concat!("Size of: ", stringify!(BACnetColorCommand))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetColorCommand>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnetColorCommand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transit) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetColorCommand),
            "::",
            stringify!(transit)
        )
    );
}
#[doc = "  BACnetColorCommand ::= SEQUENCE {\n      operation      [0] BACnetColorOperation,\n      target-color   [1] BACnetxyColor OPTIONAL,\n      target-color-temperature [2] Unsigned OPTIONAL,\n      fade-time      [3] Unsigned (100.. 86400000) OPTIONAL,\n      ramp-rate      [4] Unsigned (1..30000) OPTIONAL,\n      step-increment [5] Unsigned (1..30000) OPTIONAL\n  }"]
pub type BACNET_COLOR_COMMAND = BACnetColorCommand;
extern "C" {
    pub fn lighting_command_encode(
        apdu: *mut u8,
        data: *mut BACNET_LIGHTING_COMMAND,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lighting_command_encode_context(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_LIGHTING_COMMAND,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lighting_command_decode(
        apdu: *mut u8,
        apdu_max_len: ::std::os::raw::c_uint,
        data: *mut BACNET_LIGHTING_COMMAND,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lighting_command_copy(
        dst: *mut BACNET_LIGHTING_COMMAND,
        src: *mut BACNET_LIGHTING_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn lighting_command_same(
        dst: *mut BACNET_LIGHTING_COMMAND,
        src: *mut BACNET_LIGHTING_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn xy_color_encode(apdu: *mut u8, value: *mut BACNET_XY_COLOR) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xy_color_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_XY_COLOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xy_color_decode(
        apdu: *mut u8,
        apdu_size: u32,
        value: *mut BACNET_XY_COLOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xy_color_context_decode(
        apdu: *mut u8,
        apdu_size: u32,
        tag_number: u8,
        value: *mut BACNET_XY_COLOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xy_color_copy(
        dst: *mut BACNET_XY_COLOR,
        src: *mut BACNET_XY_COLOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn xy_color_same(value1: *mut BACNET_XY_COLOR, value2: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn color_command_encode(
        apdu: *mut u8,
        address: *mut BACNET_COLOR_COMMAND,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn color_command_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        address: *mut BACNET_COLOR_COMMAND,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn color_command_decode(
        apdu: *mut u8,
        apdu_len: u16,
        error_code: *mut BACNET_ERROR_CODE,
        address: *mut BACNET_COLOR_COMMAND,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn color_command_copy(
        dst: *mut BACNET_COLOR_COMMAND,
        src: *mut BACNET_COLOR_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn color_command_same(
        dst: *mut BACNET_COLOR_COMMAND,
        src: *mut BACNET_COLOR_COMMAND,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnetDeviceObjectPropertyReference {
    pub arrayIndex: BACNET_UNSIGNED_INTEGER,
    pub objectIdentifier: BACNET_OBJECT_ID,
    pub propertyIdentifier: BACNET_PROPERTY_ID,
    pub deviceIdentifier: BACNET_OBJECT_ID,
}
#[test]
fn bindgen_test_layout_BACnetDeviceObjectPropertyReference() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetDeviceObjectPropertyReference> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetDeviceObjectPropertyReference>(),
        32usize,
        concat!("Size of: ", stringify!(BACnetDeviceObjectPropertyReference))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetDeviceObjectPropertyReference>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnetDeviceObjectPropertyReference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arrayIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetDeviceObjectPropertyReference),
            "::",
            stringify!(arrayIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectIdentifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetDeviceObjectPropertyReference),
            "::",
            stringify!(objectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propertyIdentifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetDeviceObjectPropertyReference),
            "::",
            stringify!(propertyIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceIdentifier) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetDeviceObjectPropertyReference),
            "::",
            stringify!(deviceIdentifier)
        )
    );
}
pub type BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE = BACnetDeviceObjectPropertyReference;
#[doc = " BACnetDeviceObjectReference structure.\n If the optional deviceIdentifier is not provided, then this refers\n to an object inside this Device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnetDeviceObjectReference {
    #[doc = "< Optional, for external device."]
    pub deviceIdentifier: BACNET_OBJECT_ID,
    pub objectIdentifier: BACNET_OBJECT_ID,
}
#[test]
fn bindgen_test_layout_BACnetDeviceObjectReference() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetDeviceObjectReference> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetDeviceObjectReference>(),
        16usize,
        concat!("Size of: ", stringify!(BACnetDeviceObjectReference))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetDeviceObjectReference>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnetDeviceObjectReference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deviceIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetDeviceObjectReference),
            "::",
            stringify!(deviceIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectIdentifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetDeviceObjectReference),
            "::",
            stringify!(objectIdentifier)
        )
    );
}
#[doc = " BACnetDeviceObjectReference structure.\n If the optional deviceIdentifier is not provided, then this refers\n to an object inside this Device."]
pub type BACNET_DEVICE_OBJECT_REFERENCE = BACnetDeviceObjectReference;
#[doc = "  BACnetObjectPropertyReference ::= SEQUENCE {\n      object-identifier [0] BACnetObjectIdentifier,\n      property-identifier [1] BACnetPropertyIdentifier,\n      property-array-index [2] Unsigned OPTIONAL\n      -- used only with array datatype\n      -- if omitted with an array the entire array is referenced\n }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Object_Property_Reference {
    pub object_identifier: BACNET_OBJECT_ID,
    pub property_identifier: BACNET_PROPERTY_ID,
    pub property_array_index: BACNET_ARRAY_INDEX,
}
#[test]
fn bindgen_test_layout_BACnet_Object_Property_Reference() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Object_Property_Reference> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Object_Property_Reference>(),
        16usize,
        concat!("Size of: ", stringify!(BACnet_Object_Property_Reference))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Object_Property_Reference>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Object_Property_Reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Reference),
            "::",
            stringify!(object_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_identifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Reference),
            "::",
            stringify!(property_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).property_array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Reference),
            "::",
            stringify!(property_array_index)
        )
    );
}
#[doc = "  BACnetObjectPropertyReference ::= SEQUENCE {\n      object-identifier [0] BACnetObjectIdentifier,\n      property-identifier [1] BACnetPropertyIdentifier,\n      property-array-index [2] Unsigned OPTIONAL\n      -- used only with array datatype\n      -- if omitted with an array the entire array is referenced\n }"]
pub type BACNET_OBJECT_PROPERTY_REFERENCE = BACnet_Object_Property_Reference;
extern "C" {
    pub fn bacapp_encode_device_obj_property_ref(
        apdu: *mut u8,
        value: *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_device_obj_property_ref(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_device_obj_property_ref(
        apdu: *mut u8,
        value: *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_device_obj_property_ref(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_device_obj_ref(
        apdu: *mut u8,
        value: *mut BACNET_DEVICE_OBJECT_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_device_obj_ref(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_DEVICE_OBJECT_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_device_obj_ref(
        apdu: *mut u8,
        value: *mut BACNET_DEVICE_OBJECT_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_device_obj_ref(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_DEVICE_OBJECT_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_obj_property_ref(
        apdu: *mut u8,
        value: *mut BACNET_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_obj_property_ref(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_obj_property_ref(
        apdu: *mut u8,
        apdu_len_max: u16,
        value: *mut BACNET_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_obj_property_ref(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_number: u8,
        value: *mut BACNET_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bacnet_npdu_data_t {
    pub protocol_version: u8,
    pub data_expecting_reply: bool,
    pub network_layer_message: bool,
    pub priority: BACNET_MESSAGE_PRIORITY,
    pub network_message_type: BACNET_NETWORK_MESSAGE_TYPE,
    pub vendor_id: u16,
    pub hop_count: u8,
}
#[test]
fn bindgen_test_layout_bacnet_npdu_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<bacnet_npdu_data_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bacnet_npdu_data_t>(),
        16usize,
        concat!("Size of: ", stringify!(bacnet_npdu_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bacnet_npdu_data_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bacnet_npdu_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(protocol_version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_expecting_reply) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(data_expecting_reply)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_layer_message) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(network_layer_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).network_message_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(network_message_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hop_count) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_npdu_data_t),
            "::",
            stringify!(hop_count)
        )
    );
}
pub type BACNET_NPDU_DATA = bacnet_npdu_data_t;
#[doc = " Port Info structure used by Routers for their routing table."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct router_port_t {
    #[doc = "< The DNET number that identifies this port."]
    pub dnet: u16,
    #[doc = "< Either 0 or some ill-defined, meaningless value."]
    pub id: u8,
    #[doc = "< Info like 'modem dialing string'"]
    pub info: [u8; 2usize],
    #[doc = "< Length of info[]."]
    pub info_len: u8,
    #[doc = "< Point to next in linked list"]
    pub next: *mut router_port_t,
}
#[test]
fn bindgen_test_layout_router_port_t() {
    const UNINIT: ::std::mem::MaybeUninit<router_port_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<router_port_t>(),
        16usize,
        concat!("Size of: ", stringify!(router_port_t))
    );
    assert_eq!(
        ::std::mem::align_of::<router_port_t>(),
        8usize,
        concat!("Alignment of ", stringify!(router_port_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dnet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(router_port_t),
            "::",
            stringify!(dnet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(router_port_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(router_port_t),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info_len) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(router_port_t),
            "::",
            stringify!(info_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(router_port_t),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Port Info structure used by Routers for their routing table."]
pub type BACNET_ROUTER_PORT = router_port_t;
extern "C" {
    pub fn npdu_encode_max_seg_max_apdu(
        max_segs: ::std::os::raw::c_int,
        max_apdu: ::std::os::raw::c_int,
    ) -> u8;
}
extern "C" {
    pub fn npdu_encode_pdu(
        npdu: *mut u8,
        dest: *mut BACNET_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn npdu_encode_npdu_data(
        npdu: *mut BACNET_NPDU_DATA,
        data_expecting_reply: bool,
        priority: BACNET_MESSAGE_PRIORITY,
    );
}
extern "C" {
    pub fn npdu_encode_npdu_network(
        npdu_data: *mut BACNET_NPDU_DATA,
        network_message_type: BACNET_NETWORK_MESSAGE_TYPE,
        data_expecting_reply: bool,
        priority: BACNET_MESSAGE_PRIORITY,
    );
}
extern "C" {
    pub fn npdu_copy_data(dest: *mut BACNET_NPDU_DATA, src: *mut BACNET_NPDU_DATA);
}
extern "C" {
    pub fn npdu_decode(
        npdu: *mut u8,
        dest: *mut BACNET_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_npdu_decode(
        npdu: *mut u8,
        pdu_len: u16,
        dest: *mut BACNET_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn npdu_confirmed_service(pdu: *mut u8, pdu_len: u16) -> bool;
}
#[doc = " BACnet IPv4 Address\n\n Data link layer addressing between B/IPv4 nodes consists of a 32-bit\n IPv4 address followed by a two-octet UDP port number (both of which\n shall be transmitted with the most significant octet first).\n This address shall be referred to as a B/IPv4 address.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP_Address {
    pub address: [u8; 4usize],
    pub port: u16,
}
#[test]
fn bindgen_test_layout_BACnet_IP_Address() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP_Address> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP_Address>(),
        6usize,
        concat!("Size of: ", stringify!(BACnet_IP_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP_Address>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_IP_Address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Address),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Address),
            "::",
            stringify!(port)
        )
    );
}
#[doc = " BACnet IPv4 Address\n\n Data link layer addressing between B/IPv4 nodes consists of a 32-bit\n IPv4 address followed by a two-octet UDP port number (both of which\n shall be transmitted with the most significant octet first).\n This address shall be referred to as a B/IPv4 address.\n @{"]
pub type BACNET_IP_ADDRESS = BACnet_IP_Address;
#[doc = " BACnet IPv4 Broadcast Distribution Mask\n\n The Broadcast Distribution Mask is a 4-octet field that\n indicates how broadcast messages are to be distributed on\n the IP subnet served by the BBMD.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP_Broadcast_Distribution_Mask {
    pub address: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_BACnet_IP_Broadcast_Distribution_Mask() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP_Broadcast_Distribution_Mask> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP_Broadcast_Distribution_Mask>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Mask)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP_Broadcast_Distribution_Mask>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_IP_Broadcast_Distribution_Mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Mask),
            "::",
            stringify!(address)
        )
    );
}
#[doc = " BACnet IPv4 Broadcast Distribution Mask\n\n The Broadcast Distribution Mask is a 4-octet field that\n indicates how broadcast messages are to be distributed on\n the IP subnet served by the BBMD.\n @{"]
pub type BACNET_IP_BROADCAST_DISTRIBUTION_MASK = BACnet_IP_Broadcast_Distribution_Mask;
#[doc = " BACnet/IP Broadcast Distribution Table (BDT)\n\n The BDT consists of one entry for the address of the BBMD\n for the local IP subnet and an entry for the BBMD on each\n remote IP subnet to which broadcasts are to be forwarded.\n Each entry consists of the 6-octet B/IP address with which\n the BBMD is accessed and a 4-octet broadcast distribution mask.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP_Broadcast_Distribution_Table_Entry {
    pub valid: bool,
    pub dest_address: BACNET_IP_ADDRESS,
    pub broadcast_mask: BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    pub next: *mut BACnet_IP_Broadcast_Distribution_Table_Entry,
}
#[test]
fn bindgen_test_layout_BACnet_IP_Broadcast_Distribution_Table_Entry() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP_Broadcast_Distribution_Table_Entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP_Broadcast_Distribution_Table_Entry>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Table_Entry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP_Broadcast_Distribution_Table_Entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_IP_Broadcast_Distribution_Table_Entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest_address) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(dest_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).broadcast_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(broadcast_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " BACnet/IP Broadcast Distribution Table (BDT)\n\n The BDT consists of one entry for the address of the BBMD\n for the local IP subnet and an entry for the BBMD on each\n remote IP subnet to which broadcasts are to be forwarded.\n Each entry consists of the 6-octet B/IP address with which\n the BBMD is accessed and a 4-octet broadcast distribution mask.\n @{"]
pub type BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY =
    BACnet_IP_Broadcast_Distribution_Table_Entry;
#[doc = " Foreign Device Table (FDT)\n\n Each device that registers as a foreign device shall be placed\n in an entry in the BBMD's Foreign Device Table (FDT). Each\n entry shall consist of the 6-octet B/IP address of the registrant;\n the 2-octet Time-to-Live value supplied at the time of\n registration; and a 2-octet value representing the number of\n seconds remaining before the BBMD will purge the registrant's FDT\n entry if no re-registration occurs. This value will be initialized\n to the 2-octet Time-to-Live value supplied at the time of\n registration.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP_Foreign_Device_Table_Entry {
    pub valid: bool,
    pub dest_address: BACNET_IP_ADDRESS,
    pub ttl_seconds: u16,
    pub ttl_seconds_remaining: u16,
    pub next: *mut BACnet_IP_Foreign_Device_Table_Entry,
}
#[test]
fn bindgen_test_layout_BACnet_IP_Foreign_Device_Table_Entry() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP_Foreign_Device_Table_Entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP_Foreign_Device_Table_Entry>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP_Foreign_Device_Table_Entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest_address) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry),
            "::",
            stringify!(dest_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl_seconds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry),
            "::",
            stringify!(ttl_seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl_seconds_remaining) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry),
            "::",
            stringify!(ttl_seconds_remaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP_Foreign_Device_Table_Entry),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Foreign Device Table (FDT)\n\n Each device that registers as a foreign device shall be placed\n in an entry in the BBMD's Foreign Device Table (FDT). Each\n entry shall consist of the 6-octet B/IP address of the registrant;\n the 2-octet Time-to-Live value supplied at the time of\n registration; and a 2-octet value representing the number of\n seconds remaining before the BBMD will purge the registrant's FDT\n entry if no re-registration occurs. This value will be initialized\n to the 2-octet Time-to-Live value supplied at the time of\n registration.\n @{"]
pub type BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY = BACnet_IP_Foreign_Device_Table_Entry;
extern "C" {
    pub fn bvlc_encode_address(
        pdu: *mut u8,
        pdu_size: u16,
        ip_address: *const BACNET_IP_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_address(
        pdu: *mut u8,
        pdu_len: u16,
        ip_address: *mut BACNET_IP_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_address_copy(dst: *mut BACNET_IP_ADDRESS, src: *const BACNET_IP_ADDRESS) -> bool;
}
extern "C" {
    pub fn bvlc_address_different(
        dst: *const BACNET_IP_ADDRESS,
        src: *const BACNET_IP_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_address_from_ascii(
        dst: *mut BACNET_IP_ADDRESS,
        addrstr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_address_port_from_ascii(
        dst: *mut BACNET_IP_ADDRESS,
        addrstr: *const ::std::os::raw::c_char,
        portstr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_address_from_network(dst: *mut BACNET_IP_ADDRESS, addr: u32);
}
extern "C" {
    pub fn bvlc_address_set(
        addr: *mut BACNET_IP_ADDRESS,
        addr0: u8,
        addr1: u8,
        addr2: u8,
        addr3: u8,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_address_get(
        addr: *mut BACNET_IP_ADDRESS,
        addr0: *mut u8,
        addr1: *mut u8,
        addr2: *mut u8,
        addr3: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_ip_address_to_bacnet_local(
        addr: *mut BACNET_ADDRESS,
        ipaddr: *mut BACNET_IP_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_ip_address_from_bacnet_local(
        ipaddr: *mut BACNET_IP_ADDRESS,
        addr: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_ip_address_to_bacnet_remote(
        addr: *mut BACNET_ADDRESS,
        dnet: u16,
        ipaddr: *mut BACNET_IP_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_ip_address_from_bacnet_remote(
        ipaddr: *mut BACNET_IP_ADDRESS,
        dnet: *mut u16,
        addr: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_encode_broadcast_distribution_mask(
        pdu: *mut u8,
        pdu_size: u16,
        bd_mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_broadcast_distribution_mask(
        pdu: *mut u8,
        pdu_len: u16,
        bd_mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_broadcast_distribution_table_entry(
        pdu: *mut u8,
        pdu_size: u16,
        bdt_entry: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_broadcast_distribution_table_entry(
        pdu: *mut u8,
        pdu_len: u16,
        bdt_entry: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_link_array(
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
        bdt_array_size: usize,
    );
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_count(
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> u16;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_valid_count(
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> u16;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_valid_clear(
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    );
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_entry_different(
        dst: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
        src: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_entry_copy(
        dst: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
        src: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_mask_different(
        dst: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
        src: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_mask_copy(
        dst: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
        src: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_entry_append(
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
        bdt_entry: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_entry_set(
        bdt_entry: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
        addr: *mut BACNET_IP_ADDRESS,
        mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_entry_forward_address(
        addr: *mut BACNET_IP_ADDRESS,
        bdt_entry: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_address_mask(
        dst: *mut BACNET_IP_ADDRESS,
        src: *const BACNET_IP_ADDRESS,
        mask: *const BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_mask_from_host(
        mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
        broadcast_mask: u32,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_mask_to_host(
        broadcast_mask: *mut u32,
        mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_mask_set(
        mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
        addr0: u8,
        addr1: u8,
        addr2: u8,
        addr3: u8,
    );
}
extern "C" {
    pub fn bvlc_broadcast_distribution_mask_get(
        mask: *mut BACNET_IP_BROADCAST_DISTRIBUTION_MASK,
        addr0: *mut u8,
        addr1: *mut u8,
        addr2: *mut u8,
        addr3: *mut u8,
    );
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_decode(
        apdu: *mut u8,
        apdu_len: u16,
        error_code: *mut BACNET_ERROR_CODE,
        bdt_head: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_broadcast_distribution_table_encode(
        apdu: *mut u8,
        apdu_size: u16,
        bdt_head: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_write_broadcast_distribution_table(
        pdu: *mut u8,
        pdu_size: u16,
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_write_broadcast_distribution_table(
        pdu: *mut u8,
        pdu_len: u16,
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_read_broadcast_distribution_table(
        pdu: *mut u8,
        pdu_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_read_broadcast_distribution_table_ack(
        pdu: *mut u8,
        pdu_size: u16,
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_read_broadcast_distribution_table_ack(
        pdu: *mut u8,
        pdu_len: u16,
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_header(
        pdu: *mut u8,
        pdu_size: u16,
        message_type: u8,
        length: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_header(
        pdu: *mut u8,
        pdu_len: u16,
        message_type: *mut u8,
        length: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_foreign_device_table_maintenance_timer(
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
        seconds: u16,
    );
}
extern "C" {
    pub fn bvlc_foreign_device_table_valid_count(
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> u16;
}
extern "C" {
    pub fn bvlc_foreign_device_table_count(
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> u16;
}
extern "C" {
    pub fn bvlc_foreign_device_table_link_array(
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
        array_size: usize,
    );
}
extern "C" {
    pub fn bvlc_foreign_device_table_entry_different(
        dst: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
        src: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_foreign_device_table_entry_copy(
        dst: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
        src: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_foreign_device_table_entry_delete(
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
        ip_address: *mut BACNET_IP_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_foreign_device_table_entry_add(
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
        ip_address: *mut BACNET_IP_ADDRESS,
        ttl_seconds: u16,
    ) -> bool;
}
extern "C" {
    pub fn bvlc_encode_foreign_device_table_entry(
        pdu: *mut u8,
        pdu_size: u16,
        fdt_entry: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_foreign_device_table_entry(
        pdu: *mut u8,
        pdu_len: u16,
        fdt_entry: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_foreign_device_table_encode(
        apdu: *mut u8,
        apdu_size: u16,
        fdt_head: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_read_foreign_device_table(
        pdu: *mut u8,
        pdu_size: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_read_foreign_device_table_ack(
        pdu: *mut u8,
        pdu_size: u16,
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_read_foreign_device_table_ack(
        pdu: *mut u8,
        pdu_len: u16,
        fdt_list: *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_result(
        pdu: *mut u8,
        pdu_size: u16,
        result_code: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_result(
        pdu: *mut u8,
        pdu_len: u16,
        result_code: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_original_unicast(
        pdu: *mut u8,
        pdu_size: u16,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_original_unicast(
        pdu: *mut u8,
        pdu_len: u16,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_original_broadcast(
        pdu: *mut u8,
        pdu_size: u16,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_original_broadcast(
        pdu: *mut u8,
        pdu_len: u16,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_forwarded_npdu(
        pdu: *mut u8,
        pdu_size: u16,
        address: *mut BACNET_IP_ADDRESS,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_forwarded_npdu(
        pdu: *mut u8,
        pdu_len: u16,
        address: *mut BACNET_IP_ADDRESS,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_register_foreign_device(
        pdu: *mut u8,
        pdu_size: u16,
        ttl_seconds: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_register_foreign_device(
        pdu: *mut u8,
        pdu_len: u16,
        ttl_seconds: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_delete_foreign_device(
        pdu: *mut u8,
        pdu_size: u16,
        ip_address: *mut BACNET_IP_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_delete_foreign_device(
        pdu: *mut u8,
        pdu_len: u16,
        ip_address: *mut BACNET_IP_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_secure_bvll(
        pdu: *mut u8,
        pdu_size: u16,
        sbuf: *mut u8,
        sbuf_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_secure_bvll(
        pdu: *mut u8,
        pdu_len: u16,
        sbuf: *mut u8,
        sbuf_size: u16,
        sbuf_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_encode_distribute_broadcast_to_network(
        pdu: *mut u8,
        pdu_size: u16,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_decode_distribute_broadcast_to_network(
        pdu: *mut u8,
        pdu_len: u16,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_result_code_name(result_code: u16) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bvlc_foreign_device_bbmd_host_address_encode(
        apdu: *mut u8,
        apdu_size: u16,
        ip_address: *mut BACNET_IP_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_foreign_device_bbmd_host_address_decode(
        apdu: *mut u8,
        apdu_len: u16,
        error_code: *mut BACNET_ERROR_CODE,
        ip_address: *mut BACNET_IP_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
#[doc = "  BACnetHostNPort ::= SEQUENCE {\n      host [0] BACnetHostAddress,\n          BACnetHostAddress ::= CHOICE {\n              none [0] NULL,\n              ip-address [1] OCTET STRING,\n              name [2] CharacterString\n          }\n      port [1] Unsigned16\n  }"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnetHostNPort {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub host: BACnetHostNPort_BACnetHostAddress,
    pub port: u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnetHostNPort_BACnetHostAddress {
    pub ip_address: BACNET_OCTET_STRING,
    pub name: BACNET_CHARACTER_STRING,
}
#[test]
fn bindgen_test_layout_BACnetHostNPort_BACnetHostAddress() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetHostNPort_BACnetHostAddress> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetHostNPort_BACnetHostAddress>(),
        1480usize,
        concat!("Size of: ", stringify!(BACnetHostNPort_BACnetHostAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetHostNPort_BACnetHostAddress>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnetHostNPort_BACnetHostAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ip_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetHostNPort_BACnetHostAddress),
            "::",
            stringify!(ip_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetHostNPort_BACnetHostAddress),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnetHostNPort() {
    const UNINIT: ::std::mem::MaybeUninit<BACnetHostNPort> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnetHostNPort>(),
        1496usize,
        concat!("Size of: ", stringify!(BACnetHostNPort))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnetHostNPort>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnetHostNPort))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetHostNPort),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnetHostNPort),
            "::",
            stringify!(port)
        )
    );
}
impl BACnetHostNPort {
    #[inline]
    pub fn host_ip_address(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_host_ip_address(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn host_name(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_host_name(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        host_ip_address: bool,
        host_name: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let host_ip_address: u8 = unsafe { ::std::mem::transmute(host_ip_address) };
            host_ip_address as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let host_name: u8 = unsafe { ::std::mem::transmute(host_name) };
            host_name as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "  BACnetHostNPort ::= SEQUENCE {\n      host [0] BACnetHostAddress,\n          BACnetHostAddress ::= CHOICE {\n              none [0] NULL,\n              ip-address [1] OCTET STRING,\n              name [2] CharacterString\n          }\n      port [1] Unsigned16\n  }"]
pub type BACNET_HOST_N_PORT = BACnetHostNPort;
extern "C" {
    pub fn host_n_port_encode(
        apdu: *mut u8,
        address: *mut BACNET_HOST_N_PORT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn host_n_port_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        address: *mut BACNET_HOST_N_PORT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn host_n_port_decode(
        apdu: *mut u8,
        apdu_len: u16,
        error_code: *mut BACNET_ERROR_CODE,
        address: *mut BACNET_HOST_N_PORT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn host_n_port_copy(dst: *mut BACNET_HOST_N_PORT, src: *mut BACNET_HOST_N_PORT) -> bool;
}
extern "C" {
    pub fn host_n_port_same(dst: *mut BACNET_HOST_N_PORT, src: *mut BACNET_HOST_N_PORT) -> bool;
}
extern "C" {
    pub fn decode_real_safe(
        apdu: *mut u8,
        len_value: u32,
        real_value: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_real(apdu: *mut u8, real_value: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_real(value: f32, apdu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_double(apdu: *mut u8, real_value: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_double_safe(
        apdu: *mut u8,
        len_value: u32,
        double_value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_double(value: f64, apdu: *mut u8) -> ::std::os::raw::c_int;
}
#[doc = " @brief Encode a BACnetARRAY property element; a function template\n @param object_instance [in] BACnet network port object instance number\n @param array_index [in] array index requested:\n    0 to N for individual array members\n @param apdu [out] Buffer in which the APDU contents are built, or NULL to\n return the length of buffer if it had been built\n @return The length of the apdu encoded or\n   BACNET_STATUS_ERROR for ERROR_CODE_INVALID_ARRAY_INDEX"]
pub type bacnet_array_property_element_encode_function = ::std::option::Option<
    unsafe extern "C" fn(
        object_instance: u32,
        array_index: BACNET_ARRAY_INDEX,
        apdu: *mut u8,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn encode_tag(
        apdu: *mut u8,
        tag_number: u8,
        context_specific: bool,
        len_value_type: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_opening_tag(apdu: *mut u8, tag_number: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_closing_tag(apdu: *mut u8, tag_number: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_tag_number(apdu: *mut u8, tag_number: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_tag_number_decode(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        tag_number: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_tag_number_and_value(
        apdu: *mut u8,
        tag_number: *mut u8,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_tag_number_and_value_decode(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        tag_number: *mut u8,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_is_opening_tag_number(apdu: *mut u8, tag_number: u8) -> bool;
}
extern "C" {
    pub fn decode_is_closing_tag_number(apdu: *mut u8, tag_number: u8) -> bool;
}
extern "C" {
    pub fn decode_is_context_tag(apdu: *mut u8, tag_number: u8) -> bool;
}
extern "C" {
    pub fn decode_is_context_tag_with_length(
        apdu: *mut u8,
        tag_number: u8,
        tag_length: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn decode_is_opening_tag(apdu: *mut u8) -> bool;
}
extern "C" {
    pub fn decode_is_closing_tag(apdu: *mut u8) -> bool;
}
extern "C" {
    pub fn encode_application_null(apdu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_null(apdu: *mut u8, tag_number: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_boolean(apdu: *mut u8, boolean_value: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_boolean(len_value: u32) -> bool;
}
extern "C" {
    pub fn encode_context_boolean(
        apdu: *mut u8,
        tag_number: u8,
        boolean_value: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_boolean(apdu: *mut u8) -> bool;
}
extern "C" {
    pub fn decode_context_boolean2(
        apdu: *mut u8,
        tag_number: u8,
        boolean_value: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_bitstring(
        apdu: *mut u8,
        len_value: u32,
        bit_string: *mut BACNET_BIT_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_bitstring(
        apdu: *mut u8,
        tag_number: u8,
        bit_string: *mut BACNET_BIT_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bitstring(
        apdu: *mut u8,
        bit_string: *mut BACNET_BIT_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_bitstring(
        apdu: *mut u8,
        bit_string: *mut BACNET_BIT_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_bitstring(
        apdu: *mut u8,
        tag_number: u8,
        bit_string: *mut BACNET_BIT_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_real(apdu: *mut u8, value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_real(apdu: *mut u8, tag_number: u8, value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_real(
        apdu: *mut u8,
        tag_number: u8,
        real_value: *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_double(apdu: *mut u8, value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_double(
        apdu: *mut u8,
        tag_number: u8,
        value: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_double(
        apdu: *mut u8,
        tag_number: u8,
        double_value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_object_id(
        apdu: *mut u8,
        object_type: *mut BACNET_OBJECT_TYPE,
        object_instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_object_id_safe(
        apdu: *mut u8,
        len_value: u32,
        object_type: *mut BACNET_OBJECT_TYPE,
        object_instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_object_id_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        len_value: u32,
        object_type: *mut BACNET_OBJECT_TYPE,
        instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_object_id_application_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        object_type: *mut BACNET_OBJECT_TYPE,
        object_instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_object_id_context_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_value: u8,
        object_type: *mut BACNET_OBJECT_TYPE,
        instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_object_id(
        apdu: *mut u8,
        tag_number: u8,
        object_type: *mut BACNET_OBJECT_TYPE,
        instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_object_id(
        apdu: *mut u8,
        object_type: BACNET_OBJECT_TYPE,
        instance: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_object_id(
        apdu: *mut u8,
        tag_number: u8,
        object_type: BACNET_OBJECT_TYPE,
        instance: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_object_id(
        apdu: *mut u8,
        object_type: BACNET_OBJECT_TYPE,
        instance: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_octet_string(
        apdu: *mut u8,
        octet_string: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_octet_string(
        apdu: *mut u8,
        octet_string: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_octet_string(
        apdu: *mut u8,
        tag_number: u8,
        octet_string: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_octet_string(
        apdu: *mut u8,
        len_value: u32,
        octet_string: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_octet_string(
        apdu: *mut u8,
        tag_number: u8,
        octet_string: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_octet_string_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        len_value: u32,
        value: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_octet_string_application_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        value: *mut BACNET_OCTET_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_character_string_safe(
        apdu: *mut u8,
        max_apdu: u32,
        encoding: u8,
        pString: *mut ::std::os::raw::c_char,
        length: u32,
    ) -> u32;
}
extern "C" {
    pub fn encode_bacnet_character_string(
        apdu: *mut u8,
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_character_string(
        apdu: *mut u8,
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_character_string(
        apdu: *mut u8,
        tag_number: u8,
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_character_string(
        apdu: *mut u8,
        len_value: u32,
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_character_string(
        apdu: *mut u8,
        tag_number: u8,
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_character_string_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        len_value: u32,
        char_string: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_character_string_context_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_value: u8,
        value: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_unsigned(
        apdu: *mut u8,
        value: BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_unsigned(
        apdu: *mut u8,
        tag_number: u8,
        value: BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_unsigned(
        apdu: *mut u8,
        value: BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_unsigned(
        apdu: *mut u8,
        len_value: u32,
        value: *mut BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_unsigned(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_unsigned_decode(
        apdu: *mut u8,
        apdu_max_len: u16,
        len_value: u32,
        value: *mut BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_unsigned_application_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        value: *mut BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_unsigned_context_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_number: u8,
        value: *mut BACNET_UNSIGNED_INTEGER,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_signed(apdu: *mut u8, value: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_signed(apdu: *mut u8, value: i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_signed(
        apdu: *mut u8,
        tag_number: u8,
        value: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_signed(apdu: *mut u8, len_value: u32, value: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_signed(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_signed_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        len_value: u32,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_signed_context_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_value: u8,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_signed_application_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_enumerated_decode(
        apdu: *mut u8,
        apdu_max_len: u16,
        len_value: u32,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_enumerated_context_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_value: u8,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_enumerated(
        apdu: *mut u8,
        len_value: u32,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_enumerated(
        apdu: *mut u8,
        tag_value: u8,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_enumerated(apdu: *mut u8, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_enumerated(apdu: *mut u8, value: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_enumerated(
        apdu: *mut u8,
        tag_number: u8,
        value: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_time(apdu: *mut u8, btime: *mut BACNET_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_time(apdu: *mut u8, btime: *mut BACNET_TIME)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_bacnet_time(apdu: *mut u8, btime: *mut BACNET_TIME) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_bacnet_time_safe(
        apdu: *mut u8,
        len_value: u32,
        btime: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_time(
        apdu: *mut u8,
        tag_number: u8,
        btime: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_application_time(apdu: *mut u8, btime: *mut BACNET_TIME)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_bacnet_time(
        apdu: *mut u8,
        tag_number: u8,
        btime: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        len_value: u32,
        value: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_context_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        tag_value: u8,
        value: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_application_decode(
        apdu: *mut u8,
        apdu_len_max: u16,
        value: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_date(apdu: *mut u8, bdate: *mut BACNET_DATE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_application_date(apdu: *mut u8, bdate: *mut BACNET_DATE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_date(
        apdu: *mut u8,
        tag_number: u8,
        bdate: *mut BACNET_DATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_date(apdu: *mut u8, bdate: *mut BACNET_DATE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_date_safe(
        apdu: *mut u8,
        len_value: u32,
        bdate: *mut BACNET_DATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_application_date(apdu: *mut u8, bdate: *mut BACNET_DATE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_date(
        apdu: *mut u8,
        tag_number: u8,
        bdate: *mut BACNET_DATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_max_segs_max_apdu(
        max_segs: ::std::os::raw::c_int,
        max_apdu: ::std::os::raw::c_int,
    ) -> u8;
}
extern "C" {
    pub fn decode_max_segs(octet: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_max_apdu(octet: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_simple_ack(
        apdu: *mut u8,
        invoke_id: u8,
        service_choice: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_bacnet_address(
        apdu: *mut u8,
        destination: *mut BACNET_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_bacnet_address(
        apdu: *mut u8,
        destination: *mut BACNET_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_context_bacnet_address(
        apdu: *mut u8,
        tag_number: u8,
        destination: *mut BACNET_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_context_bacnet_address(
        apdu: *mut u8,
        tag_number: u8,
        destination: *mut BACNET_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_array_encode(
        object_instance: u32,
        array_index: BACNET_ARRAY_INDEX,
        encoder: bacnet_array_property_element_encode_function,
        array_size: BACNET_UNSIGNED_INTEGER,
        apdu: *mut u8,
        max_apdu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const BACNET_TIMESTAMP_TAG_TIME_STAMP_TIME: BACNET_TIMESTAMP_TAG = 0;
pub const BACNET_TIMESTAMP_TAG_TIME_STAMP_SEQUENCE: BACNET_TIMESTAMP_TAG = 1;
pub const BACNET_TIMESTAMP_TAG_TIME_STAMP_DATETIME: BACNET_TIMESTAMP_TAG = 2;
pub type BACNET_TIMESTAMP_TAG = ::std::os::raw::c_uint;
pub type TYPE_BACNET_TIMESTAMP_TYPE = u8;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Timestamp {
    pub tag: TYPE_BACNET_TIMESTAMP_TYPE,
    pub value: BACnet_Timestamp__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Timestamp__bindgen_ty_1 {
    pub time: BACNET_TIME,
    pub sequenceNum: u16,
    pub dateTime: BACNET_DATE_TIME,
}
#[test]
fn bindgen_test_layout_BACnet_Timestamp__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Timestamp__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Timestamp__bindgen_ty_1>(),
        10usize,
        concat!("Size of: ", stringify!(BACnet_Timestamp__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Timestamp__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_Timestamp__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Timestamp__bindgen_ty_1),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequenceNum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Timestamp__bindgen_ty_1),
            "::",
            stringify!(sequenceNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dateTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Timestamp__bindgen_ty_1),
            "::",
            stringify!(dateTime)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Timestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Timestamp>(),
        12usize,
        concat!("Size of: ", stringify!(BACnet_Timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Timestamp>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_Timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Timestamp),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Timestamp),
            "::",
            stringify!(value)
        )
    );
}
pub type BACNET_TIMESTAMP = BACnet_Timestamp;
extern "C" {
    pub fn bacapp_timestamp_sequence_set(dest: *mut BACNET_TIMESTAMP, sequenceNum: u16);
}
extern "C" {
    pub fn bacapp_timestamp_time_set(dest: *mut BACNET_TIMESTAMP, btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn bacapp_timestamp_datetime_set(
        dest: *mut BACNET_TIMESTAMP,
        bdateTime: *mut BACNET_DATE_TIME,
    );
}
extern "C" {
    pub fn bacapp_timestamp_copy(dest: *mut BACNET_TIMESTAMP, src: *mut BACNET_TIMESTAMP);
}
extern "C" {
    pub fn bacapp_encode_timestamp(
        apdu: *mut u8,
        value: *mut BACNET_TIMESTAMP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_timestamp(
        apdu: *mut u8,
        value: *mut BACNET_TIMESTAMP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_timestamp(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_TIMESTAMP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_timestamp(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_TIMESTAMP,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_timestamp_init_ascii(
        timestamp: *mut BACNET_TIMESTAMP,
        ascii: *const ::std::os::raw::c_char,
    ) -> bool;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __fpclassifyl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    const UNINIT: ::std::mem::MaybeUninit<__float2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::std::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    const UNINIT: ::std::mem::MaybeUninit<__double2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::std::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sinval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cosval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: ::std::os::raw::c_int,
    pub name: *mut ::std::os::raw::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    const UNINIT: ::std::mem::MaybeUninit<exception> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
#[doc = " Smaller version of BACnet_Application_Data_Value used in BACnetTimeValue\n\n This must be a separate struct to avoid recursive structure.\n Keeping it small also helps keep the size of BACNET_APPLICATION_DATA_VALUE\n small. Besides, schedule can't contain complex types."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Primitive_Data_Value {
    pub tag: u8,
    pub type_: BACnet_Primitive_Data_Value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Primitive_Data_Value__bindgen_ty_1 {
    pub Boolean: bool,
    pub Unsigned_Int: BACNET_UNSIGNED_INTEGER,
    pub Signed_Int: i32,
    pub Real: f32,
    pub Double: f64,
    pub Enumerated: u32,
}
#[test]
fn bindgen_test_layout_BACnet_Primitive_Data_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Primitive_Data_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Primitive_Data_Value__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Primitive_Data_Value__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unsigned_Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Unsigned_Int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signed_Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Signed_Int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Real)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enumerated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Enumerated)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Primitive_Data_Value() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Primitive_Data_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Primitive_Data_Value>(),
        16usize,
        concat!("Size of: ", stringify!(BACnet_Primitive_Data_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Primitive_Data_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Primitive_Data_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Primitive_Data_Value),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " Smaller version of BACnet_Application_Data_Value used in BACnetTimeValue\n\n This must be a separate struct to avoid recursive structure.\n Keeping it small also helps keep the size of BACNET_APPLICATION_DATA_VALUE\n small. Besides, schedule can't contain complex types."]
pub type BACNET_PRIMITIVE_DATA_VALUE = BACnet_Primitive_Data_Value;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Time_Value {
    pub Time: BACNET_TIME,
    pub Value: BACNET_PRIMITIVE_DATA_VALUE,
}
#[test]
fn bindgen_test_layout_BACnet_Time_Value() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Time_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Time_Value>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_Time_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Time_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Time_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Time_Value),
            "::",
            stringify!(Time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Time_Value),
            "::",
            stringify!(Value)
        )
    );
}
pub type BACNET_TIME_VALUE = BACnet_Time_Value;
extern "C" {
    #[doc = " returns 0 if OK, -1 on error"]
    pub fn bacnet_application_to_primitive_data_value(
        dest: *mut BACNET_PRIMITIVE_DATA_VALUE,
        src: *const BACnet_Application_Data_Value,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " returns 0 if OK, -1 on error"]
    pub fn bacnet_primitive_to_application_data_value(
        dest: *mut BACnet_Application_Data_Value,
        src: *const BACNET_PRIMITIVE_DATA_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_value_encode(
        apdu: *mut u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_time_value(
        apdu: *mut u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_value_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_time_value(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_time_value(
        apdu: *mut u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_value_decode(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_time_value(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_time_value_context_decode(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        tag_number: u8,
        value: *mut BACNET_TIME_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode array of time-values wrapped in a context tag\n @param apdu\n @param max_apdu_len\n @param tag_number - number expected in the context tag; 0 used for DailySchedule\n @param time_values\n @param max_time_values - number of time values to encode\n @param[out] out_count - actual number of time values found\n @return used bytes, <0 if decoding failed"]
    pub fn bacnet_time_values_context_decode(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        tag_number: u8,
        time_values: *mut BACNET_TIME_VALUE,
        max_time_values: ::std::os::raw::c_uint,
        out_count: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode array of time-values wrapped in a context tag\n @param apdu - output buffer, NULL to just measure length\n @param max_apdu_len\n @param tag_number - number to use for the context tag; 0 used for DailySchedule\n @param time_values\n @param max_time_values - number of time values to encode\n @return used bytes, <=0 if encoding failed"]
    pub fn bacnet_time_values_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        time_values: *mut BACNET_TIME_VALUE,
        max_time_values: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Daily_Schedule {
    pub Time_Values: [BACNET_TIME_VALUE; 40usize],
    pub TV_Count: u16,
}
#[test]
fn bindgen_test_layout_BACnet_Daily_Schedule() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Daily_Schedule> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Daily_Schedule>(),
        968usize,
        concat!("Size of: ", stringify!(BACnet_Daily_Schedule))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Daily_Schedule>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Daily_Schedule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Time_Values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Daily_Schedule),
            "::",
            stringify!(Time_Values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TV_Count) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Daily_Schedule),
            "::",
            stringify!(TV_Count)
        )
    );
}
pub type BACNET_DAILY_SCHEDULE = BACnet_Daily_Schedule;
extern "C" {
    #[doc = " Decode DailySchedule (sequence of times and values)"]
    pub fn bacnet_dailyschedule_decode(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        day: *mut BACNET_DAILY_SCHEDULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode DailySchedule (sequence of times and values)"]
    pub fn bacnet_dailyschedule_encode(
        apdu: *mut u8,
        day: *mut BACNET_DAILY_SCHEDULE,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Weekly_Schedule {
    pub weeklySchedule: [BACNET_DAILY_SCHEDULE; 7usize],
    pub singleDay: bool,
}
#[test]
fn bindgen_test_layout_BACnet_Weekly_Schedule() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Weekly_Schedule> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Weekly_Schedule>(),
        6784usize,
        concat!("Size of: ", stringify!(BACnet_Weekly_Schedule))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Weekly_Schedule>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Weekly_Schedule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weeklySchedule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Weekly_Schedule),
            "::",
            stringify!(weeklySchedule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).singleDay) as usize - ptr as usize },
        6776usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Weekly_Schedule),
            "::",
            stringify!(singleDay)
        )
    );
}
pub type BACNET_WEEKLY_SCHEDULE = BACnet_Weekly_Schedule;
extern "C" {
    #[doc = " Decode WeeklySchedule"]
    pub fn bacnet_weeklyschedule_decode(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        value: *mut BACNET_WEEKLY_SCHEDULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode WeeklySchedule"]
    pub fn bacnet_weeklyschedule_encode(
        apdu: *mut u8,
        value: *mut BACNET_WEEKLY_SCHEDULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_weeklyschedule_context_encode(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_WEEKLY_SCHEDULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_weeklyschedule_context_decode(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        tag_number: u8,
        value: *mut BACNET_WEEKLY_SCHEDULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_weeklyschedule_same(
        value1: *mut BACNET_WEEKLY_SCHEDULE,
        value2: *mut BACNET_WEEKLY_SCHEDULE,
    ) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Application_Data_Value {
    pub context_specific: bool,
    pub context_tag: u8,
    pub tag: u8,
    pub type_: BACnet_Application_Data_Value__bindgen_ty_1,
    pub next: *mut BACnet_Application_Data_Value,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Application_Data_Value__bindgen_ty_1 {
    pub Boolean: bool,
    pub Unsigned_Int: BACNET_UNSIGNED_INTEGER,
    pub Signed_Int: i32,
    pub Real: f32,
    pub Double: f64,
    pub Octet_String: BACNET_OCTET_STRING,
    pub Character_String: BACNET_CHARACTER_STRING,
    pub Bit_String: BACNET_BIT_STRING,
    pub Enumerated: u32,
    pub Date: BACNET_DATE,
    pub Time: BACNET_TIME,
    pub Object_Id: BACNET_OBJECT_ID,
    pub Time_Stamp: BACNET_TIMESTAMP,
    pub Date_Time: BACNET_DATE_TIME,
    pub Lighting_Command: BACNET_LIGHTING_COMMAND,
    pub Color_Command: BACNET_COLOR_COMMAND,
    pub XY_Color: BACNET_XY_COLOR,
    pub Weekly_Schedule: BACNET_WEEKLY_SCHEDULE,
    pub Host_Address: BACNET_HOST_N_PORT,
    pub Device_Object_Property_Reference: BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    pub Device_Object_Reference: BACNET_DEVICE_OBJECT_REFERENCE,
    pub Object_Property_Reference: BACNET_OBJECT_PROPERTY_REFERENCE,
    pub Destination: BACNET_DESTINATION,
}
#[test]
fn bindgen_test_layout_BACnet_Application_Data_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Application_Data_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Application_Data_Value__bindgen_ty_1>(),
        6784usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Application_Data_Value__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unsigned_Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Unsigned_Int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signed_Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Signed_Int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Real)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Octet_String) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Octet_String)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Character_String) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Character_String)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bit_String) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Bit_String)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enumerated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Enumerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Object_Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Time_Stamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Time_Stamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Date_Time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Date_Time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Lighting_Command) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Lighting_Command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Color_Command) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Color_Command)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XY_Color) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(XY_Color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Weekly_Schedule) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Weekly_Schedule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Host_Address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Host_Address)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).Device_Object_Property_Reference) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Device_Object_Property_Reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Device_Object_Reference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Device_Object_Reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Property_Reference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Object_Property_Reference)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Destination) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value__bindgen_ty_1),
            "::",
            stringify!(Destination)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Application_Data_Value() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Application_Data_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Application_Data_Value>(),
        6800usize,
        concat!("Size of: ", stringify!(BACnet_Application_Data_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Application_Data_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Application_Data_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_specific) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value),
            "::",
            stringify!(context_specific)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).context_tag) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value),
            "::",
            stringify!(context_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        6792usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Application_Data_Value),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_APPLICATION_DATA_VALUE = BACnet_Application_Data_Value;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Access_Error {
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[test]
fn bindgen_test_layout_BACnet_Access_Error() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Access_Error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Access_Error>(),
        8usize,
        concat!("Size of: ", stringify!(BACnet_Access_Error))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Access_Error>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_Access_Error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Access_Error),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Access_Error),
            "::",
            stringify!(error_code)
        )
    );
}
pub type BACNET_ACCESS_ERROR = BACnet_Access_Error;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Property_Reference {
    pub propertyIdentifier: BACNET_PROPERTY_ID,
    pub propertyArrayIndex: BACNET_ARRAY_INDEX,
    pub value: *mut BACNET_APPLICATION_DATA_VALUE,
    pub error: BACNET_ACCESS_ERROR,
    pub next: *mut BACnet_Property_Reference,
}
#[test]
fn bindgen_test_layout_BACnet_Property_Reference() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Property_Reference> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Property_Reference>(),
        32usize,
        concat!("Size of: ", stringify!(BACnet_Property_Reference))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Property_Reference>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Property_Reference))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propertyIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Reference),
            "::",
            stringify!(propertyIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propertyArrayIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Reference),
            "::",
            stringify!(propertyArrayIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Reference),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Reference),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Reference),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_PROPERTY_REFERENCE = BACnet_Property_Reference;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Property_Value {
    pub propertyIdentifier: BACNET_PROPERTY_ID,
    pub propertyArrayIndex: BACNET_ARRAY_INDEX,
    pub value: BACNET_APPLICATION_DATA_VALUE,
    pub priority: u8,
    pub next: *mut BACnet_Property_Value,
}
#[test]
fn bindgen_test_layout_BACnet_Property_Value() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Property_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Property_Value>(),
        6824usize,
        concat!("Size of: ", stringify!(BACnet_Property_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Property_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Property_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propertyIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Value),
            "::",
            stringify!(propertyIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).propertyArrayIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Value),
            "::",
            stringify!(propertyArrayIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Value),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        6808usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Value),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        6816usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Property_Value),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_PROPERTY_VALUE = BACnet_Property_Value;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Object_Property_Value {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub object_property: BACNET_PROPERTY_ID,
    pub array_index: BACNET_ARRAY_INDEX,
    pub value: *mut BACNET_APPLICATION_DATA_VALUE,
}
#[test]
fn bindgen_test_layout_BACnet_Object_Property_Value() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Object_Property_Value> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Object_Property_Value>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_Object_Property_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Object_Property_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Object_Property_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Value),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Value),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Value),
            "::",
            stringify!(object_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Value),
            "::",
            stringify!(array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Object_Property_Value),
            "::",
            stringify!(value)
        )
    );
}
pub type BACNET_OBJECT_PROPERTY_VALUE = BACnet_Object_Property_Value;
extern "C" {
    pub fn bacapp_value_list_init(value: *mut BACNET_APPLICATION_DATA_VALUE, count: usize);
}
extern "C" {
    pub fn bacapp_property_value_list_init(value: *mut BACNET_PROPERTY_VALUE, count: usize);
}
extern "C" {
    pub fn bacapp_encode_data(
        apdu: *mut u8,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_data(
        apdu: *mut u8,
        tag_data_type: u8,
        len_value_type: u32,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_application_data(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_application_data_safe(
        new_apdu: *mut u8,
        new_apdu_len: u32,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn bacapp_encode_application_data(
        apdu: *mut u8,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_data(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_data(
        apdu: *mut u8,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_data_value(
        apdu: *mut u8,
        context_tag_number: u8,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_context_tag_type(
        property: BACNET_PROPERTY_ID,
        tag_number: u8,
    ) -> BACNET_APPLICATION_TAG;
}
extern "C" {
    pub fn bacapp_decode_generic_property(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        prop: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_known_property(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_int,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        object_type: BACNET_OBJECT_TYPE,
        property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_known_property_tag(
        object_type: BACNET_OBJECT_TYPE,
        property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_copy(
        dest_value: *mut BACNET_APPLICATION_DATA_VALUE,
        src_value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn bacapp_data_len(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_data_len(
        apdu: *mut u8,
        tag_data_type: u8,
        len_value_type: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_application_data_len(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_data_len(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_snprintf_value(
        str_: *mut ::std::os::raw::c_char,
        str_len: usize,
        object_value: *mut BACNET_OBJECT_PROPERTY_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_same_value(
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        test_value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> bool;
}
pub const BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER_TIME_RANGE_SPECIFIER_SPECIFIED:
    BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER = 0;
pub const BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER_TIME_RANGE_SPECIFIER_ALWAYS:
    BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER = 1;
pub const BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER_TIME_RANGE_SPECIFIER_MAX:
    BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER = 2;
pub type BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER = ::std::os::raw::c_uint;
pub const BACNET_ACCESS_RULE_LOCATION_SPECIFIER_LOCATION_SPECIFIER_SPECIFIED:
    BACNET_ACCESS_RULE_LOCATION_SPECIFIER = 0;
pub const BACNET_ACCESS_RULE_LOCATION_SPECIFIER_LOCATION_SPECIFIER_ALL:
    BACNET_ACCESS_RULE_LOCATION_SPECIFIER = 1;
pub const BACNET_ACCESS_RULE_LOCATION_SPECIFIER_LOCATION_SPECIFIER_MAX:
    BACNET_ACCESS_RULE_LOCATION_SPECIFIER = 2;
pub type BACNET_ACCESS_RULE_LOCATION_SPECIFIER = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACNET_ACCESS_RULE {
    pub time_range_specifier: BACNET_ACCESS_RULE_TIME_RANGE_SPECIFIER,
    pub time_range: BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    pub location_specifier: BACNET_ACCESS_RULE_LOCATION_SPECIFIER,
    pub location: BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    pub enable: bool,
}
#[test]
fn bindgen_test_layout_BACNET_ACCESS_RULE() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_ACCESS_RULE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_ACCESS_RULE>(),
        88usize,
        concat!("Size of: ", stringify!(BACNET_ACCESS_RULE))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_ACCESS_RULE>(),
        8usize,
        concat!("Alignment of ", stringify!(BACNET_ACCESS_RULE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_range_specifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ACCESS_RULE),
            "::",
            stringify!(time_range_specifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_range) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ACCESS_RULE),
            "::",
            stringify!(time_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location_specifier) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ACCESS_RULE),
            "::",
            stringify!(location_specifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ACCESS_RULE),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ACCESS_RULE),
            "::",
            stringify!(enable)
        )
    );
}
extern "C" {
    pub fn bacapp_encode_access_rule(
        apdu: *mut u8,
        rule: *mut BACNET_ACCESS_RULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_access_rule(
        apdu: *mut u8,
        tag_number: u8,
        rule: *mut BACNET_ACCESS_RULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_access_rule(
        apdu: *mut u8,
        rule: *mut BACNET_ACCESS_RULE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_access_rule(
        apdu: *mut u8,
        tag_number: u8,
        rule: *mut BACNET_ACCESS_RULE,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACNET_ALARM_ACK_DATA {
    pub ackProcessIdentifier: u32,
    pub eventObjectIdentifier: BACNET_OBJECT_ID,
    pub eventStateAcked: BACNET_EVENT_STATE,
    pub eventTimeStamp: BACNET_TIMESTAMP,
    pub ackSource: BACNET_CHARACTER_STRING,
    pub ackTimeStamp: BACNET_TIMESTAMP,
}
#[test]
fn bindgen_test_layout_BACNET_ALARM_ACK_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_ALARM_ACK_DATA> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_ALARM_ACK_DATA>(),
        1528usize,
        concat!("Size of: ", stringify!(BACNET_ALARM_ACK_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_ALARM_ACK_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(BACNET_ALARM_ACK_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ackProcessIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ALARM_ACK_DATA),
            "::",
            stringify!(ackProcessIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventObjectIdentifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ALARM_ACK_DATA),
            "::",
            stringify!(eventObjectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventStateAcked) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ALARM_ACK_DATA),
            "::",
            stringify!(eventStateAcked)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventTimeStamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ALARM_ACK_DATA),
            "::",
            stringify!(eventTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ackSource) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ALARM_ACK_DATA),
            "::",
            stringify!(ackSource)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ackTimeStamp) as usize - ptr as usize },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ALARM_ACK_DATA),
            "::",
            stringify!(ackTimeStamp)
        )
    );
}
pub type alarm_ack_function = ::std::option::Option<
    unsafe extern "C" fn(
        alarmack_data: *mut BACNET_ALARM_ACK_DATA,
        error_code: *mut BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " Creates a Alarm Acknowledge APDU"]
    pub fn alarm_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_ALARM_ACK_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes the service data part of Alarm Acknowledge"]
    pub fn alarm_ack_encode_service_request(
        apdu: *mut u8,
        data: *mut BACNET_ALARM_ACK_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes the service data part of Alarm Acknowledge"]
    pub fn alarm_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_ALARM_ACK_DATA,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _confirmed_service_data {
    pub segmented_message: bool,
    pub more_follows: bool,
    pub segmented_response_accepted: bool,
    pub max_segs: ::std::os::raw::c_int,
    pub max_resp: ::std::os::raw::c_int,
    pub invoke_id: u8,
    pub sequence_number: u8,
    pub proposed_window_number: u8,
}
#[test]
fn bindgen_test_layout__confirmed_service_data() {
    const UNINIT: ::std::mem::MaybeUninit<_confirmed_service_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_confirmed_service_data>(),
        16usize,
        concat!("Size of: ", stringify!(_confirmed_service_data))
    );
    assert_eq!(
        ::std::mem::align_of::<_confirmed_service_data>(),
        4usize,
        concat!("Alignment of ", stringify!(_confirmed_service_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmented_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(segmented_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).more_follows) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(more_follows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmented_response_accepted) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(segmented_response_accepted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_segs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(max_segs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_resp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(max_resp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invoke_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(invoke_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(sequence_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposed_window_number) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_data),
            "::",
            stringify!(proposed_window_number)
        )
    );
}
pub type BACNET_CONFIRMED_SERVICE_DATA = _confirmed_service_data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _confirmed_service_ack_data {
    pub segmented_message: bool,
    pub more_follows: bool,
    pub invoke_id: u8,
    pub sequence_number: u8,
    pub proposed_window_number: u8,
}
#[test]
fn bindgen_test_layout__confirmed_service_ack_data() {
    const UNINIT: ::std::mem::MaybeUninit<_confirmed_service_ack_data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_confirmed_service_ack_data>(),
        5usize,
        concat!("Size of: ", stringify!(_confirmed_service_ack_data))
    );
    assert_eq!(
        ::std::mem::align_of::<_confirmed_service_ack_data>(),
        1usize,
        concat!("Alignment of ", stringify!(_confirmed_service_ack_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmented_message) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_ack_data),
            "::",
            stringify!(segmented_message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).more_follows) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_ack_data),
            "::",
            stringify!(more_follows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invoke_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_ack_data),
            "::",
            stringify!(invoke_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence_number) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_ack_data),
            "::",
            stringify!(sequence_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proposed_window_number) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_confirmed_service_ack_data),
            "::",
            stringify!(proposed_window_number)
        )
    );
}
pub type BACNET_CONFIRMED_SERVICE_ACK_DATA = _confirmed_service_ack_data;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Atomic_Read_File_Data {
    pub object_instance: u32,
    pub object_type: BACNET_OBJECT_TYPE,
    pub access: BACNET_FILE_ACCESS_METHOD,
    pub type_: BACnet_Atomic_Read_File_Data__bindgen_ty_1,
    pub fileData: [BACNET_OCTET_STRING; 1usize],
    pub endOfFile: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Atomic_Read_File_Data__bindgen_ty_1 {
    pub stream: BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1,
    pub record: BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1 {
    pub fileStartPosition: i32,
    pub requestedOctetCount: BACNET_UNSIGNED_INTEGER,
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileStartPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fileStartPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestedOctetCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(requestedOctetCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2 {
    pub fileStartRecord: i32,
    pub RecordCount: BACNET_UNSIGNED_INTEGER,
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileStartRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fileStartRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecordCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(RecordCount)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Read_File_Data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Atomic_Read_File_Data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Read_File_Data__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Read_File_Data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data__bindgen_ty_1),
            "::",
            stringify!(record)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Read_File_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Atomic_Read_File_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Read_File_Data>(),
        1520usize,
        concat!("Size of: ", stringify!(BACnet_Atomic_Read_File_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Read_File_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Atomic_Read_File_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data),
            "::",
            stringify!(fileData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endOfFile) as usize - ptr as usize },
        1512usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Read_File_Data),
            "::",
            stringify!(endOfFile)
        )
    );
}
pub type BACNET_ATOMIC_READ_FILE_DATA = BACnet_Atomic_Read_File_Data;
extern "C" {
    pub fn arf_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arf_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arf_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arf_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arf_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arf_ack_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACNET_ASSIGNED_ACCESS_RIGHTS {
    pub assigned_access_rights: BACNET_DEVICE_OBJECT_REFERENCE,
    pub enable: bool,
}
#[test]
fn bindgen_test_layout_BACNET_ASSIGNED_ACCESS_RIGHTS() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_ASSIGNED_ACCESS_RIGHTS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_ASSIGNED_ACCESS_RIGHTS>(),
        20usize,
        concat!("Size of: ", stringify!(BACNET_ASSIGNED_ACCESS_RIGHTS))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_ASSIGNED_ACCESS_RIGHTS>(),
        4usize,
        concat!("Alignment of ", stringify!(BACNET_ASSIGNED_ACCESS_RIGHTS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assigned_access_rights) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ASSIGNED_ACCESS_RIGHTS),
            "::",
            stringify!(assigned_access_rights)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_ASSIGNED_ACCESS_RIGHTS),
            "::",
            stringify!(enable)
        )
    );
}
extern "C" {
    pub fn bacapp_encode_assigned_access_rights(
        apdu: *mut u8,
        aar: *mut BACNET_ASSIGNED_ACCESS_RIGHTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_assigned_access_rights(
        apdu: *mut u8,
        tag: u8,
        aar: *mut BACNET_ASSIGNED_ACCESS_RIGHTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_assigned_access_rights(
        apdu: *mut u8,
        aar: *mut BACNET_ASSIGNED_ACCESS_RIGHTS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_assigned_access_rights(
        apdu: *mut u8,
        tag: u8,
        aar: *mut BACNET_ASSIGNED_ACCESS_RIGHTS,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACNET_AUTHENTICATION_FACTOR {
    pub format_type: BACNET_AUTHENTICATION_FACTOR_TYPE,
    pub format_class: u32,
    pub value: BACNET_OCTET_STRING,
}
#[test]
fn bindgen_test_layout_BACNET_AUTHENTICATION_FACTOR() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_AUTHENTICATION_FACTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_AUTHENTICATION_FACTOR>(),
        1488usize,
        concat!("Size of: ", stringify!(BACNET_AUTHENTICATION_FACTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_AUTHENTICATION_FACTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(BACNET_AUTHENTICATION_FACTOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_AUTHENTICATION_FACTOR),
            "::",
            stringify!(format_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_class) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_AUTHENTICATION_FACTOR),
            "::",
            stringify!(format_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_AUTHENTICATION_FACTOR),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn bacapp_encode_authentication_factor(
        apdu: *mut u8,
        af: *mut BACNET_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_authentication_factor(
        apdu: *mut u8,
        tag: u8,
        af: *mut BACNET_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_authentication_factor(
        apdu: *mut u8,
        af: *mut BACNET_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_authentication_factor(
        apdu: *mut u8,
        tag: u8,
        af: *mut BACNET_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACNET_AUTHENTICATION_FACTOR_FORMAT {
    pub format_type: BACNET_AUTHENTICATION_FACTOR_TYPE,
    pub vendor_id: u32,
    pub vendor_format: u32,
}
#[test]
fn bindgen_test_layout_BACNET_AUTHENTICATION_FACTOR_FORMAT() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_AUTHENTICATION_FACTOR_FORMAT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_AUTHENTICATION_FACTOR_FORMAT>(),
        12usize,
        concat!("Size of: ", stringify!(BACNET_AUTHENTICATION_FACTOR_FORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_AUTHENTICATION_FACTOR_FORMAT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACNET_AUTHENTICATION_FACTOR_FORMAT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_AUTHENTICATION_FACTOR_FORMAT),
            "::",
            stringify!(format_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_AUTHENTICATION_FACTOR_FORMAT),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_AUTHENTICATION_FACTOR_FORMAT),
            "::",
            stringify!(vendor_format)
        )
    );
}
extern "C" {
    pub fn bacapp_encode_authentication_factor_format(
        apdu: *mut u8,
        aff: *mut BACNET_AUTHENTICATION_FACTOR_FORMAT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_authentication_factor_format(
        apdu: *mut u8,
        tag_number: u8,
        aff: *mut BACNET_AUTHENTICATION_FACTOR_FORMAT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_authentication_factor_format(
        apdu: *mut u8,
        aff: *mut BACNET_AUTHENTICATION_FACTOR_FORMAT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_authentication_factor_format(
        apdu: *mut u8,
        tag_number: u8,
        aff: *mut BACNET_AUTHENTICATION_FACTOR_FORMAT,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Atomic_Write_File_Data {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub access: BACNET_FILE_ACCESS_METHOD,
    pub type_: BACnet_Atomic_Write_File_Data__bindgen_ty_1,
    pub fileData: [BACNET_OCTET_STRING; 1usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Atomic_Write_File_Data__bindgen_ty_1 {
    pub stream: BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1,
    pub record: BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1 {
    pub fileStartPosition: i32,
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileStartPosition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(fileStartPosition)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2 {
    pub fileStartRecord: i32,
    pub returnedRecordCount: u32,
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileStartRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fileStartRecord)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returnedRecordCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(returnedRecordCount)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Write_File_Data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Atomic_Write_File_Data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Write_File_Data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Write_File_Data__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).record) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data__bindgen_ty_1),
            "::",
            stringify!(record)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Atomic_Write_File_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Atomic_Write_File_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Atomic_Write_File_Data>(),
        1504usize,
        concat!("Size of: ", stringify!(BACnet_Atomic_Write_File_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Atomic_Write_File_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Atomic_Write_File_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Atomic_Write_File_Data),
            "::",
            stringify!(fileData)
        )
    );
}
pub type BACNET_ATOMIC_WRITE_FILE_DATA = BACnet_Atomic_Write_File_Data;
extern "C" {
    pub fn awf_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_ATOMIC_WRITE_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn awf_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_ATOMIC_WRITE_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn awf_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        data: *mut BACNET_ATOMIC_WRITE_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn awf_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_ATOMIC_WRITE_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn awf_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_ATOMIC_WRITE_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn awf_ack_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        data: *mut BACNET_ATOMIC_WRITE_FILE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacnet_address_copy(dest: *mut BACNET_ADDRESS, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn bacnet_address_same(dest: *mut BACNET_ADDRESS, src: *mut BACNET_ADDRESS) -> bool;
}
extern "C" {
    pub fn bacnet_address_init(
        dest: *mut BACNET_ADDRESS,
        mac: *mut BACNET_MAC_ADDRESS,
        dnet: u16,
        adr: *mut BACNET_MAC_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_address_mac_same(
        dest: *mut BACNET_MAC_ADDRESS,
        src: *mut BACNET_MAC_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_address_mac_init(mac: *mut BACNET_MAC_ADDRESS, adr: *mut u8, len: u8);
}
extern "C" {
    pub fn bacnet_address_mac_from_ascii(
        mac: *mut BACNET_MAC_ADDRESS,
        arg: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn bacerror_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        service: BACNET_CONFIRMED_SERVICE,
        error_class: BACNET_ERROR_CLASS,
        error_code: BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacerror_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        service: *mut BACNET_CONFIRMED_SERVICE,
        error_class: *mut BACNET_ERROR_CLASS,
        error_code: *mut BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacerror_decode_error_class_and_code(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        error_class: *mut BACNET_ERROR_CLASS,
        error_code: *mut BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROP_TAG_DATA {
    pub prop_id: ::std::os::raw::c_int,
    pub tag_id: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROP_TAG_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<PROP_TAG_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROP_TAG_DATA>(),
        8usize,
        concat!("Size of: ", stringify!(PROP_TAG_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<PROP_TAG_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(PROP_TAG_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prop_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROP_TAG_DATA),
            "::",
            stringify!(prop_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROP_TAG_DATA),
            "::",
            stringify!(tag_id)
        )
    );
}
extern "C" {
    pub fn bacprop_tag_by_index_default(
        data_list: *mut PROP_TAG_DATA,
        index: ::std::os::raw::c_int,
        default_ret: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacprop_property_tag(
        type_: BACNET_OBJECT_TYPE,
        prop: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub const BACNET_PROPERTY_STATE_TYPE_BOOLEAN_VALUE: BACNET_PROPERTY_STATE_TYPE = 0;
pub const BACNET_PROPERTY_STATE_TYPE_BINARY_VALUE: BACNET_PROPERTY_STATE_TYPE = 1;
pub const BACNET_PROPERTY_STATE_TYPE_EVENT_TYPE: BACNET_PROPERTY_STATE_TYPE = 2;
pub const BACNET_PROPERTY_STATE_TYPE_POLARITY: BACNET_PROPERTY_STATE_TYPE = 3;
pub const BACNET_PROPERTY_STATE_TYPE_PROGRAM_CHANGE: BACNET_PROPERTY_STATE_TYPE = 4;
pub const BACNET_PROPERTY_STATE_TYPE_PROGRAM_STATE: BACNET_PROPERTY_STATE_TYPE = 5;
pub const BACNET_PROPERTY_STATE_TYPE_REASON_FOR_HALT: BACNET_PROPERTY_STATE_TYPE = 6;
pub const BACNET_PROPERTY_STATE_TYPE_RELIABILITY: BACNET_PROPERTY_STATE_TYPE = 7;
pub const BACNET_PROPERTY_STATE_TYPE_STATE: BACNET_PROPERTY_STATE_TYPE = 8;
pub const BACNET_PROPERTY_STATE_TYPE_SYSTEM_STATUS: BACNET_PROPERTY_STATE_TYPE = 9;
pub const BACNET_PROPERTY_STATE_TYPE_UNITS: BACNET_PROPERTY_STATE_TYPE = 10;
pub const BACNET_PROPERTY_STATE_TYPE_UNSIGNED_VALUE: BACNET_PROPERTY_STATE_TYPE = 11;
pub const BACNET_PROPERTY_STATE_TYPE_LIFE_SAFETY_MODE: BACNET_PROPERTY_STATE_TYPE = 12;
pub const BACNET_PROPERTY_STATE_TYPE_LIFE_SAFETY_STATE: BACNET_PROPERTY_STATE_TYPE = 13;
pub type BACNET_PROPERTY_STATE_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACNET_PROPERTY_STATE {
    pub tag: BACNET_PROPERTY_STATE_TYPE,
    pub state: BACNET_PROPERTY_STATE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACNET_PROPERTY_STATE__bindgen_ty_1 {
    pub booleanValue: bool,
    pub binaryValue: BACNET_BINARY_PV,
    pub eventType: BACNET_EVENT_TYPE,
    pub polarity: BACNET_POLARITY,
    pub programChange: BACNET_PROGRAM_REQUEST,
    pub programState: BACNET_PROGRAM_STATE,
    pub programError: BACNET_PROGRAM_ERROR,
    pub reliability: BACNET_RELIABILITY,
    pub state: BACNET_EVENT_STATE,
    pub systemStatus: BACNET_DEVICE_STATUS,
    pub units: BACNET_ENGINEERING_UNITS,
    pub unsignedValue: BACNET_UNSIGNED_INTEGER,
    pub lifeSafetyMode: BACNET_LIFE_SAFETY_MODE,
    pub lifeSafetyState: BACNET_LIFE_SAFETY_STATE,
}
#[test]
fn bindgen_test_layout_BACNET_PROPERTY_STATE__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_PROPERTY_STATE__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_PROPERTY_STATE__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_PROPERTY_STATE__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).booleanValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(booleanValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(binaryValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(eventType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).polarity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(polarity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).programChange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(programChange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).programState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(programState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).programError) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(programError)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).systemStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(systemStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).units) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsignedValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(unsignedValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifeSafetyMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(lifeSafetyMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifeSafetyState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE__bindgen_ty_1),
            "::",
            stringify!(lifeSafetyState)
        )
    );
}
#[test]
fn bindgen_test_layout_BACNET_PROPERTY_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_PROPERTY_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_PROPERTY_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(BACNET_PROPERTY_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_PROPERTY_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(BACNET_PROPERTY_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_PROPERTY_STATE),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    pub fn bacapp_decode_property_state(
        apdu: *mut u8,
        value: *mut BACNET_PROPERTY_STATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_property_state(
        apdu: *mut u8,
        tag_number: u8,
        value: *mut BACNET_PROPERTY_STATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_property_state(
        apdu: *mut u8,
        value: *mut BACNET_PROPERTY_STATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __b: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __len: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __charset: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        __s1: *mut ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut ::std::os::raw::c_char,
        __sep: *const ::std::os::raw::c_char,
        __lasts: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __strerrbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn stpcpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __s1: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn memset_s(
        __s: *mut ::std::os::raw::c_void,
        __smax: rsize_t,
        __c: ::std::os::raw::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const ::std::os::raw::c_void,
        __big_len: usize,
        __little: *const ::std::os::raw::c_void,
        __little_len: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset_pattern4(
        __b: *mut ::std::os::raw::c_void,
        __pattern4: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern8(
        __b: *mut ::std::os::raw::c_void,
        __pattern8: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn memset_pattern16(
        __b: *mut ::std::os::raw::c_void,
        __pattern16: *const ::std::os::raw::c_void,
        __len: usize,
    );
}
extern "C" {
    pub fn strcasestr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const ::std::os::raw::c_char,
        __little: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut ::std::os::raw::c_char,
        __source: *const ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: ::std::os::raw::c_int, __bp: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const ::std::os::raw::c_void,
        __b2: *const ::std::os::raw::c_void,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsignal_r(
        __sig: ::std::os::raw::c_int,
        __strsignalbuf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fls(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsl(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flsll(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_1 {
    pub index: ::std::os::raw::c_uint,
    pub pString: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_bindgen_ty_1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pString) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_bindgen_ty_1),
            "::",
            stringify!(pString)
        )
    );
}
pub type INDTEXT_DATA = _bindgen_ty_1;
extern "C" {
    pub fn indtext_by_string(
        data_list: *const _bindgen_ty_1,
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn indtext_by_istring(
        data_list: *const _bindgen_ty_1,
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn indtext_by_string_default(
        data_list: *const _bindgen_ty_1,
        search_name: *const ::std::os::raw::c_char,
        default_index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn indtext_by_istring_default(
        data_list: *const _bindgen_ty_1,
        search_name: *const ::std::os::raw::c_char,
        default_index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn indtext_by_index(
        data_list: *const _bindgen_ty_1,
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn indtext_by_index_default(
        data_list: *const _bindgen_ty_1,
        index: ::std::os::raw::c_uint,
        default_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn indtext_by_index_split_default(
        data_list: *const _bindgen_ty_1,
        index: ::std::os::raw::c_uint,
        split_index: ::std::os::raw::c_uint,
        before_split_default_name: *const ::std::os::raw::c_char,
        default_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn indtext_count(data_list: *const _bindgen_ty_1) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn stricmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bactext_confirmed_service_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_unconfirmed_service_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_application_tag_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_application_tag_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_object_type_name(index: ::std::os::raw::c_uint)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_object_type_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_object_type_strtol(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_notify_type_name(index: ::std::os::raw::c_uint)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_event_type_name(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_property_name_proprietary(index: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn bactext_property_name(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_property_name_default(
        index: ::std::os::raw::c_uint,
        default_string: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_property_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_property_strtol(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_engineering_unit_name_proprietary(index: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn bactext_engineering_unit_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_engineering_unit_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_reject_reason_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_abort_reason_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_error_class_name(index: ::std::os::raw::c_uint)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_error_code_name(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_property_id(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bactext_month_name(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_week_of_month_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_day_of_week_name(index: ::std::os::raw::c_uint)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_notify_type_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_event_state_name(index: ::std::os::raw::c_uint)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_event_state_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_event_state_strtol(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_event_type_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_binary_present_value_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_binary_polarity_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_binary_present_value_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_reliability_name(index: ::std::os::raw::c_uint)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_device_status_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_segmentation_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_segmentation_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_node_type_name(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_character_string_encoding_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_event_transition_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_event_transition_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_days_of_week_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_days_of_week_index(
        search_name: *const ::std::os::raw::c_char,
        found_index: *mut ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn bactext_network_layer_msg_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_life_safety_state_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_device_communications_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_lighting_operation_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_lighting_in_progress(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_lighting_transition(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bactext_color_operation_name(
        index: ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_COV_Data {
    pub subscriberProcessIdentifier: u32,
    pub initiatingDeviceIdentifier: u32,
    pub monitoredObjectIdentifier: BACNET_OBJECT_ID,
    pub timeRemaining: u32,
    pub listOfValues: *mut BACNET_PROPERTY_VALUE,
}
#[test]
fn bindgen_test_layout_BACnet_COV_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_COV_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_COV_Data>(),
        32usize,
        concat!("Size of: ", stringify!(BACnet_COV_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_COV_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_COV_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriberProcessIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Data),
            "::",
            stringify!(subscriberProcessIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiatingDeviceIdentifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Data),
            "::",
            stringify!(initiatingDeviceIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitoredObjectIdentifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Data),
            "::",
            stringify!(monitoredObjectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeRemaining) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Data),
            "::",
            stringify!(timeRemaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listOfValues) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Data),
            "::",
            stringify!(listOfValues)
        )
    );
}
pub type BACNET_COV_DATA = BACnet_COV_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Subscribe_COV_Data {
    pub subscriberProcessIdentifier: u32,
    pub monitoredObjectIdentifier: BACNET_OBJECT_ID,
    pub cancellationRequest: bool,
    pub issueConfirmedNotifications: bool,
    pub lifetime: u32,
    pub covSubscribeToProperty: bool,
    pub monitoredProperty: BACNET_PROPERTY_REFERENCE,
    pub covIncrementPresent: bool,
    pub covIncrement: f32,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
    pub next: *mut BACnet_Subscribe_COV_Data,
}
#[test]
fn bindgen_test_layout_BACnet_Subscribe_COV_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Subscribe_COV_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Subscribe_COV_Data>(),
        80usize,
        concat!("Size of: ", stringify!(BACnet_Subscribe_COV_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Subscribe_COV_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Subscribe_COV_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subscriberProcessIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(subscriberProcessIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitoredObjectIdentifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(monitoredObjectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cancellationRequest) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(cancellationRequest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).issueConfirmedNotifications) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(issueConfirmedNotifications)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lifetime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(lifetime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).covSubscribeToProperty) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(covSubscribeToProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monitoredProperty) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(monitoredProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).covIncrementPresent) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(covIncrementPresent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).covIncrement) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(covIncrement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Subscribe_COV_Data),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_SUBSCRIBE_COV_DATA = BACnet_Subscribe_COV_Data;
pub type BACnet_COV_Notification_Callback =
    ::std::option::Option<unsafe extern "C" fn(cov_data: *mut BACNET_COV_DATA)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_COV_Notification {
    pub next: *mut BACnet_COV_Notification,
    pub callback: BACnet_COV_Notification_Callback,
}
#[test]
fn bindgen_test_layout_BACnet_COV_Notification() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_COV_Notification> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_COV_Notification>(),
        16usize,
        concat!("Size of: ", stringify!(BACnet_COV_Notification))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_COV_Notification>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_COV_Notification))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Notification),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_COV_Notification),
            "::",
            stringify!(callback)
        )
    );
}
pub type BACNET_COV_NOTIFICATION = BACnet_COV_Notification;
extern "C" {
    pub fn ucov_notify_encode_apdu(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucov_notify_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucov_notify_send(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccov_notify_encode_apdu(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        invoke_id: u8,
        data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ccov_notify_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cov_notify_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cov_subscribe_property_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_SUBSCRIBE_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cov_subscribe_property_encode_apdu(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        invoke_id: u8,
        data: *mut BACNET_SUBSCRIBE_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cov_subscribe_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_SUBSCRIBE_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cov_subscribe_encode_apdu(
        apdu: *mut u8,
        max_apdu_len: ::std::os::raw::c_uint,
        invoke_id: u8,
        data: *mut BACNET_SUBSCRIBE_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cov_data_value_list_link(
        data: *mut BACNET_COV_DATA,
        value_list: *mut BACNET_PROPERTY_VALUE,
        count: usize,
    );
}
extern "C" {
    pub fn cov_value_list_encode_real(
        value_list: *mut BACNET_PROPERTY_VALUE,
        value: f32,
        in_alarm: bool,
        fault: bool,
        overridden: bool,
        out_of_service: bool,
    ) -> bool;
}
extern "C" {
    pub fn cov_value_list_encode_enumerated(
        value_list: *mut BACNET_PROPERTY_VALUE,
        value: u32,
        in_alarm: bool,
        fault: bool,
        overridden: bool,
        out_of_service: bool,
    ) -> bool;
}
extern "C" {
    pub fn cov_value_list_encode_unsigned(
        value_list: *mut BACNET_PROPERTY_VALUE,
        value: u32,
        in_alarm: bool,
        fault: bool,
        overridden: bool,
        out_of_service: bool,
    ) -> bool;
}
extern "C" {
    pub fn cov_value_list_encode_character_string(
        value_list: *mut BACNET_PROPERTY_VALUE,
        value: *mut BACNET_CHARACTER_STRING,
        in_alarm: bool,
        fault: bool,
        overridden: bool,
        out_of_service: bool,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACNET_CREDENTIAL_AUTHENTICATION_FACTOR {
    pub disable: BACNET_ACCESS_AUTHENTICATION_FACTOR_DISABLE,
    pub authentication_factor: BACNET_AUTHENTICATION_FACTOR,
}
#[test]
fn bindgen_test_layout_BACNET_CREDENTIAL_AUTHENTICATION_FACTOR() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_CREDENTIAL_AUTHENTICATION_FACTOR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_CREDENTIAL_AUTHENTICATION_FACTOR>(),
        1496usize,
        concat!(
            "Size of: ",
            stringify!(BACNET_CREDENTIAL_AUTHENTICATION_FACTOR)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_CREDENTIAL_AUTHENTICATION_FACTOR>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACNET_CREDENTIAL_AUTHENTICATION_FACTOR)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_CREDENTIAL_AUTHENTICATION_FACTOR),
            "::",
            stringify!(disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_factor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_CREDENTIAL_AUTHENTICATION_FACTOR),
            "::",
            stringify!(authentication_factor)
        )
    );
}
extern "C" {
    pub fn bacapp_encode_credential_authentication_factor(
        apdu: *mut u8,
        caf: *mut BACNET_CREDENTIAL_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_encode_context_credential_authentication_factor(
        apdu: *mut u8,
        tag: u8,
        caf: *mut BACNET_CREDENTIAL_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_credential_authentication_factor(
        apdu: *mut u8,
        caf: *mut BACNET_CREDENTIAL_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacapp_decode_context_credential_authentication_factor(
        apdu: *mut u8,
        tag: u8,
        caf: *mut BACNET_CREDENTIAL_AUTHENTICATION_FACTOR,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dcc_enable_status() -> BACNET_COMMUNICATION_ENABLE_DISABLE;
}
extern "C" {
    pub fn dcc_communication_enabled() -> bool;
}
extern "C" {
    pub fn dcc_communication_disabled() -> bool;
}
extern "C" {
    pub fn dcc_communication_initiation_disabled() -> bool;
}
extern "C" {
    pub fn dcc_duration_seconds() -> u32;
}
extern "C" {
    pub fn dcc_timer_seconds(seconds: u32);
}
extern "C" {
    pub fn dcc_set_status_duration(
        status: BACNET_COMMUNICATION_ENABLE_DISABLE,
        minutes: u16,
    ) -> bool;
}
extern "C" {
    pub fn dcc_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        timeDuration: u16,
        enable_disable: BACNET_COMMUNICATION_ENABLE_DISABLE,
        password: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dcc_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        timeDuration: *mut u16,
        enable_disable: *mut BACNET_COMMUNICATION_ENABLE_DISABLE,
        password: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
pub const CHANGE_OF_VALUE_TYPE_CHANGE_OF_VALUE_BITS: CHANGE_OF_VALUE_TYPE = 0;
pub const CHANGE_OF_VALUE_TYPE_CHANGE_OF_VALUE_REAL: CHANGE_OF_VALUE_TYPE = 1;
pub type CHANGE_OF_VALUE_TYPE = ::std::os::raw::c_uint;
pub const COMMAND_FAILURE_TYPE_COMMAND_FAILURE_BINARY_PV: COMMAND_FAILURE_TYPE = 0;
pub const COMMAND_FAILURE_TYPE_COMMAND_FAILURE_UNSIGNED: COMMAND_FAILURE_TYPE = 1;
pub type COMMAND_FAILURE_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Event_Notification_Data {
    pub processIdentifier: u32,
    pub initiatingObjectIdentifier: BACNET_OBJECT_ID,
    pub eventObjectIdentifier: BACNET_OBJECT_ID,
    pub timeStamp: BACNET_TIMESTAMP,
    pub notificationClass: u32,
    pub priority: u8,
    pub eventType: BACNET_EVENT_TYPE,
    pub messageText: *mut BACNET_CHARACTER_STRING,
    pub notifyType: BACNET_NOTIFY_TYPE,
    pub ackRequired: bool,
    pub fromState: BACNET_EVENT_STATE,
    pub toState: BACNET_EVENT_STATE,
    pub notificationParams: BACnet_Event_Notification_Data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Event_Notification_Data__bindgen_ty_1 {
    pub changeOfBitstring: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1,
    pub changeOfState: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2,
    pub changeOfValue: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3,
    pub commandFailure: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4,
    pub floatingLimit: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5,
    pub outOfRange: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6,
    pub changeOfLifeSafety: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7,
    pub bufferReady: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8,
    pub unsignedRange: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9,
    pub accessEvent: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10,
    pub complexEventType: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1 {
    pub referencedBitString: BACNET_BIT_STRING,
    pub statusFlags: BACNET_BIT_STRING,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).referencedBitString) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(referencedBitString)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(statusFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2 {
    pub newState: BACNET_PROPERTY_STATE,
    pub statusFlags: BACNET_BIT_STRING,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).newState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(newState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(statusFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3 {
    pub newValue: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub tag: CHANGE_OF_VALUE_TYPE,
    pub statusFlags: BACNET_BIT_STRING,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub changedBits: BACNET_BIT_STRING,
    pub changeValue: f32,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changedBits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(changedBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(changeValue)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).newValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(newValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(statusFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4 {
    pub commandValue: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub tag: COMMAND_FAILURE_TYPE,
    pub statusFlags: BACNET_BIT_STRING,
    pub feedbackValue: BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub binaryValue: BACNET_BINARY_PV,
    pub unsignedValue: BACNET_UNSIGNED_INTEGER,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(binaryValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsignedValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(unsignedValue)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub binaryValue: BACNET_BINARY_PV,
    pub unsignedValue: BACNET_UNSIGNED_INTEGER,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).binaryValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(binaryValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsignedValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(unsignedValue)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(commandValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feedbackValue) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(feedbackValue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5 {
    pub referenceValue: f32,
    pub statusFlags: BACNET_BIT_STRING,
    pub setPointValue: f32,
    pub errorLimit: f32,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).referenceValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(referenceValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setPointValue) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(setPointValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errorLimit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(errorLimit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6 {
    pub exceedingValue: f32,
    pub statusFlags: BACNET_BIT_STRING,
    pub deadband: f32,
    pub exceededLimit: f32,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceedingValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(exceedingValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deadband) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(deadband)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceededLimit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(exceededLimit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7 {
    pub newState: BACNET_LIFE_SAFETY_STATE,
    pub newMode: BACNET_LIFE_SAFETY_MODE,
    pub statusFlags: BACNET_BIT_STRING,
    pub operationExpected: BACNET_LIFE_SAFETY_OPERATION,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).newState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(newState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).newMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(newMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operationExpected) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(operationExpected)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8 {
    pub bufferProperty: BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    pub previousNotification: u32,
    pub currentNotification: u32,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferProperty) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(bufferProperty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previousNotification) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(previousNotification)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentNotification) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(currentNotification)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9 {
    pub exceedingValue: u32,
    pub statusFlags: BACNET_BIT_STRING,
    pub exceededLimit: u32,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceedingValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(exceedingValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exceededLimit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(exceededLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10 {
    pub accessEvent: BACNET_ACCESS_EVENT,
    pub statusFlags: BACNET_BIT_STRING,
    pub accessEventTag: BACNET_UNSIGNED_INTEGER,
    pub accessEventTime: BACNET_TIMESTAMP,
    pub accessCredential: BACNET_DEVICE_OBJECT_REFERENCE,
    pub authenticationFactor: BACNET_AUTHENTICATION_FACTOR,
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10>(),
        1552usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(accessEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).statusFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(statusFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessEventTag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(accessEventTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessEventTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(accessEventTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessCredential) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(accessCredential)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authenticationFactor) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(authenticationFactor)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11 {
    pub values: [BACNET_PROPERTY_VALUE; 5usize],
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11() {
    const UNINIT: ::std::mem::MaybeUninit<
        BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11>(),
        34120usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(values)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Event_Notification_Data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data__bindgen_ty_1>(),
        34120usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeOfBitstring) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(changeOfBitstring)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeOfState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(changeOfState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeOfValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(changeOfValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).commandFailure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(commandFailure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).floatingLimit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(floatingLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outOfRange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(outOfRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).changeOfLifeSafety) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(changeOfLifeSafety)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bufferReady) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(bufferReady)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsignedRange) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(unsignedRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accessEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(accessEvent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complexEventType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data__bindgen_ty_1),
            "::",
            stringify!(complexEventType)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Event_Notification_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Event_Notification_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Event_Notification_Data>(),
        34192usize,
        concat!("Size of: ", stringify!(BACnet_Event_Notification_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Event_Notification_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Event_Notification_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(processIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initiatingObjectIdentifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(initiatingObjectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventObjectIdentifier) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(eventObjectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notificationClass) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(notificationClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventType) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(eventType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageText) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(messageText)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notifyType) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(notifyType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ackRequired) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(ackRequired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fromState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(fromState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).toState) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(toState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notificationParams) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Event_Notification_Data),
            "::",
            stringify!(notificationParams)
        )
    );
}
pub type BACNET_EVENT_NOTIFICATION_DATA = BACnet_Event_Notification_Data;
extern "C" {
    #[doc = " Creates a Confirmed Event Notification APDU"]
    pub fn cevent_notify_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Creates an Unconfirmed Event Notification APDU"]
    pub fn uevent_notify_encode_apdu(
        apdu: *mut u8,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encodes the service data part of Event Notification"]
    pub fn event_notify_encode_service_request(
        apdu: *mut u8,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decodes the service data part of Event Notification"]
    pub fn event_notify_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sends an Unconfirmed Event Notification to a dest"]
    pub fn uevent_notify_send(
        buffer: *mut u8,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
        dest: *mut BACNET_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Get_Alarm_Summary_Data {
    pub objectIdentifier: BACNET_OBJECT_ID,
    pub alarmState: BACNET_EVENT_STATE,
    pub acknowledgedTransitions: BACNET_BIT_STRING,
    pub next: *mut BACnet_Get_Alarm_Summary_Data,
}
#[test]
fn bindgen_test_layout_BACnet_Get_Alarm_Summary_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Get_Alarm_Summary_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Get_Alarm_Summary_Data>(),
        40usize,
        concat!("Size of: ", stringify!(BACnet_Get_Alarm_Summary_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Get_Alarm_Summary_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Get_Alarm_Summary_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Alarm_Summary_Data),
            "::",
            stringify!(objectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alarmState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Alarm_Summary_Data),
            "::",
            stringify!(alarmState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledgedTransitions) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Alarm_Summary_Data),
            "::",
            stringify!(acknowledgedTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Alarm_Summary_Data),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_GET_ALARM_SUMMARY_DATA = BACnet_Get_Alarm_Summary_Data;
pub type get_alarm_summary_function = ::std::option::Option<
    unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        getalarm_data: *mut BACNET_GET_ALARM_SUMMARY_DATA,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn get_alarm_summary_encode_apdu(apdu: *mut u8, invoke_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_alarm_summary_ack_encode_apdu_init(
        apdu: *mut u8,
        invoke_id: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_alarm_summary_ack_encode_apdu_data(
        apdu: *mut u8,
        max_apdu: usize,
        get_alarm_data: *mut BACNET_GET_ALARM_SUMMARY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn get_alarm_summary_ack_decode_apdu_data(
        apdu: *mut u8,
        max_apdu: usize,
        get_alarm_data: *mut BACNET_GET_ALARM_SUMMARY_DATA,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Get_Event_Information_Data {
    pub objectIdentifier: BACNET_OBJECT_ID,
    pub eventState: BACNET_EVENT_STATE,
    pub acknowledgedTransitions: BACNET_BIT_STRING,
    pub eventTimeStamps: [BACNET_TIMESTAMP; 3usize],
    pub notifyType: BACNET_NOTIFY_TYPE,
    pub eventEnable: BACNET_BIT_STRING,
    pub eventPriorities: [u32; 3usize],
    pub next: *mut BACnet_Get_Event_Information_Data,
}
#[test]
fn bindgen_test_layout_BACnet_Get_Event_Information_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Get_Event_Information_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Get_Event_Information_Data>(),
        104usize,
        concat!("Size of: ", stringify!(BACnet_Get_Event_Information_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Get_Event_Information_Data>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Get_Event_Information_Data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objectIdentifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(objectIdentifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(eventState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).acknowledgedTransitions) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(acknowledgedTransitions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventTimeStamps) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(eventTimeStamps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).notifyType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(notifyType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventEnable) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(eventEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventPriorities) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(eventPriorities)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Get_Event_Information_Data),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_GET_EVENT_INFORMATION_DATA = BACnet_Get_Event_Information_Data;
pub type get_event_info_function = ::std::option::Option<
    unsafe extern "C" fn(
        index: ::std::os::raw::c_uint,
        getevent_data: *mut BACNET_GET_EVENT_INFORMATION_DATA,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn getevent_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        lastReceivedObjectIdentifier: *mut BACNET_OBJECT_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getevent_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        object_id: *mut BACNET_OBJECT_ID,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getevent_ack_encode_apdu_init(
        apdu: *mut u8,
        max_apdu: usize,
        invoke_id: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getevent_ack_encode_apdu_data(
        apdu: *mut u8,
        max_apdu: usize,
        get_event_data: *mut BACNET_GET_EVENT_INFORMATION_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getevent_ack_encode_apdu_end(
        apdu: *mut u8,
        max_apdu: usize,
        moreEvents: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getevent_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_int,
        get_event_data: *mut BACNET_GET_EVENT_INFORMATION_DATA,
        moreEvents: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iam_encode_apdu(
        apdu: *mut u8,
        device_id: u32,
        max_apdu: ::std::os::raw::c_uint,
        segmentation: ::std::os::raw::c_int,
        vendor_id: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iam_decode_service_request(
        apdu: *mut u8,
        pDevice_id: *mut u32,
        pMax_apdu: *mut ::std::os::raw::c_uint,
        pSegmentation: *mut ::std::os::raw::c_int,
        pVendor_id: *mut u16,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_I_Have_Data {
    pub device_id: BACNET_OBJECT_ID,
    pub object_id: BACNET_OBJECT_ID,
    pub object_name: BACNET_CHARACTER_STRING,
}
#[test]
fn bindgen_test_layout_BACnet_I_Have_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_I_Have_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_I_Have_Data>(),
        1496usize,
        concat!("Size of: ", stringify!(BACnet_I_Have_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_I_Have_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_I_Have_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_I_Have_Data),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_I_Have_Data),
            "::",
            stringify!(object_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_I_Have_Data),
            "::",
            stringify!(object_name)
        )
    );
}
pub type BACNET_I_HAVE_DATA = BACnet_I_Have_Data;
extern "C" {
    pub fn ihave_encode_apdu(apdu: *mut u8, data: *mut BACNET_I_HAVE_DATA)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ihave_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_I_HAVE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ihave_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_I_HAVE_DATA,
    ) -> ::std::os::raw::c_int;
}
#[doc = "  AddListElement-Request ::= SEQUENCE {\n      object-identifier       [0] BACnetObjectIdentifier,\n      property-identifier     [1] BACnetPropertyIdentifier,\n      property-array-index    [2] Unsigned OPTIONAL,\n      -- used only with array datatype\n      list-of-elements        [3] ABSTRACT-SYNTAX.&Type\n  }\n  RemoveListElement-Request ::= SEQUENCE {\n      object-identifier       [0] BACnetObjectIdentifier,\n      property-identifier     [1] BACnetPropertyIdentifier,\n      property-array-index    [2] Unsigned OPTIONAL,\n      -- used only with array datatypes\n      list-of-elements        [3] ABSTRACT-SYNTAX.&Type\n  }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_List_Element_Data {
    pub object_instance: u32,
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_property: BACNET_PROPERTY_ID,
    pub array_index: BACNET_ARRAY_INDEX,
    pub application_data: *mut u8,
    pub application_data_len: ::std::os::raw::c_int,
    pub first_failed_element_number: BACNET_UNSIGNED_INTEGER,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[test]
fn bindgen_test_layout_BACnet_List_Element_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_List_Element_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_List_Element_Data>(),
        48usize,
        concat!("Size of: ", stringify!(BACnet_List_Element_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_List_Element_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_List_Element_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(object_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(application_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(application_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).first_failed_element_number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(first_failed_element_number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_List_Element_Data),
            "::",
            stringify!(error_code)
        )
    );
}
#[doc = "  AddListElement-Request ::= SEQUENCE {\n      object-identifier       [0] BACnetObjectIdentifier,\n      property-identifier     [1] BACnetPropertyIdentifier,\n      property-array-index    [2] Unsigned OPTIONAL,\n      -- used only with array datatype\n      list-of-elements        [3] ABSTRACT-SYNTAX.&Type\n  }\n  RemoveListElement-Request ::= SEQUENCE {\n      object-identifier       [0] BACnetObjectIdentifier,\n      property-identifier     [1] BACnetPropertyIdentifier,\n      property-array-index    [2] Unsigned OPTIONAL,\n      -- used only with array datatypes\n      list-of-elements        [3] ABSTRACT-SYNTAX.&Type\n  }"]
pub type BACNET_LIST_ELEMENT_DATA = BACnet_List_Element_Data;
#[doc = " @brief AddListElement or RemoveListElement from an object list property\n @ingroup ObjHelpers\n @param list_element [in] Pointer to the BACnet_List_Element_Data structure,\n which is packed with the information from the request.\n @return The length of the apdu encoded or #BACNET_STATUS_ERROR or\n #BACNET_STATUS_ABORT or #BACNET_STATUS_REJECT."]
pub type list_element_function = ::std::option::Option<
    unsafe extern "C" fn(list_element: *mut BACNET_LIST_ELEMENT_DATA) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn list_element_encode_service_request(
        apdu: *mut u8,
        list_element: *mut BACNET_LIST_ELEMENT_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn list_element_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        list_element: *mut BACNET_LIST_ELEMENT_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn list_element_error_ack_encode(
        apdu: *mut u8,
        list_element: *mut BACNET_LIST_ELEMENT_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn list_element_error_ack_decode(
        apdu: *mut u8,
        apdu_size: u16,
        list_element: *mut BACNET_LIST_ELEMENT_DATA,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACNET_LSO_DATA {
    pub processId: u32,
    pub requestingSrc: BACNET_CHARACTER_STRING,
    pub operation: BACNET_LIFE_SAFETY_OPERATION,
    pub targetObject: BACNET_OBJECT_ID,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_BACNET_LSO_DATA() {
    const UNINIT: ::std::mem::MaybeUninit<BACNET_LSO_DATA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACNET_LSO_DATA>(),
        1504usize,
        concat!("Size of: ", stringify!(BACNET_LSO_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<BACNET_LSO_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(BACNET_LSO_DATA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_LSO_DATA),
            "::",
            stringify!(processId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestingSrc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_LSO_DATA),
            "::",
            stringify!(requestingSrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_LSO_DATA),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).targetObject) as usize - ptr as usize },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(BACNET_LSO_DATA),
            "::",
            stringify!(targetObject)
        )
    );
}
impl BACNET_LSO_DATA {
    #[inline]
    pub fn use_target(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_target(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(use_target: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_target: u8 = unsafe { ::std::mem::transmute(use_target) };
            use_target as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn lso_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        data: *mut BACNET_LSO_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lso_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_LSO_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcopylen(offset: usize, max: usize, len: usize) -> bool;
}
extern "C" {
    pub fn memcopy(
        dest: *mut ::std::os::raw::c_void,
        src: *mut ::std::os::raw::c_void,
        offset: usize,
        len: usize,
        max: usize,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Read_Property_Data {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub object_property: BACNET_PROPERTY_ID,
    pub array_index: BACNET_ARRAY_INDEX,
    pub application_data: *mut u8,
    pub application_data_len: ::std::os::raw::c_int,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[test]
fn bindgen_test_layout_BACnet_Read_Property_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Read_Property_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Read_Property_Data>(),
        40usize,
        concat!("Size of: ", stringify!(BACnet_Read_Property_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Read_Property_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Read_Property_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(object_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(application_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(application_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Property_Data),
            "::",
            stringify!(error_code)
        )
    );
}
pub type BACNET_READ_PROPERTY_DATA = BACnet_Read_Property_Data;
#[doc = " Reads one property for this object type of a given instance.\n A function template; @see device.c for assignment to object types.\n @ingroup ObjHelpers\n\n @param rp_data [in] Pointer to the BACnet_Read_Property_Data structure,\n                     which is packed with the information from the RP request.\n @return The length of the apdu encoded or -1 for error or\n         -2 for abort message."]
pub type read_property_function = ::std::option::Option<
    unsafe extern "C" fn(rp_data: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn rp_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_ack_encode_apdu_init(
        apdu: *mut u8,
        invoke_id: u8,
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_ack_encode_apdu_object_property_end(apdu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_int,
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rp_ack_fully_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_int,
        read_access_data: *mut BACnet_Read_Access_Data,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @file Property_List property encode decode helper"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct property_list_t {
    pub pList: *const ::std::os::raw::c_int,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_property_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<property_list_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<property_list_t>(),
        16usize,
        concat!("Size of: ", stringify!(property_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<property_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(property_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pList) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(property_list_t),
            "::",
            stringify!(pList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(property_list_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct special_property_list_t {
    pub Required: property_list_t,
    pub Optional: property_list_t,
    pub Proprietary: property_list_t,
}
#[test]
fn bindgen_test_layout_special_property_list_t() {
    const UNINIT: ::std::mem::MaybeUninit<special_property_list_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<special_property_list_t>(),
        48usize,
        concat!("Size of: ", stringify!(special_property_list_t))
    );
    assert_eq!(
        ::std::mem::align_of::<special_property_list_t>(),
        8usize,
        concat!("Alignment of ", stringify!(special_property_list_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Required) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(special_property_list_t),
            "::",
            stringify!(Required)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Optional) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(special_property_list_t),
            "::",
            stringify!(Optional)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Proprietary) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(special_property_list_t),
            "::",
            stringify!(Proprietary)
        )
    );
}
extern "C" {
    pub fn property_list_count(pList: *const ::std::os::raw::c_int) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn property_list_member(
        pList: *const ::std::os::raw::c_int,
        object_property: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn property_list_encode(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
        pListRequired: *const ::std::os::raw::c_int,
        pListOptional: *const ::std::os::raw::c_int,
        pListProprietary: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn property_list_common_encode(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
        device_instance_number: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn property_list_common(property: BACNET_PROPERTY_ID) -> bool;
}
extern "C" {
    pub fn property_list_optional(object_type: BACNET_OBJECT_TYPE) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn property_list_required(object_type: BACNET_OBJECT_TYPE) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn property_list_special(
        object_type: BACNET_OBJECT_TYPE,
        pPropertyList: *mut special_property_list_t,
    );
}
extern "C" {
    pub fn property_list_special_property(
        object_type: BACNET_OBJECT_TYPE,
        special_property: BACNET_PROPERTY_ID,
        index: ::std::os::raw::c_uint,
    ) -> BACNET_PROPERTY_ID;
}
extern "C" {
    pub fn property_list_special_count(
        object_type: BACNET_OBJECT_TYPE,
        special_property: BACNET_PROPERTY_ID,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Private_Transfer_Data {
    pub vendorID: u16,
    pub serviceNumber: u32,
    pub serviceParameters: *mut u8,
    pub serviceParametersLen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_BACnet_Private_Transfer_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Private_Transfer_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Private_Transfer_Data>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_Private_Transfer_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Private_Transfer_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Private_Transfer_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendorID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Private_Transfer_Data),
            "::",
            stringify!(vendorID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceNumber) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Private_Transfer_Data),
            "::",
            stringify!(serviceNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceParameters) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Private_Transfer_Data),
            "::",
            stringify!(serviceParameters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serviceParametersLen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Private_Transfer_Data),
            "::",
            stringify!(serviceParametersLen)
        )
    );
}
pub type BACNET_PRIVATE_TRANSFER_DATA = BACnet_Private_Transfer_Data;
extern "C" {
    pub fn ptransfer_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uptransfer_encode_apdu(
        apdu: *mut u8,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptransfer_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptransfer_error_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        error_class: BACNET_ERROR_CLASS,
        error_code: BACNET_ERROR_CODE,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptransfer_error_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        error_class: *mut BACNET_ERROR_CLASS,
        error_code: *mut BACNET_ERROR_CODE,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptransfer_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Reinitialize_Device_Data {
    pub state: BACNET_REINITIALIZED_STATE,
    pub password: BACNET_CHARACTER_STRING,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[test]
fn bindgen_test_layout_BACnet_Reinitialize_Device_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Reinitialize_Device_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Reinitialize_Device_Data>(),
        1496usize,
        concat!("Size of: ", stringify!(BACnet_Reinitialize_Device_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Reinitialize_Device_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Reinitialize_Device_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Reinitialize_Device_Data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Reinitialize_Device_Data),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Reinitialize_Device_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Reinitialize_Device_Data),
            "::",
            stringify!(error_code)
        )
    );
}
pub type BACNET_REINITIALIZE_DEVICE_DATA = BACnet_Reinitialize_Device_Data;
pub type reinitialize_device_function = ::std::option::Option<
    unsafe extern "C" fn(rd_data: *mut BACNET_REINITIALIZE_DEVICE_DATA) -> bool,
>;
extern "C" {
    pub fn rd_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        state: BACNET_REINITIALIZED_STATE,
        password: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rd_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        state: *mut BACNET_REINITIALIZED_STATE,
        password: *mut BACNET_CHARACTER_STRING,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Read_Range_Data {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub object_property: BACNET_PROPERTY_ID,
    pub array_index: BACNET_ARRAY_INDEX,
    pub application_data: *mut u8,
    pub application_data_len: ::std::os::raw::c_int,
    #[doc = "<  FIRST_ITEM, LAST_ITEM, MORE_ITEMS."]
    pub ResultFlags: BACNET_BIT_STRING,
    #[doc = "< Index, sequence or time based request."]
    pub RequestType: ::std::os::raw::c_int,
    #[doc = "< How much space the baggage takes in the response."]
    pub Overhead: ::std::os::raw::c_int,
    pub ItemCount: u32,
    pub FirstSequence: u32,
    pub Range: BACnet_Read_Range_Data__bindgen_ty_1,
    #[doc = "< SIGNED value as +ve vs -ve  is important."]
    pub Count: i32,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Read_Range_Data__bindgen_ty_1 {
    pub RefIndex: u32,
    pub RefSeqNum: u32,
    pub RefTime: BACNET_DATE_TIME,
}
#[test]
fn bindgen_test_layout_BACnet_Read_Range_Data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Read_Range_Data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Read_Range_Data__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Read_Range_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Read_Range_Data__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Read_Range_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefIndex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data__bindgen_ty_1),
            "::",
            stringify!(RefIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefSeqNum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data__bindgen_ty_1),
            "::",
            stringify!(RefSeqNum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RefTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data__bindgen_ty_1),
            "::",
            stringify!(RefTime)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Read_Range_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Read_Range_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Read_Range_Data>(),
        88usize,
        concat!("Size of: ", stringify!(BACnet_Read_Range_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Read_Range_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Read_Range_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(object_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(application_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(application_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResultFlags) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(ResultFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestType) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(RequestType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Overhead) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(Overhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemCount) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(ItemCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirstSequence) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(FirstSequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Range) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(Range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Count) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Range_Data),
            "::",
            stringify!(error_code)
        )
    );
}
pub type BACNET_READ_RANGE_DATA = BACnet_Read_Range_Data;
pub const BACNET_RESULT_FLAGS_RESULT_FLAG_FIRST_ITEM: BACNET_RESULT_FLAGS = 0;
pub const BACNET_RESULT_FLAGS_RESULT_FLAG_LAST_ITEM: BACNET_RESULT_FLAGS = 1;
pub const BACNET_RESULT_FLAGS_RESULT_FLAG_MORE_ITEMS: BACNET_RESULT_FLAGS = 2;
#[doc = " Bit String Enumerations"]
pub type BACNET_RESULT_FLAGS = ::std::os::raw::c_uint;
#[doc = " Define pointer to function type for handling ReadRange request.\nThis function will take the following parameters:\n- 1. A pointer to a buffer of at least MAX_APDU bytes to build the response in.\n- 2. A pointer to a BACNET_READ_RANGE_DATA structure with all the request\ninformation in it. The function is responsible for applying the request\nto the property in question and returning the response."]
pub type rr_handler_function = ::std::option::Option<
    unsafe extern "C" fn(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Structure to return the type of requests a given object property can\n accept and the address of the function to handle the request"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rrpropertyinfo {
    pub RequestTypes: ::std::os::raw::c_int,
    pub Handler: rr_handler_function,
}
#[test]
fn bindgen_test_layout_rrpropertyinfo() {
    const UNINIT: ::std::mem::MaybeUninit<rrpropertyinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rrpropertyinfo>(),
        16usize,
        concat!("Size of: ", stringify!(rrpropertyinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rrpropertyinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rrpropertyinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestTypes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rrpropertyinfo),
            "::",
            stringify!(RequestTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rrpropertyinfo),
            "::",
            stringify!(Handler)
        )
    );
}
#[doc = " Structure to return the type of requests a given object property can\n accept and the address of the function to handle the request"]
pub type RR_PROP_INFO = rrpropertyinfo;
#[doc = " Function template for ReadRange information retrieval function.\n A function template; @see device.c for assignment to object types.\n @ingroup ObjHelpers\n @param pRequest [in]\tInfo on the request.\n @param pInfo [out]   Where to write the response to.\n @return True on success, False on error or failure."]
pub type rr_info_function = ::std::option::Option<
    unsafe extern "C" fn(pRequest: *mut BACNET_READ_RANGE_DATA, pInfo: *mut RR_PROP_INFO) -> bool,
>;
extern "C" {
    pub fn rr_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        rrdata: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rr_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        rrdata: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rr_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        rrdata: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rr_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_int,
        rrdata: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reject_convert_error_code(error_code: BACNET_ERROR_CODE) -> BACNET_REJECT_REASON;
}
extern "C" {
    pub fn reject_convert_to_error_code(reject_code: BACNET_REJECT_REASON) -> BACNET_ERROR_CODE;
}
extern "C" {
    pub fn reject_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        reject_reason: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reject_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        invoke_id: *mut u8,
        reject_reason: *mut u8,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_RPM_Data {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub object_property: BACNET_PROPERTY_ID,
    pub array_index: BACNET_ARRAY_INDEX,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[test]
fn bindgen_test_layout_BACnet_RPM_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_RPM_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_RPM_Data>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_RPM_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_RPM_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_RPM_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_RPM_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_RPM_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_RPM_Data),
            "::",
            stringify!(object_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_RPM_Data),
            "::",
            stringify!(array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_RPM_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_RPM_Data),
            "::",
            stringify!(error_code)
        )
    );
}
pub type BACNET_RPM_DATA = BACnet_RPM_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Read_Access_Data {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub listOfProperties: *mut BACNET_PROPERTY_REFERENCE,
    pub next: *mut BACnet_Read_Access_Data,
}
#[test]
fn bindgen_test_layout_BACnet_Read_Access_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Read_Access_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Read_Access_Data>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_Read_Access_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Read_Access_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Read_Access_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Access_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Access_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listOfProperties) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Access_Data),
            "::",
            stringify!(listOfProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Read_Access_Data),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_READ_ACCESS_DATA = BACnet_Read_Access_Data;
#[doc = " Fetches the lists of properties (array of BACNET_PROPERTY_ID's) for this\n  object type, grouped by Required, Optional, and Proprietary.\n A function template; @see device.c for assignment to object types.\n @ingroup ObjHelpers\n\n @param pRequired [out] Pointer reference for the list of Required properties.\n @param pOptional [out] Pointer reference for the list of Optional properties.\n @param pProprietary [out] Pointer reference for the list of Proprietary\n                           properties for this BACNET_OBJECT_TYPE."]
pub type rpm_property_lists_function = ::std::option::Option<
    unsafe extern "C" fn(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    ),
>;
pub type rpm_object_property_lists_function = ::std::option::Option<
    unsafe extern "C" fn(
        object_type: BACNET_OBJECT_TYPE,
        pPropertyList: *mut special_property_list_t,
    ),
>;
extern "C" {
    pub fn rpm_encode_apdu_init(apdu: *mut u8, invoke_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_encode_apdu_object_begin(
        apdu: *mut u8,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_encode_apdu_object_property(
        apdu: *mut u8,
        object_property: BACNET_PROPERTY_ID,
        array_index: BACNET_ARRAY_INDEX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_encode_apdu_object_end(apdu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_encode_apdu(
        apdu: *mut u8,
        max_apdu: usize,
        invoke_id: u8,
        read_access_data: *mut BACNET_READ_ACCESS_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_decode_object_id(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        rpmdata: *mut BACNET_RPM_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_decode_object_end(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_decode_object_property(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        rpmdata: *mut BACNET_RPM_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_encode_apdu_init(apdu: *mut u8, invoke_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_encode_apdu_object_begin(
        apdu: *mut u8,
        rpmdata: *mut BACNET_RPM_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_encode_apdu_object_property(
        apdu: *mut u8,
        object_property: BACNET_PROPERTY_ID,
        array_index: BACNET_ARRAY_INDEX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_encode_apdu_object_property_value(
        apdu: *mut u8,
        application_data: *mut u8,
        application_data_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_encode_apdu_object_property_error(
        apdu: *mut u8,
        error_class: BACNET_ERROR_CLASS,
        error_code: BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_encode_apdu_object_end(apdu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_decode_object_id(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        object_type: *mut BACNET_OBJECT_TYPE,
        object_instance: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_decode_object_end(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_decode_object_property(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        object_property: *mut BACNET_PROPERTY_ID,
        array_index: *mut BACNET_ARRAY_INDEX,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Recipient_List {
    pub tag: u8,
    pub type_: BACnet_Recipient_List__bindgen_ty_1,
    pub next: *mut BACnet_Recipient_List,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Recipient_List__bindgen_ty_1 {
    pub device: BACNET_OBJECT_ID,
    pub address: BACNET_ADDRESS,
}
#[test]
fn bindgen_test_layout_BACnet_Recipient_List__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Recipient_List__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Recipient_List__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(BACnet_Recipient_List__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Recipient_List__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Recipient_List__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient_List__bindgen_ty_1),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient_List__bindgen_ty_1),
            "::",
            stringify!(address)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Recipient_List() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Recipient_List> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Recipient_List>(),
        32usize,
        concat!("Size of: ", stringify!(BACnet_Recipient_List))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Recipient_List>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Recipient_List))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient_List),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient_List),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Recipient_List),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_RECIPIENT_LIST = BACnet_Recipient_List;
extern "C" {
    pub fn timesync_utc_encode_apdu(
        apdu: *mut u8,
        my_date: *mut BACNET_DATE,
        my_time: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_encode_apdu(
        apdu: *mut u8,
        my_date: *mut BACNET_DATE,
        my_time: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_encode_apdu_service(
        apdu: *mut u8,
        service: BACNET_UNCONFIRMED_SERVICE,
        my_date: *mut BACNET_DATE,
        my_time: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        my_date: *mut BACNET_DATE,
        my_time: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_utc_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        my_date: *mut BACNET_DATE,
        my_time: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        my_date: *mut BACNET_DATE,
        my_time: *mut BACNET_TIME,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_encode_timesync_recipients(
        apdu: *mut u8,
        max_apdu: ::std::os::raw::c_uint,
        recipient: *mut BACNET_RECIPIENT_LIST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timesync_decode_timesync_recipients(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        recipient: *mut BACNET_RECIPIENT_LIST,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Who_Has_Data {
    pub low_limit: i32,
    pub high_limit: i32,
    pub is_object_name: bool,
    pub object: BACnet_Who_Has_Data__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Who_Has_Data__bindgen_ty_1 {
    pub identifier: BACNET_OBJECT_ID,
    pub name: BACNET_CHARACTER_STRING,
}
#[test]
fn bindgen_test_layout_BACnet_Who_Has_Data__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Who_Has_Data__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Who_Has_Data__bindgen_ty_1>(),
        1480usize,
        concat!("Size of: ", stringify!(BACnet_Who_Has_Data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Who_Has_Data__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Who_Has_Data__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Who_Has_Data__bindgen_ty_1),
            "::",
            stringify!(identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Who_Has_Data__bindgen_ty_1),
            "::",
            stringify!(name)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Who_Has_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Who_Has_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Who_Has_Data>(),
        1496usize,
        concat!("Size of: ", stringify!(BACnet_Who_Has_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Who_Has_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Who_Has_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_limit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Who_Has_Data),
            "::",
            stringify!(low_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).high_limit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Who_Has_Data),
            "::",
            stringify!(high_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_object_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Who_Has_Data),
            "::",
            stringify!(is_object_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Who_Has_Data),
            "::",
            stringify!(object)
        )
    );
}
pub type BACNET_WHO_HAS_DATA = BACnet_Who_Has_Data;
extern "C" {
    pub fn whohas_encode_apdu(
        apdu: *mut u8,
        data: *mut BACNET_WHO_HAS_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whohas_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_WHO_HAS_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whohas_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        data: *mut BACNET_WHO_HAS_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whois_encode_apdu(
        apdu: *mut u8,
        low_limit: i32,
        high_limit: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn whois_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        pLow_limit: *mut i32,
        pHigh_limit: *mut i32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @note: write property can have application tagged data, or context tagged data,\nor even complex data types (i.e. opening and closing tag around data).\nIt could also have more than one value or element."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Write_Property_Data {
    pub object_instance: u32,
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_property: BACNET_PROPERTY_ID,
    pub array_index: BACNET_ARRAY_INDEX,
    pub application_data: [u8; 1476usize],
    pub application_data_len: ::std::os::raw::c_int,
    pub priority: u8,
    pub error_class: BACNET_ERROR_CLASS,
    pub error_code: BACNET_ERROR_CODE,
}
#[test]
fn bindgen_test_layout_BACnet_Write_Property_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Write_Property_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Write_Property_Data>(),
        1508usize,
        concat!("Size of: ", stringify!(BACnet_Write_Property_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Write_Property_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_Write_Property_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_property) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(object_property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array_index) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(array_index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(application_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).application_data_len) as usize - ptr as usize },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(application_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_class) as usize - ptr as usize },
        1500usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(error_class)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_code) as usize - ptr as usize },
        1504usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Property_Data),
            "::",
            stringify!(error_code)
        )
    );
}
#[doc = " @note: write property can have application tagged data, or context tagged data,\nor even complex data types (i.e. opening and closing tag around data).\nIt could also have more than one value or element."]
pub type BACNET_WRITE_PROPERTY_DATA = BACnet_Write_Property_Data;
#[doc = " Attempts to write a new value to one property for this object type\n  of a given instance.\n A function template; @see device.c for assignment to object types.\n @ingroup ObjHelpers\n\n @param wp_data [in] Pointer to the BACnet_Write_Property_Data structure,\n                     which is packed with the information from the WP request.\n @return The length of the apdu encoded or -1 for error or\n         -2 for abort message."]
pub type write_property_function =
    ::std::option::Option<unsafe extern "C" fn(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool>;
extern "C" {
    pub fn wp_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wp_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn write_property_type_valid(
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        expected_tag: u8,
    ) -> bool;
}
extern "C" {
    pub fn write_property_string_valid(
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        len_max: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn write_property_empty_string_valid(
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        len_max: ::std::os::raw::c_int,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Write_Access_Data {
    pub object_type: BACNET_OBJECT_TYPE,
    pub object_instance: u32,
    pub listOfProperties: *mut BACNET_PROPERTY_VALUE,
    pub next: *mut BACnet_Write_Access_Data,
}
#[test]
fn bindgen_test_layout_BACnet_Write_Access_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Write_Access_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Write_Access_Data>(),
        24usize,
        concat!("Size of: ", stringify!(BACnet_Write_Access_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Write_Access_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Write_Access_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Access_Data),
            "::",
            stringify!(object_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object_instance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Access_Data),
            "::",
            stringify!(object_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listOfProperties) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Access_Data),
            "::",
            stringify!(listOfProperties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Write_Access_Data),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_WRITE_ACCESS_DATA = BACnet_Write_Access_Data;
extern "C" {
    pub fn wpm_decode_object_id(
        apdu: *mut u8,
        apdu_len: u16,
        data: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_decode_object_property(
        apdu: *mut u8,
        apdu_len: u16,
        wpm_data: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_encode_apdu_init(apdu: *mut u8, invoke_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_encode_apdu_object_begin(
        apdu: *mut u8,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_encode_apdu_object_end(apdu: *mut u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_encode_apdu_object_property(
        apdu: *mut u8,
        wpdata: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_encode_apdu(
        apdu: *mut u8,
        max_apdu: usize,
        invoke_id: u8,
        write_access_data: *mut BACNET_WRITE_ACCESS_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_ack_encode_apdu_init(apdu: *mut u8, invoke_id: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_error_ack_encode_apdu(
        apdu: *mut u8,
        invoke_id: u8,
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wpm_error_ack_decode_apdu(
        apdu: *mut u8,
        apdu_size: u16,
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arcnet_valid() -> bool;
}
extern "C" {
    pub fn arcnet_cleanup();
}
extern "C" {
    pub fn arcnet_init(interface_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn arcnet_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arcnet_receive(
        src: *mut BACNET_ADDRESS,
        pdu: *mut u8,
        max_pdu: u16,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn arcnet_get_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn arcnet_get_broadcast_address(dest: *mut BACNET_ADDRESS);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_Security_Wrapper {
    pub payload_net_or_bvll_flag: bool,
    pub encrypted_flag: bool,
    pub authentication_flag: bool,
    pub do_not_unwrap_flag: bool,
    pub do_not_decrypt_flag: bool,
    pub non_trusted_source_flag: bool,
    pub secured_by_router_flag: bool,
    pub key_revision: u8,
    pub key_identifier: u16,
    pub source_device_instance: u32,
    pub message_id: u32,
    pub timestamp: u32,
    pub destination_device_instance: u32,
    pub dnet: u16,
    pub dlen: u8,
    pub dadr: [u8; 7usize],
    pub snet: u16,
    pub slen: u8,
    pub sadr: [u8; 7usize],
    pub authentication_mechanism: u8,
    pub user_id: u16,
    pub user_role: u8,
    pub authentication_data_length: u16,
    pub vendor_id: u16,
    pub authentication_data: [u8; 16usize],
    pub service_data_len: u16,
    pub service_data: *mut u8,
    pub service_type: u8,
    pub padding_len: u16,
    pub padding: [u8; 16usize],
    pub signature: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_BACnet_Security_Wrapper() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Security_Wrapper> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Security_Wrapper>(),
        128usize,
        concat!("Size of: ", stringify!(BACnet_Security_Wrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Security_Wrapper>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Security_Wrapper))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_net_or_bvll_flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(payload_net_or_bvll_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encrypted_flag) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(encrypted_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_flag) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(authentication_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_not_unwrap_flag) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(do_not_unwrap_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).do_not_decrypt_flag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(do_not_decrypt_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).non_trusted_source_flag) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(non_trusted_source_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secured_by_router_flag) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(secured_by_router_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_revision) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(key_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_identifier) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(key_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_device_instance) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(source_device_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_id) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(message_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).destination_device_instance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(destination_device_instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dnet) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(dnet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dlen) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(dlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dadr) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(dadr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).snet) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(snet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).slen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(slen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sadr) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(sadr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_mechanism) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(authentication_mechanism)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_id) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(user_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_role) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(user_role)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_data_length) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(authentication_data_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_data) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(authentication_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_data_len) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(service_data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_data) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(service_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).service_type) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(service_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding_len) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(padding_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signature) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Security_Wrapper),
            "::",
            stringify!(signature)
        )
    );
}
pub type BACNET_SECURITY_WRAPPER = BACnet_Security_Wrapper;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Challenge_Request {
    pub message_challenge: u8,
    pub orig_message_id: u32,
    pub orig_timestamp: u32,
}
#[test]
fn bindgen_test_layout_Challenge_Request() {
    const UNINIT: ::std::mem::MaybeUninit<Challenge_Request> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Challenge_Request>(),
        12usize,
        concat!("Size of: ", stringify!(Challenge_Request))
    );
    assert_eq!(
        ::std::mem::align_of::<Challenge_Request>(),
        4usize,
        concat!("Alignment of ", stringify!(Challenge_Request))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message_challenge) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Challenge_Request),
            "::",
            stringify!(message_challenge)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_message_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Challenge_Request),
            "::",
            stringify!(orig_message_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Challenge_Request),
            "::",
            stringify!(orig_timestamp)
        )
    );
}
pub type BACNET_CHALLENGE_REQUEST = Challenge_Request;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Security_Payload {
    pub payload_length: u16,
    pub payload: *mut u8,
}
#[test]
fn bindgen_test_layout_Security_Payload() {
    const UNINIT: ::std::mem::MaybeUninit<Security_Payload> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Security_Payload>(),
        16usize,
        concat!("Size of: ", stringify!(Security_Payload))
    );
    assert_eq!(
        ::std::mem::align_of::<Security_Payload>(),
        8usize,
        concat!("Alignment of ", stringify!(Security_Payload))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Payload),
            "::",
            stringify!(payload_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Payload),
            "::",
            stringify!(payload)
        )
    );
}
pub type BACNET_SECURITY_PAYLOAD = Security_Payload;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Bad_Timestamp {
    pub expected_timestamp: u32,
}
#[test]
fn bindgen_test_layout_Bad_Timestamp() {
    const UNINIT: ::std::mem::MaybeUninit<Bad_Timestamp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Bad_Timestamp>(),
        4usize,
        concat!("Size of: ", stringify!(Bad_Timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<Bad_Timestamp>(),
        4usize,
        concat!("Alignment of ", stringify!(Bad_Timestamp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expected_timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Bad_Timestamp),
            "::",
            stringify!(expected_timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cannot_Use_Key {
    pub key: u16,
}
#[test]
fn bindgen_test_layout_Cannot_Use_Key() {
    const UNINIT: ::std::mem::MaybeUninit<Cannot_Use_Key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Cannot_Use_Key>(),
        2usize,
        concat!("Size of: ", stringify!(Cannot_Use_Key))
    );
    assert_eq!(
        ::std::mem::align_of::<Cannot_Use_Key>(),
        2usize,
        concat!("Alignment of ", stringify!(Cannot_Use_Key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Cannot_Use_Key),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Incorrect_Key {
    pub number_of_keys: u8,
    pub keys: [u16; 255usize],
}
#[test]
fn bindgen_test_layout_Incorrect_Key() {
    const UNINIT: ::std::mem::MaybeUninit<Incorrect_Key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Incorrect_Key>(),
        512usize,
        concat!("Size of: ", stringify!(Incorrect_Key))
    );
    assert_eq!(
        ::std::mem::align_of::<Incorrect_Key>(),
        2usize,
        concat!("Alignment of ", stringify!(Incorrect_Key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_of_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Incorrect_Key),
            "::",
            stringify!(number_of_keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Incorrect_Key),
            "::",
            stringify!(keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unknown_Authentication_Type {
    pub original_authentication_type: u8,
    pub vendor_id: u16,
}
#[test]
fn bindgen_test_layout_Unknown_Authentication_Type() {
    const UNINIT: ::std::mem::MaybeUninit<Unknown_Authentication_Type> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Unknown_Authentication_Type>(),
        4usize,
        concat!("Size of: ", stringify!(Unknown_Authentication_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<Unknown_Authentication_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(Unknown_Authentication_Type))
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).original_authentication_type) as usize - ptr as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Unknown_Authentication_Type),
            "::",
            stringify!(original_authentication_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Unknown_Authentication_Type),
            "::",
            stringify!(vendor_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unknown_Key {
    pub original_key: u16,
}
#[test]
fn bindgen_test_layout_Unknown_Key() {
    const UNINIT: ::std::mem::MaybeUninit<Unknown_Key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Unknown_Key>(),
        2usize,
        concat!("Size of: ", stringify!(Unknown_Key))
    );
    assert_eq!(
        ::std::mem::align_of::<Unknown_Key>(),
        2usize,
        concat!("Alignment of ", stringify!(Unknown_Key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Unknown_Key),
            "::",
            stringify!(original_key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unknown_Key_Revision {
    pub original_key_revision: u8,
}
#[test]
fn bindgen_test_layout_Unknown_Key_Revision() {
    const UNINIT: ::std::mem::MaybeUninit<Unknown_Key_Revision> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Unknown_Key_Revision>(),
        1usize,
        concat!("Size of: ", stringify!(Unknown_Key_Revision))
    );
    assert_eq!(
        ::std::mem::align_of::<Unknown_Key_Revision>(),
        1usize,
        concat!("Alignment of ", stringify!(Unknown_Key_Revision))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).original_key_revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Unknown_Key_Revision),
            "::",
            stringify!(original_key_revision)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Too_Many_Keys {
    pub max_num_of_keys: u8,
}
#[test]
fn bindgen_test_layout_Too_Many_Keys() {
    const UNINIT: ::std::mem::MaybeUninit<Too_Many_Keys> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Too_Many_Keys>(),
        1usize,
        concat!("Size of: ", stringify!(Too_Many_Keys))
    );
    assert_eq!(
        ::std::mem::align_of::<Too_Many_Keys>(),
        1usize,
        concat!("Alignment of ", stringify!(Too_Many_Keys))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_num_of_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Too_Many_Keys),
            "::",
            stringify!(max_num_of_keys)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Invalid_Key_Data {
    pub key: u16,
}
#[test]
fn bindgen_test_layout_Invalid_Key_Data() {
    const UNINIT: ::std::mem::MaybeUninit<Invalid_Key_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Invalid_Key_Data>(),
        2usize,
        concat!("Size of: ", stringify!(Invalid_Key_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<Invalid_Key_Data>(),
        2usize,
        concat!("Alignment of ", stringify!(Invalid_Key_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Invalid_Key_Data),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Security_Response {
    pub response_code: u16,
    pub orig_message_id: u32,
    pub orig_timestamp: u32,
    pub response: Security_Response__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Security_Response__bindgen_ty_1 {
    pub bad_timestamp: Bad_Timestamp,
    pub cannot_use_key: Cannot_Use_Key,
    pub incorrect_key: Incorrect_Key,
    pub unknown_authentication_type: Unknown_Authentication_Type,
    pub unknown_key: Unknown_Key,
    pub unknown_key_revision: Unknown_Key_Revision,
    pub too_many_keys: Too_Many_Keys,
    pub invalid_key_data: Invalid_Key_Data,
}
#[test]
fn bindgen_test_layout_Security_Response__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Security_Response__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Security_Response__bindgen_ty_1>(),
        512usize,
        concat!("Size of: ", stringify!(Security_Response__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Security_Response__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(Security_Response__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bad_timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(bad_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cannot_use_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(cannot_use_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).incorrect_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(incorrect_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknown_authentication_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(unknown_authentication_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknown_key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(unknown_key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unknown_key_revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(unknown_key_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).too_many_keys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(too_many_keys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invalid_key_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response__bindgen_ty_1),
            "::",
            stringify!(invalid_key_data)
        )
    );
}
#[test]
fn bindgen_test_layout_Security_Response() {
    const UNINIT: ::std::mem::MaybeUninit<Security_Response> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Security_Response>(),
        524usize,
        concat!("Size of: ", stringify!(Security_Response))
    );
    assert_eq!(
        ::std::mem::align_of::<Security_Response>(),
        4usize,
        concat!("Alignment of ", stringify!(Security_Response))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response),
            "::",
            stringify!(response_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_message_id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response),
            "::",
            stringify!(orig_message_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).orig_timestamp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response),
            "::",
            stringify!(orig_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).response) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Security_Response),
            "::",
            stringify!(response)
        )
    );
}
pub type BACNET_SECURITY_RESPONSE = Security_Response;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Request_Key_Update {
    pub set_1_key_revision: u8,
    pub set_1_activation_time: u32,
    pub set_1_expiration_time: u32,
    pub set_2_key_revision: u8,
    pub set_2_activation_time: u32,
    pub set_2_expiration_time: u32,
    pub distribution_key_revision: u8,
}
#[test]
fn bindgen_test_layout_Request_Key_Update() {
    const UNINIT: ::std::mem::MaybeUninit<Request_Key_Update> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Request_Key_Update>(),
        28usize,
        concat!("Size of: ", stringify!(Request_Key_Update))
    );
    assert_eq!(
        ::std::mem::align_of::<Request_Key_Update>(),
        4usize,
        concat!("Alignment of ", stringify!(Request_Key_Update))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_1_key_revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(set_1_key_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_1_activation_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(set_1_activation_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_1_expiration_time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(set_1_expiration_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_2_key_revision) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(set_2_key_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_2_activation_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(set_2_activation_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_2_expiration_time) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(set_2_expiration_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distribution_key_revision) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Key_Update),
            "::",
            stringify!(distribution_key_revision)
        )
    );
}
pub type BACNET_REQUEST_KEY_UPDATE = Request_Key_Update;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Key_Entry {
    pub key_identifier: u16,
    pub key_len: u8,
    pub key: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_Key_Entry() {
    const UNINIT: ::std::mem::MaybeUninit<Key_Entry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Key_Entry>(),
        52usize,
        concat!("Size of: ", stringify!(Key_Entry))
    );
    assert_eq!(
        ::std::mem::align_of::<Key_Entry>(),
        2usize,
        concat!("Alignment of ", stringify!(Key_Entry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Key_Entry),
            "::",
            stringify!(key_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_len) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Key_Entry),
            "::",
            stringify!(key_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Key_Entry),
            "::",
            stringify!(key)
        )
    );
}
pub type BACNET_KEY_ENTRY = Key_Entry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Update_Key_Set {
    pub set_rae: [bool; 2usize],
    pub set_ck: [bool; 2usize],
    pub set_clr: [bool; 2usize],
    pub more: bool,
    pub remove: bool,
    pub set_key_revision: [u8; 2usize],
    pub set_activation_time: [u32; 2usize],
    pub set_expiration_time: [u32; 2usize],
    pub set_key_count: [u8; 2usize],
    pub set_keys: [[BACNET_KEY_ENTRY; 32usize]; 2usize],
}
#[test]
fn bindgen_test_layout_Update_Key_Set() {
    const UNINIT: ::std::mem::MaybeUninit<Update_Key_Set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Update_Key_Set>(),
        3360usize,
        concat!("Size of: ", stringify!(Update_Key_Set))
    );
    assert_eq!(
        ::std::mem::align_of::<Update_Key_Set>(),
        4usize,
        concat!("Alignment of ", stringify!(Update_Key_Set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_rae) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_rae)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_ck) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_ck)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_clr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_clr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).more) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(more)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_key_revision) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_key_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_activation_time) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_activation_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_expiration_time) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_expiration_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_key_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_key_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).set_keys) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Key_Set),
            "::",
            stringify!(set_keys)
        )
    );
}
pub type BACNET_UPDATE_KEY_SET = Update_Key_Set;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Update_Distribution_Key {
    pub key_revision: u8,
    pub key: BACNET_KEY_ENTRY,
}
#[test]
fn bindgen_test_layout_Update_Distribution_Key() {
    const UNINIT: ::std::mem::MaybeUninit<Update_Distribution_Key> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Update_Distribution_Key>(),
        54usize,
        concat!("Size of: ", stringify!(Update_Distribution_Key))
    );
    assert_eq!(
        ::std::mem::align_of::<Update_Distribution_Key>(),
        2usize,
        concat!("Alignment of ", stringify!(Update_Distribution_Key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key_revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Distribution_Key),
            "::",
            stringify!(key_revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Update_Distribution_Key),
            "::",
            stringify!(key)
        )
    );
}
pub type BACNET_UPDATE_DISTRIBUTION_KEY = Update_Distribution_Key;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Request_Master_Key {
    pub no_supported_algorithms: u8,
    pub es_algorithms: [u8; 255usize],
}
#[test]
fn bindgen_test_layout_Request_Master_Key() {
    const UNINIT: ::std::mem::MaybeUninit<Request_Master_Key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Request_Master_Key>(),
        256usize,
        concat!("Size of: ", stringify!(Request_Master_Key))
    );
    assert_eq!(
        ::std::mem::align_of::<Request_Master_Key>(),
        1usize,
        concat!("Alignment of ", stringify!(Request_Master_Key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).no_supported_algorithms) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Master_Key),
            "::",
            stringify!(no_supported_algorithms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).es_algorithms) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Request_Master_Key),
            "::",
            stringify!(es_algorithms)
        )
    );
}
pub type BACNET_REQUEST_MASTER_KEY = Request_Master_Key;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Set_Master_Key {
    pub key: BACNET_KEY_ENTRY,
}
#[test]
fn bindgen_test_layout_Set_Master_Key() {
    const UNINIT: ::std::mem::MaybeUninit<Set_Master_Key> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Set_Master_Key>(),
        52usize,
        concat!("Size of: ", stringify!(Set_Master_Key))
    );
    assert_eq!(
        ::std::mem::align_of::<Set_Master_Key>(),
        2usize,
        concat!("Alignment of ", stringify!(Set_Master_Key))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Set_Master_Key),
            "::",
            stringify!(key)
        )
    );
}
pub type BACNET_SET_MASTER_KEY = Set_Master_Key;
extern "C" {
    pub fn key_algorithm(id: u16) -> BACNET_KEY_IDENTIFIER_ALGORITHM;
}
extern "C" {
    pub fn key_number(id: u16) -> BACNET_KEY_IDENTIFIER_KEY_NUMBER;
}
extern "C" {
    pub fn bacnet_master_key_set(key: *mut BACNET_SET_MASTER_KEY) -> BACNET_SECURITY_RESPONSE_CODE;
}
extern "C" {
    pub fn bacnet_distribution_key_update(
        key: *mut BACNET_UPDATE_DISTRIBUTION_KEY,
    ) -> BACNET_SECURITY_RESPONSE_CODE;
}
extern "C" {
    pub fn bacnet_key_set_update(
        update_key_sets: *mut BACNET_UPDATE_KEY_SET,
    ) -> BACNET_SECURITY_RESPONSE_CODE;
}
extern "C" {
    pub fn bacnet_find_key(
        revision: u8,
        key: *mut BACNET_KEY_ENTRY,
    ) -> BACNET_SECURITY_RESPONSE_CODE;
}
extern "C" {
    pub fn key_sign_msg(
        key: *mut BACNET_KEY_ENTRY,
        msg: *mut u8,
        msg_len: u32,
        signature: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_encrypt_msg(
        key: *mut BACNET_KEY_ENTRY,
        msg: *mut u8,
        msg_len: u32,
        signature: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn key_decrypt_msg(
        key: *mut BACNET_KEY_ENTRY,
        msg: *mut u8,
        msg_len: u32,
        signature: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn key_set_padding(
        key: *mut BACNET_KEY_ENTRY,
        enc_len: ::std::os::raw::c_int,
        padding_len: *mut u16,
        padding: *mut u8,
    );
}
extern "C" {
    pub fn encode_challenge_request(
        apdu: *mut u8,
        bc_req: *mut BACNET_CHALLENGE_REQUEST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_security_payload(
        apdu: *mut u8,
        payload: *mut BACNET_SECURITY_PAYLOAD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_security_response(
        apdu: *mut u8,
        resp: *mut BACNET_SECURITY_RESPONSE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_request_key_update(
        apdu: *mut u8,
        req: *mut BACNET_REQUEST_KEY_UPDATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_key_entry(apdu: *mut u8, entry: *mut BACNET_KEY_ENTRY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_update_key_set(
        apdu: *mut u8,
        key_set: *mut BACNET_UPDATE_KEY_SET,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_update_distribution_key(
        apdu: *mut u8,
        dist_key: *mut BACNET_UPDATE_DISTRIBUTION_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_request_master_key(
        apdu: *mut u8,
        req_master_key: *mut BACNET_REQUEST_MASTER_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn encode_set_master_key(
        apdu: *mut u8,
        set_master_key: *mut BACNET_SET_MASTER_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_challenge_request_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        bc_req: *mut BACNET_CHALLENGE_REQUEST,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_security_payload_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        payload: *mut BACNET_SECURITY_PAYLOAD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_security_response_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        resp: *mut BACNET_SECURITY_RESPONSE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_request_key_update_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        req: *mut BACNET_REQUEST_KEY_UPDATE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_key_entry_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        entry: *mut BACNET_KEY_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_update_key_set_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        key_set: *mut BACNET_UPDATE_KEY_SET,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_update_distribution_key_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        dist_key: *mut BACNET_UPDATE_DISTRIBUTION_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_request_master_key_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        req_master_key: *mut BACNET_REQUEST_MASTER_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn decode_set_master_key_safe(
        apdu: *mut u8,
        apdu_len_remaining: u32,
        set_master_key: *mut BACNET_SET_MASTER_KEY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip_init(ifname: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn bip_set_interface(ifname: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn bip_cleanup();
}
extern "C" {
    pub fn bip_valid() -> bool;
}
extern "C" {
    pub fn bip_get_broadcast_address(dest: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn bip_get_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn bip_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip_send_mpdu(
        dest: *mut BACNET_IP_ADDRESS,
        mtu: *mut u8,
        mtu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip_receive(
        src: *mut BACNET_ADDRESS,
        pdu: *mut u8,
        max_pdu: u16,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn bip_set_port(port: u16);
}
extern "C" {
    pub fn bip_port_changed() -> bool;
}
extern "C" {
    pub fn bip_get_port() -> u16;
}
extern "C" {
    pub fn bip_set_addr(addr: *mut BACNET_IP_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip_get_addr(addr: *mut BACNET_IP_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip_get_addr_by_name(
        host_name: *const ::std::os::raw::c_char,
        addr: *mut BACNET_IP_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bip_set_broadcast_addr(addr: *mut BACNET_IP_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip_get_broadcast_addr(addr: *mut BACNET_IP_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip_set_subnet_prefix(prefix: u8) -> bool;
}
extern "C" {
    pub fn bip_get_subnet_prefix() -> u8;
}
extern "C" {
    pub fn bip_debug_enable();
}
extern "C" {
    pub fn bip_debug_disable();
}
extern "C" {
    pub fn bip_get_socket() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip_get_broadcast_socket() -> ::std::os::raw::c_int;
}
#[doc = " BACnet IPv6 Address\n\n Data link layer addressing between B/IPv6 nodes consists of a 128-bit\n IPv6 address followed by a two-octet UDP port number (both of which\n shall be transmitted with the most significant octet first).\n This address shall be referred to as a B/IPv6 address.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP6_Address {
    pub address: [u8; 16usize],
    pub port: u16,
}
#[test]
fn bindgen_test_layout_BACnet_IP6_Address() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP6_Address> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP6_Address>(),
        18usize,
        concat!("Size of: ", stringify!(BACnet_IP6_Address))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP6_Address>(),
        2usize,
        concat!("Alignment of ", stringify!(BACnet_IP6_Address))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Address),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Address),
            "::",
            stringify!(port)
        )
    );
}
#[doc = " BACnet IPv6 Address\n\n Data link layer addressing between B/IPv6 nodes consists of a 128-bit\n IPv6 address followed by a two-octet UDP port number (both of which\n shall be transmitted with the most significant octet first).\n This address shall be referred to as a B/IPv6 address.\n @{"]
pub type BACNET_IP6_ADDRESS = BACnet_IP6_Address;
#[doc = " BACnet /IPv6 Broadcast Distribution Table Format\n\n The BDT shall consist of either the eighteen-octet B/IPv6 address\n of the peer BBMD or the combination of the fully qualified\n domain name service (DNS) entry and UDP port that resolves to\n the B/IPv6 address of the peer BBMD. The Broadcast\n Distribution Table shall not contain an entry for the BBMD in\n which the BDT resides.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP6_Broadcast_Distribution_Table_Entry {
    pub valid: bool,
    pub bip6_address: BACNET_IP6_ADDRESS,
    pub next: *mut BACnet_IP6_Broadcast_Distribution_Table_Entry,
}
#[test]
fn bindgen_test_layout_BACnet_IP6_Broadcast_Distribution_Table_Entry() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP6_Broadcast_Distribution_Table_Entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP6_Broadcast_Distribution_Table_Entry>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_IP6_Broadcast_Distribution_Table_Entry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP6_Broadcast_Distribution_Table_Entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_IP6_Broadcast_Distribution_Table_Entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bip6_address) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(bip6_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Broadcast_Distribution_Table_Entry),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " BACnet /IPv6 Broadcast Distribution Table Format\n\n The BDT shall consist of either the eighteen-octet B/IPv6 address\n of the peer BBMD or the combination of the fully qualified\n domain name service (DNS) entry and UDP port that resolves to\n the B/IPv6 address of the peer BBMD. The Broadcast\n Distribution Table shall not contain an entry for the BBMD in\n which the BDT resides.\n @{"]
pub type BACNET_IP6_BROADCAST_DISTRIBUTION_TABLE_ENTRY =
    BACnet_IP6_Broadcast_Distribution_Table_Entry;
#[doc = " Foreign Device Table (FDT)\n\n Each entry shall contain the B/IPv6 address and the TTL of the\n registered foreign device.\n\n Each entry shall consist of the eighteen-octet B/IPv6 address of the\n registrant; the 2-octet Time-to-Live value supplied at the time of\n registration; and a 2-octet value representing the number of seconds\n remaining before the BBMD will purge the registrant's FDT entry if no\n re-registration occurs. The number of seconds remaining shall be\n initialized to the 2-octet Time-to-Live value supplied at the time\n of registration plus 30 seconds (see U.4.5.2), with a maximum of 65535.\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_IP6_Foreign_Device_Table_Entry {
    pub valid: bool,
    pub bip6_address: BACNET_IP6_ADDRESS,
    pub ttl_seconds: u16,
    pub ttl_seconds_remaining: u16,
    pub next: *mut BACnet_IP6_Foreign_Device_Table_Entry,
}
#[test]
fn bindgen_test_layout_BACnet_IP6_Foreign_Device_Table_Entry() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_IP6_Foreign_Device_Table_Entry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_IP6_Foreign_Device_Table_Entry>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_IP6_Foreign_Device_Table_Entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry),
            "::",
            stringify!(valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bip6_address) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry),
            "::",
            stringify!(bip6_address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl_seconds) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry),
            "::",
            stringify!(ttl_seconds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttl_seconds_remaining) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry),
            "::",
            stringify!(ttl_seconds_remaining)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_IP6_Foreign_Device_Table_Entry),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Foreign Device Table (FDT)\n\n Each entry shall contain the B/IPv6 address and the TTL of the\n registered foreign device.\n\n Each entry shall consist of the eighteen-octet B/IPv6 address of the\n registrant; the 2-octet Time-to-Live value supplied at the time of\n registration; and a 2-octet value representing the number of seconds\n remaining before the BBMD will purge the registrant's FDT entry if no\n re-registration occurs. The number of seconds remaining shall be\n initialized to the 2-octet Time-to-Live value supplied at the time\n of registration plus 30 seconds (see U.4.5.2), with a maximum of 65535.\n @{"]
pub type BACNET_IP6_FOREIGN_DEVICE_TABLE_ENTRY = BACnet_IP6_Foreign_Device_Table_Entry;
extern "C" {
    pub fn bvlc6_encode_address(
        pdu: *mut u8,
        pdu_size: u16,
        ip6_address: *mut BACNET_IP6_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_address(
        pdu: *mut u8,
        pdu_len: u16,
        ip6_address: *mut BACNET_IP6_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_address_copy(dst: *mut BACNET_IP6_ADDRESS, src: *mut BACNET_IP6_ADDRESS) -> bool;
}
extern "C" {
    pub fn bvlc6_address_different(
        dst: *mut BACNET_IP6_ADDRESS,
        src: *mut BACNET_IP6_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn bvlc6_address_to_ascii(
        addr: *mut BACNET_IP6_ADDRESS,
        buf: *mut ::std::os::raw::c_char,
        buf_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_address_from_ascii(
        addr: *mut BACNET_IP6_ADDRESS,
        addrstr: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn bvlc6_address_set(
        addr: *mut BACNET_IP6_ADDRESS,
        addr0: u16,
        addr1: u16,
        addr2: u16,
        addr3: u16,
        addr4: u16,
        addr5: u16,
        addr6: u16,
        addr7: u16,
    ) -> bool;
}
extern "C" {
    pub fn bvlc6_address_get(
        addr: *mut BACNET_IP6_ADDRESS,
        addr0: *mut u16,
        addr1: *mut u16,
        addr2: *mut u16,
        addr3: *mut u16,
        addr4: *mut u16,
        addr5: *mut u16,
        addr6: *mut u16,
        addr7: *mut u16,
    ) -> bool;
}
extern "C" {
    pub fn bvlc6_vmac_address_set(addr: *mut BACNET_ADDRESS, device_id: u32) -> bool;
}
extern "C" {
    pub fn bvlc6_vmac_address_get(addr: *mut BACNET_ADDRESS, device_id: *mut u32) -> bool;
}
extern "C" {
    pub fn bvlc6_encode_header(
        pdu: *mut u8,
        pdu_size: u16,
        message_type: u8,
        length: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_header(
        pdu: *mut u8,
        pdu_len: u16,
        message_type: *mut u8,
        length: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_result(
        pdu: *mut u8,
        pdu_size: u16,
        vmac: u32,
        result_code: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_result(
        pdu: *mut u8,
        pdu_len: u16,
        vmac: *mut u32,
        result_code: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_original_unicast(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        vmac_dst: u32,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_original_unicast(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        vmac_dst: *mut u32,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_original_broadcast(
        pdu: *mut u8,
        pdu_size: u16,
        vmac: u32,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_original_broadcast(
        pdu: *mut u8,
        pdu_len: u16,
        vmac: *mut u32,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_address_resolution(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        vmac_target: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_address_resolution(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        vmac_target: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_forwarded_address_resolution(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        vmac_target: u32,
        bip6_address: *mut BACNET_IP6_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_forwarded_address_resolution(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        vmac_target: *mut u32,
        bip6_address: *mut BACNET_IP6_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_address_resolution_ack(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        vmac_dst: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_address_resolution_ack(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        vmac_dst: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_virtual_address_resolution(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_virtual_address_resolution(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_virtual_address_resolution_ack(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        vmac_dst: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_virtual_address_resolution_ack(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        vmac_dst: *mut u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_forwarded_npdu(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        address: *mut BACNET_IP6_ADDRESS,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_forwarded_npdu(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        address: *mut BACNET_IP6_ADDRESS,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_register_foreign_device(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        ttl_seconds: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_register_foreign_device(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        ttl_seconds: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_delete_foreign_device(
        pdu: *mut u8,
        pdu_size: u16,
        vmac_src: u32,
        bip6_address: *mut BACNET_IP6_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_delete_foreign_device(
        pdu: *mut u8,
        pdu_len: u16,
        vmac_src: *mut u32,
        bip6_address: *mut BACNET_IP6_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_secure_bvll(
        pdu: *mut u8,
        pdu_size: u16,
        sbuf: *mut u8,
        sbuf_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_secure_bvll(
        pdu: *mut u8,
        pdu_len: u16,
        sbuf: *mut u8,
        sbuf_size: u16,
        sbuf_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_encode_distribute_broadcast_to_network(
        pdu: *mut u8,
        pdu_size: u16,
        vmac: u32,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_decode_distribute_broadcast_to_network(
        pdu: *mut u8,
        pdu_len: u16,
        vmac: *mut u32,
        npdu: *mut u8,
        npdu_size: u16,
        npdu_len: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip6_init(ifname: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn bip6_cleanup();
}
extern "C" {
    pub fn bip6_get_broadcast_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn bip6_get_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn bip6_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip6_receive(
        src: *mut BACNET_ADDRESS,
        pdu: *mut u8,
        max_pdu: u16,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn bip6_set_interface(ifname: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn bip6_address_match_self(addr: *mut BACNET_IP6_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip6_set_addr(addr: *mut BACNET_IP6_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip6_get_addr(addr: *mut BACNET_IP6_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip6_set_port(port: u16);
}
extern "C" {
    pub fn bip6_get_port() -> u16;
}
extern "C" {
    pub fn bip6_set_broadcast_addr(addr: *mut BACNET_IP6_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip6_get_broadcast_addr(addr: *mut BACNET_IP6_ADDRESS) -> bool;
}
extern "C" {
    pub fn bip6_send_mpdu(
        addr: *mut BACNET_IP6_ADDRESS,
        mtu: *mut u8,
        mtu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bip6_send_pdu_queue_empty() -> bool;
}
extern "C" {
    pub fn bip6_receive_callback();
}
extern "C" {
    pub fn bip6_debug_enable();
}
extern "C" {
    pub fn cobs_encode(
        buffer: *mut u8,
        buffer_size: usize,
        from: *const u8,
        length: usize,
        mask: u8,
    ) -> usize;
}
extern "C" {
    pub fn cobs_frame_encode(
        buffer: *mut u8,
        buffer_size: usize,
        from: *const u8,
        length: usize,
    ) -> usize;
}
extern "C" {
    pub fn cobs_decode(
        buffer: *mut u8,
        buffer_size: usize,
        from: *const u8,
        length: usize,
        mask: u8,
    ) -> usize;
}
extern "C" {
    pub fn cobs_frame_decode(
        buffer: *mut u8,
        buffer_size: usize,
        from: *const u8,
        length: usize,
    ) -> usize;
}
extern "C" {
    pub fn cobs_crc32k(dataValue: u8, crc: u32) -> u32;
}
extern "C" {
    pub fn cobs_crc32k_encode(buffer: *mut u8, buffer_size: usize, crc: u32) -> usize;
}
extern "C" {
    pub fn CRC_Calc_Header(dataValue: u8, crcValue: u8) -> u8;
}
extern "C" {
    pub fn CRC_Calc_Data(dataValue: u8, crcValue: u16) -> u16;
}
extern "C" {
    pub fn bvlc_handler(
        addr: *mut BACNET_IP_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_broadcast_handler(
        addr: *mut BACNET_IP_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_bbmd_enabled_handler(
        addr: *mut BACNET_IP_ADDRESS,
        src: *mut BACNET_ADDRESS,
        mtu: *mut u8,
        mtu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_bbmd_disabled_handler(
        addr: *mut BACNET_IP_ADDRESS,
        src: *mut BACNET_ADDRESS,
        mtu: *mut u8,
        mtu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_get_last_result() -> u16;
}
extern "C" {
    pub fn bvlc_set_last_result(result_code: u16);
}
extern "C" {
    pub fn bvlc_get_function_code() -> u8;
}
extern "C" {
    pub fn bvlc_set_function_code(function_code: u8);
}
extern "C" {
    pub fn bvlc_maintenance_timer(seconds: u16);
}
extern "C" {
    pub fn bvlc_init();
}
extern "C" {
    pub fn bvlc_debug_enable();
}
extern "C" {
    pub fn bvlc_debug_disable();
}
extern "C" {
    pub fn bvlc_bbmd_read_bdt(bbmd_addr: *mut BACNET_IP_ADDRESS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_bbmd_write_bdt(
        bbmd_addr: *mut BACNET_IP_ADDRESS,
        bdt_list: *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_bbmd_read_fdt(bbmd_addr: *mut BACNET_IP_ADDRESS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_register_with_bbmd(
        address: *mut BACNET_IP_ADDRESS,
        time_to_live_seconds: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc_remote_bbmd_address(address: *mut BACNET_IP_ADDRESS);
}
extern "C" {
    pub fn bvlc_remote_bbmd_lifetime() -> u16;
}
extern "C" {
    pub fn bvlc_bdt_list() -> *mut BACNET_IP_BROADCAST_DISTRIBUTION_TABLE_ENTRY;
}
extern "C" {
    pub fn bvlc_bdt_list_clear();
}
extern "C" {
    pub fn bvlc_fdt_list() -> *mut BACNET_IP_FOREIGN_DEVICE_TABLE_ENTRY;
}
extern "C" {
    pub fn bvlc_bdt_backup_local();
}
extern "C" {
    pub fn bvlc_bdt_restore_local();
}
extern "C" {
    pub fn bvlc_set_global_address_for_nat(addr: *const BACNET_IP_ADDRESS);
}
extern "C" {
    pub fn bvlc_disable_nat();
}
extern "C" {
    pub fn dlenv_init();
}
extern "C" {
    pub fn bip_dl_debug_enable();
}
extern "C" {
    pub fn bip_dl_debug_disable();
}
extern "C" {
    pub fn dlenv_register_as_foreign_device() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dlenv_network_port_init();
}
extern "C" {
    pub fn dlenv_maintenance_timer(elapsed_seconds: u16);
}
extern "C" {
    pub fn dlenv_bbmd_address_set(address: *mut BACNET_IP_ADDRESS);
}
extern "C" {
    pub fn dlenv_bbmd_ttl_set(ttl_secs: u16);
}
extern "C" {
    pub fn dlenv_bbmd_result() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlmstp_packet {
    pub ready: bool,
    pub address: BACNET_ADDRESS,
    pub frame_type: u8,
    pub pdu_len: u16,
    pub pdu: [u8; 1512usize],
}
#[test]
fn bindgen_test_layout_dlmstp_packet() {
    const UNINIT: ::std::mem::MaybeUninit<dlmstp_packet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dlmstp_packet>(),
        1536usize,
        concat!("Size of: ", stringify!(dlmstp_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<dlmstp_packet>(),
        2usize,
        concat!("Alignment of ", stringify!(dlmstp_packet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ready) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_packet),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_packet),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_packet),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdu_len) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_packet),
            "::",
            stringify!(pdu_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pdu) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_packet),
            "::",
            stringify!(pdu)
        )
    );
}
pub type DLMSTP_PACKET = dlmstp_packet;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dlmstp_statistics {
    pub transmit_frame_counter: u32,
    pub receive_valid_frame_counter: u32,
    pub receive_invalid_frame_counter: u32,
    pub transmit_pdu_counter: u32,
    pub receive_pdu_counter: u32,
    pub lost_token_counter: u32,
}
#[test]
fn bindgen_test_layout_dlmstp_statistics() {
    const UNINIT: ::std::mem::MaybeUninit<dlmstp_statistics> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<dlmstp_statistics>(),
        24usize,
        concat!("Size of: ", stringify!(dlmstp_statistics))
    );
    assert_eq!(
        ::std::mem::align_of::<dlmstp_statistics>(),
        4usize,
        concat!("Alignment of ", stringify!(dlmstp_statistics))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transmit_frame_counter) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_statistics),
            "::",
            stringify!(transmit_frame_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_valid_frame_counter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_statistics),
            "::",
            stringify!(receive_valid_frame_counter)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).receive_invalid_frame_counter) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_statistics),
            "::",
            stringify!(receive_invalid_frame_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transmit_pdu_counter) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_statistics),
            "::",
            stringify!(transmit_pdu_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_pdu_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_statistics),
            "::",
            stringify!(receive_pdu_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lost_token_counter) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dlmstp_statistics),
            "::",
            stringify!(lost_token_counter)
        )
    );
}
pub type DLMSTP_STATISTICS = dlmstp_statistics;
pub type dlmstp_hook_frame_rx_start_cb = ::std::option::Option<unsafe extern "C" fn()>;
pub type dlmstp_hook_frame_rx_complete_cb = ::std::option::Option<
    unsafe extern "C" fn(src: u8, dest: u8, mstp_msg_type: u8, pdu: *mut u8, pdu_len: u16),
>;
extern "C" {
    pub fn dlmstp_init(ifname: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn dlmstp_reset();
}
extern "C" {
    pub fn dlmstp_cleanup();
}
extern "C" {
    pub fn dlmstp_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dlmstp_receive(
        src: *mut BACNET_ADDRESS,
        pdu: *mut u8,
        max_pdu: u16,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn dlmstp_set_max_info_frames(max_info_frames: u8);
}
extern "C" {
    pub fn dlmstp_max_info_frames() -> u8;
}
extern "C" {
    pub fn dlmstp_set_max_master(max_master: u8);
}
extern "C" {
    pub fn dlmstp_max_master() -> u8;
}
extern "C" {
    pub fn dlmstp_set_mac_address(my_address: u8);
}
extern "C" {
    pub fn dlmstp_mac_address() -> u8;
}
extern "C" {
    pub fn dlmstp_get_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn dlmstp_get_broadcast_address(dest: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn dlmstp_set_baud_rate(baud: u32);
}
extern "C" {
    pub fn dlmstp_baud_rate() -> u32;
}
extern "C" {
    pub fn dlmstp_fill_bacnet_address(src: *mut BACNET_ADDRESS, mstp_address: u8);
}
extern "C" {
    pub fn dlmstp_sole_master() -> bool;
}
extern "C" {
    pub fn dlmstp_send_pdu_queue_empty() -> bool;
}
extern "C" {
    pub fn dlmstp_send_pdu_queue_full() -> bool;
}
extern "C" {
    pub fn dlmstp_max_info_frames_limit() -> u8;
}
extern "C" {
    pub fn dlmstp_max_master_limit() -> u8;
}
extern "C" {
    pub fn dlmstp_set_frame_rx_complete_callback(cb_func: dlmstp_hook_frame_rx_complete_cb);
}
extern "C" {
    pub fn dlmstp_set_frame_rx_start_callback(cb_func: dlmstp_hook_frame_rx_start_cb);
}
extern "C" {
    pub fn dlmstp_reset_statistics();
}
extern "C" {
    pub fn dlmstp_fill_statistics(statistics: *mut dlmstp_statistics);
}
extern "C" {
    pub fn ethernet_valid() -> bool;
}
extern "C" {
    pub fn ethernet_cleanup();
}
extern "C" {
    pub fn ethernet_init(interface_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn ethernet_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ethernet_receive(
        src: *mut BACNET_ADDRESS,
        pdu: *mut u8,
        max_pdu: u16,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn ethernet_set_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn ethernet_get_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn ethernet_get_broadcast_address(dest: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn ethernet_debug_address(info: *const ::std::os::raw::c_char, dest: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn ethernet_send(mtu: *mut u8, mtu_len: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const MSTP_RECEIVE_STATE_MSTP_RECEIVE_STATE_IDLE: MSTP_RECEIVE_STATE = 0;
pub const MSTP_RECEIVE_STATE_MSTP_RECEIVE_STATE_PREAMBLE: MSTP_RECEIVE_STATE = 1;
pub const MSTP_RECEIVE_STATE_MSTP_RECEIVE_STATE_HEADER: MSTP_RECEIVE_STATE = 2;
pub const MSTP_RECEIVE_STATE_MSTP_RECEIVE_STATE_DATA: MSTP_RECEIVE_STATE = 3;
pub const MSTP_RECEIVE_STATE_MSTP_RECEIVE_STATE_SKIP_DATA: MSTP_RECEIVE_STATE = 4;
pub type MSTP_RECEIVE_STATE = ::std::os::raw::c_uint;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_INITIALIZE: MSTP_MASTER_STATE = 0;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_IDLE: MSTP_MASTER_STATE = 1;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_USE_TOKEN: MSTP_MASTER_STATE = 2;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_WAIT_FOR_REPLY: MSTP_MASTER_STATE = 3;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_DONE_WITH_TOKEN: MSTP_MASTER_STATE = 4;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_PASS_TOKEN: MSTP_MASTER_STATE = 5;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_NO_TOKEN: MSTP_MASTER_STATE = 6;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_POLL_FOR_MASTER: MSTP_MASTER_STATE = 7;
pub const MSTP_MASTER_STATE_MSTP_MASTER_STATE_ANSWER_DATA_REQUEST: MSTP_MASTER_STATE = 8;
pub type MSTP_MASTER_STATE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mstp_port_struct_t {
    pub receive_state: MSTP_RECEIVE_STATE,
    pub master_state: MSTP_MASTER_STATE,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub DataRegister: u8,
    pub DataCRC: u16,
    pub DataCRCActualMSB: u8,
    pub DataCRCActualLSB: u8,
    pub DataLength: u16,
    pub DestinationAddress: u8,
    pub EventCount: u8,
    pub FrameType: u8,
    pub FrameCount: u8,
    pub HeaderCRC: u8,
    pub HeaderCRCActual: u8,
    pub Index: u32,
    pub InputBuffer: *mut u8,
    pub InputBufferSize: u16,
    pub Next_Station: u8,
    pub Poll_Station: u8,
    pub RetryCount: ::std::os::raw::c_uint,
    pub SilenceTimer:
        ::std::option::Option<unsafe extern "C" fn(pArg: *mut ::std::os::raw::c_void) -> u32>,
    pub SilenceTimerReset:
        ::std::option::Option<unsafe extern "C" fn(pArg: *mut ::std::os::raw::c_void)>,
    pub SourceAddress: u8,
    pub TokenCount: ::std::os::raw::c_uint,
    pub This_Station: u8,
    pub Nmax_info_frames: u8,
    pub Nmax_master: u8,
    pub OutputBuffer: *mut u8,
    pub OutputBufferSize: u16,
    pub UserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_mstp_port_struct_t() {
    const UNINIT: ::std::mem::MaybeUninit<mstp_port_struct_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mstp_port_struct_t>(),
        104usize,
        concat!("Size of: ", stringify!(mstp_port_struct_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mstp_port_struct_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mstp_port_struct_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receive_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(receive_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).master_state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(master_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataRegister) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(DataRegister)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataCRC) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(DataCRC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataCRCActualMSB) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(DataCRCActualMSB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataCRCActualLSB) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(DataCRCActualLSB)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DataLength) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DestinationAddress) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(DestinationAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EventCount) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(EventCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrameType) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(FrameType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FrameCount) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(FrameCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HeaderCRC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(HeaderCRC)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HeaderCRCActual) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(HeaderCRCActual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Index) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(Index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InputBuffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(InputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InputBufferSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(InputBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Next_Station) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(Next_Station)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Poll_Station) as usize - ptr as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(Poll_Station)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RetryCount) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(RetryCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SilenceTimer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(SilenceTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SilenceTimerReset) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(SilenceTimerReset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SourceAddress) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(SourceAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TokenCount) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(TokenCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).This_Station) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(This_Station)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nmax_info_frames) as usize - ptr as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(Nmax_info_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Nmax_master) as usize - ptr as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(Nmax_master)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutputBuffer) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(OutputBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutputBufferSize) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(OutputBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserData) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mstp_port_struct_t),
            "::",
            stringify!(UserData)
        )
    );
}
impl mstp_port_struct_t {
    #[inline]
    pub fn ReceiveError(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceiveError(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DataAvailable(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataAvailable(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReceivedInvalidFrame(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedInvalidFrame(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReceivedValidFrame(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedValidFrame(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReceivedValidFrameNotForUs(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReceivedValidFrameNotForUs(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SoleMaster(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SoleMaster(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ReceiveError: ::std::os::raw::c_uint,
        DataAvailable: ::std::os::raw::c_uint,
        ReceivedInvalidFrame: ::std::os::raw::c_uint,
        ReceivedValidFrame: ::std::os::raw::c_uint,
        ReceivedValidFrameNotForUs: ::std::os::raw::c_uint,
        SoleMaster: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ReceiveError: u32 = unsafe { ::std::mem::transmute(ReceiveError) };
            ReceiveError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DataAvailable: u32 = unsafe { ::std::mem::transmute(DataAvailable) };
            DataAvailable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ReceivedInvalidFrame: u32 = unsafe { ::std::mem::transmute(ReceivedInvalidFrame) };
            ReceivedInvalidFrame as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ReceivedValidFrame: u32 = unsafe { ::std::mem::transmute(ReceivedValidFrame) };
            ReceivedValidFrame as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReceivedValidFrameNotForUs: u32 =
                unsafe { ::std::mem::transmute(ReceivedValidFrameNotForUs) };
            ReceivedValidFrameNotForUs as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SoleMaster: u32 = unsafe { ::std::mem::transmute(SoleMaster) };
            SoleMaster as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn MSTP_Init(mstp_port: *mut mstp_port_struct_t);
}
extern "C" {
    pub fn MSTP_Receive_Frame_FSM(mstp_port: *mut mstp_port_struct_t);
}
extern "C" {
    pub fn MSTP_Master_Node_FSM(mstp_port: *mut mstp_port_struct_t) -> bool;
}
extern "C" {
    pub fn MSTP_Slave_Node_FSM(mstp_port: *mut mstp_port_struct_t);
}
extern "C" {
    pub fn MSTP_Line_Active(mstp_port: *mut mstp_port_struct_t) -> bool;
}
extern "C" {
    pub fn MSTP_Create_Frame(
        buffer: *mut u8,
        buffer_len: u16,
        frame_type: u8,
        destination: u8,
        source: u8,
        data: *mut u8,
        data_len: u16,
    ) -> u16;
}
extern "C" {
    pub fn MSTP_Create_And_Send_Frame(
        mstp_port: *mut mstp_port_struct_t,
        frame_type: u8,
        destination: u8,
        source: u8,
        data: *mut u8,
        data_len: u16,
    );
}
extern "C" {
    pub fn MSTP_Fill_BACnet_Address(src: *mut BACNET_ADDRESS, mstp_address: u8);
}
extern "C" {
    pub fn MSTP_Put_Receive(mstp_port: *mut mstp_port_struct_t) -> u16;
}
extern "C" {
    pub fn MSTP_Get_Send(
        mstp_port: *mut mstp_port_struct_t,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn MSTP_Get_Reply(
        mstp_port: *mut mstp_port_struct_t,
        timeout: ::std::os::raw::c_uint,
    ) -> u16;
}
extern "C" {
    pub fn mstptext_receive_state(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mstptext_master_state(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mstptext_frame_type(index: ::std::os::raw::c_uint) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn npdu_handler(src: *mut BACNET_ADDRESS, pdu: *mut u8, pdu_len: u16);
}
extern "C" {
    pub fn npdu_network_number() -> u16;
}
extern "C" {
    pub fn npdu_network_number_set(net: u16);
}
extern "C" {
    pub fn npdu_send_network_number_is(
        dst: *mut BACNET_ADDRESS,
        net: u16,
        status: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn npdu_send_what_is_network_number(dst: *mut BACNET_ADDRESS) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn npdu_handler_cleanup();
}
extern "C" {
    pub fn npdu_handler_init(bip_net: u16, mstp_net: u16);
}
extern "C" {
    pub fn npdu_router_handler(snet: u16, src: *mut BACNET_ADDRESS, pdu: *mut u8, pdu_len: u16);
}
extern "C" {
    pub fn npdu_router_send_pdu(
        dnet: u16,
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn npdu_router_get_my_address(dnet: u16, my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn routing_npdu_handler(
        src: *mut BACNET_ADDRESS,
        DNET_list: *mut ::std::os::raw::c_int,
        pdu: *mut u8,
        pdu_len: u16,
    );
}
extern "C" {
    pub fn Send_Network_Layer_Message(
        network_message_type: BACNET_NETWORK_MESSAGE_TYPE,
        dst: *mut BACNET_ADDRESS,
        iArgs: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_Who_Is_Router_To_Network(dst: *mut BACNET_ADDRESS, dnet: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Send_I_Am_Router_To_Network(DNET_list: *const ::std::os::raw::c_int);
}
extern "C" {
    pub fn Send_Reject_Message_To_Network(
        dst: *mut BACNET_ADDRESS,
        reject_reason: u8,
        dnet: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Send_Initialize_Routing_Table(
        dst: *mut BACNET_ADDRESS,
        DNET_list: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Send_Initialize_Routing_Table_Ack(
        dst: *mut BACNET_ADDRESS,
        DNET_list: *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Send_Network_Number_Is(
        dst: *mut BACNET_ADDRESS,
        dnet: ::std::os::raw::c_int,
        status: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn address_init();
}
extern "C" {
    pub fn address_init_partial();
}
extern "C" {
    pub fn address_add(device_id: u32, max_apdu: ::std::os::raw::c_uint, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn address_remove_device(device_id: u32);
}
extern "C" {
    pub fn address_get_by_device(
        device_id: u32,
        max_apdu: *mut ::std::os::raw::c_uint,
        src: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn address_get_by_index(
        index: ::std::os::raw::c_uint,
        device_id: *mut u32,
        max_apdu: *mut ::std::os::raw::c_uint,
        src: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn address_device_get_by_index(
        index: ::std::os::raw::c_uint,
        device_id: *mut u32,
        device_ttl: *mut u32,
        max_apdu: *mut ::std::os::raw::c_uint,
        src: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn address_get_device_id(src: *mut BACNET_ADDRESS, device_id: *mut u32) -> bool;
}
extern "C" {
    pub fn address_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn address_bind_request(
        device_id: u32,
        max_apdu: *mut ::std::os::raw::c_uint,
        src: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn address_device_bind_request(
        device_id: u32,
        device_ttl: *mut u32,
        max_apdu: *mut ::std::os::raw::c_uint,
        src: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn address_add_binding(
        device_id: u32,
        max_apdu: ::std::os::raw::c_uint,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn address_list_encode(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rr_address_list_encode(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn address_set_device_TTL(device_id: u32, TimeOut: u32, StaticFlag: bool);
}
extern "C" {
    pub fn address_cache_timer(uSeconds: u16);
}
extern "C" {
    pub fn address_protected_entry_index_set(top_protected_entry_index: u32);
}
extern "C" {
    pub fn address_own_device_id_set(own_id: u32);
}
extern "C" {
    pub fn handler_alarm_ack(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_alarm_ack_set(object_type: BACNET_OBJECT_TYPE, pFunction: alarm_ack_function);
}
pub type unconfirmed_function = ::std::option::Option<
    unsafe extern "C" fn(service_request: *mut u8, len: u16, src: *mut BACNET_ADDRESS),
>;
pub type confirmed_function = ::std::option::Option<
    unsafe extern "C" fn(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    ),
>;
pub type confirmed_simple_ack_function =
    ::std::option::Option<unsafe extern "C" fn(src: *mut BACNET_ADDRESS, invoke_id: u8)>;
pub type confirmed_ack_function = ::std::option::Option<
    unsafe extern "C" fn(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    ),
>;
pub type error_function = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut BACNET_ADDRESS,
        invoke_id: u8,
        error_class: BACNET_ERROR_CLASS,
        error_code: BACNET_ERROR_CODE,
    ),
>;
pub type complex_error_function = ::std::option::Option<
    unsafe extern "C" fn(
        src: *mut BACNET_ADDRESS,
        invoke_id: u8,
        service_choice: u8,
        service_request: *mut u8,
        service_len: u16,
    ),
>;
pub type abort_function = ::std::option::Option<
    unsafe extern "C" fn(src: *mut BACNET_ADDRESS, invoke_id: u8, abort_reason: u8, server: bool),
>;
pub type reject_function = ::std::option::Option<
    unsafe extern "C" fn(src: *mut BACNET_ADDRESS, invoke_id: u8, reject_reason: u8),
>;
extern "C" {
    pub fn apdu_set_confirmed_ack_handler(
        service_choice: BACNET_CONFIRMED_SERVICE,
        pFunction: confirmed_ack_function,
    );
}
extern "C" {
    pub fn apdu_confirmed_simple_ack_service(service_choice: BACNET_CONFIRMED_SERVICE) -> bool;
}
extern "C" {
    pub fn apdu_set_confirmed_simple_ack_handler(
        service_choice: BACNET_CONFIRMED_SERVICE,
        pFunction: confirmed_simple_ack_function,
    );
}
extern "C" {
    pub fn apdu_set_unrecognized_service_handler_handler(pFunction: confirmed_function);
}
extern "C" {
    pub fn apdu_set_confirmed_handler(
        service_choice: BACNET_CONFIRMED_SERVICE,
        pFunction: confirmed_function,
    );
}
extern "C" {
    pub fn apdu_set_unconfirmed_handler(
        service_choice: BACNET_UNCONFIRMED_SERVICE,
        pFunction: unconfirmed_function,
    );
}
extern "C" {
    pub fn apdu_service_supported(service_supported: BACNET_SERVICES_SUPPORTED) -> bool;
}
extern "C" {
    pub fn apdu_service_supported_to_index(
        service_supported: BACNET_SERVICES_SUPPORTED,
        index: *mut usize,
        bIsConfirmed: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn apdu_complex_error(service_choice: u8) -> bool;
}
extern "C" {
    pub fn apdu_set_error_handler(
        service_choice: BACNET_CONFIRMED_SERVICE,
        pFunction: error_function,
    );
}
extern "C" {
    pub fn apdu_set_complex_error_handler(
        service_choice: BACNET_CONFIRMED_SERVICE,
        pFunction: complex_error_function,
    );
}
extern "C" {
    pub fn apdu_set_abort_handler(pFunction: abort_function);
}
extern "C" {
    pub fn apdu_set_reject_handler(pFunction: reject_function);
}
extern "C" {
    pub fn apdu_decode_confirmed_service_request(
        apdu: *mut u8,
        apdu_len: u16,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
        service_choice: *mut u8,
        service_request: *mut *mut u8,
        service_request_len: *mut u16,
    ) -> u16;
}
extern "C" {
    pub fn apdu_timeout() -> u16;
}
extern "C" {
    pub fn apdu_timeout_set(value: u16);
}
extern "C" {
    pub fn apdu_retries() -> u8;
}
extern "C" {
    pub fn apdu_retries_set(value: u8);
}
extern "C" {
    pub fn apdu_handler(src: *mut BACNET_ADDRESS, apdu: *mut u8, pdu_len: u16);
}
extern "C" {
    pub fn handler_atomic_read_file(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_atomic_read_file_ack(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    );
}
extern "C" {
    pub fn handler_atomic_write_file(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_ccov_notification_add(callback: *mut BACNET_COV_NOTIFICATION);
}
extern "C" {
    pub fn handler_ccov_notification(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_cov_subscribe(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_cov_fsm() -> bool;
}
extern "C" {
    pub fn handler_cov_task();
}
extern "C" {
    pub fn handler_cov_timer_seconds(elapsed_seconds: u32);
}
extern "C" {
    pub fn handler_cov_init();
}
extern "C" {
    pub fn handler_cov_encode_subscriptions(
        apdu: *mut u8,
        max_apdu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn handler_device_communication_control(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_dcc_password_set(new_password: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn handler_dcc_password() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn get_alarm_summary_ack_handler(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    );
}
extern "C" {
    pub fn handler_get_alarm_summary_set(
        object_type: BACNET_OBJECT_TYPE,
        pFunction: get_alarm_summary_function,
    );
}
extern "C" {
    pub fn handler_get_alarm_summary(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_get_event_information_set(
        object_type: BACNET_OBJECT_TYPE,
        pFunction: get_event_info_function,
    );
}
extern "C" {
    pub fn handler_get_event_information(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn ge_ack_print_data(data: *mut BACNET_GET_EVENT_INFORMATION_DATA, device_id: u32);
}
extern "C" {
    pub fn get_event_ack_handler(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    );
}
extern "C" {
    pub fn handler_i_am_add(service_request: *mut u8, service_len: u16, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn handler_i_am_bind(service_request: *mut u8, service_len: u16, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn handler_i_have(service_request: *mut u8, service_len: u16, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn handler_add_list_element(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_remove_list_element(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_lso(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_unrecognized_service(
        service_request: *mut u8,
        service_len: u16,
        dest: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_reinitialize_device(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_read_property(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_read_property_ack(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    );
}
extern "C" {
    pub fn rp_ack_print_data(data: *mut BACNET_READ_PROPERTY_DATA);
}
extern "C" {
    pub fn handler_read_property_multiple(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_read_property_multiple_ack(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    );
}
extern "C" {
    pub fn rpm_ack_decode_service_request(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_int,
        read_access_data: *mut BACNET_READ_ACCESS_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpm_ack_print_data(rpm_data: *mut BACNET_READ_ACCESS_DATA);
}
extern "C" {
    pub fn rpm_data_free(rpm_data: *mut BACNET_READ_ACCESS_DATA) -> *mut BACNET_READ_ACCESS_DATA;
}
extern "C" {
    pub fn handler_read_range(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn handler_read_range_ack(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_ACK_DATA,
    );
}
extern "C" {
    pub fn handler_timesync(service_request: *mut u8, service_len: u16, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn handler_timesync_utc(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn handler_timesync_encode_recipients(
        apdu: *mut u8,
        max_apdu: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn handler_timesync_task(bdatetime: *mut BACNET_DATE_TIME);
}
extern "C" {
    pub fn handler_timesync_init();
}
extern "C" {
    pub fn handler_timesync_recipient_write(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn handler_timesync_interval() -> u32;
}
extern "C" {
    pub fn handler_timesync_interval_set(minutes: u32) -> bool;
}
extern "C" {
    pub fn handler_timesync_interval_offset() -> u32;
}
extern "C" {
    pub fn handler_timesync_interval_offset_set(minutes: u32) -> bool;
}
extern "C" {
    pub fn handler_timesync_interval_align() -> bool;
}
extern "C" {
    pub fn handler_timesync_interval_align_set(flag: bool) -> bool;
}
extern "C" {
    pub fn handler_timesync_recipient_address_set(
        index: ::std::os::raw::c_uint,
        address: *mut BACNET_ADDRESS,
    ) -> bool;
}
extern "C" {
    pub fn handler_ucov_notification_add(callback: *mut BACNET_COV_NOTIFICATION);
}
extern "C" {
    pub fn handler_ucov_notification(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn handler_unconfirmed_private_transfer(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn private_transfer_print_data(private_data: *mut BACNET_PRIVATE_TRANSFER_DATA);
}
extern "C" {
    pub fn handler_who_has(service_request: *mut u8, service_len: u16, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn handler_who_has_for_routing(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn handler_who_is(service_request: *mut u8, service_len: u16, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn handler_who_is_unicast(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn handler_who_is_bcast_for_routing(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn handler_who_is_unicast_for_routing(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
    );
}
extern "C" {
    pub fn handler_write_property(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn WPValidateString(
        pValue: *mut BACNET_APPLICATION_DATA_VALUE,
        iMaxLen: ::std::os::raw::c_int,
        bEmptyAllowed: bool,
        pErrorClass: *mut BACNET_ERROR_CLASS,
        pErrorCode: *mut BACNET_ERROR_CODE,
    ) -> bool;
}
extern "C" {
    pub fn WPValidateArgType(
        pValue: *mut BACNET_APPLICATION_DATA_VALUE,
        ucExpectedType: u8,
        pErrorClass: *mut BACNET_ERROR_CLASS,
        pErrorCode: *mut BACNET_ERROR_CODE,
    ) -> bool;
}
extern "C" {
    pub fn handler_write_property_multiple(
        service_request: *mut u8,
        service_len: u16,
        src: *mut BACNET_ADDRESS,
        service_data: *mut BACNET_CONFIRMED_SERVICE_DATA,
    );
}
extern "C" {
    pub fn Send_Abort_To_Network(
        buffer: *mut u8,
        dest: *mut BACNET_ADDRESS,
        invoke_id: u8,
        reason: BACNET_ABORT_REASON,
        server: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort_encode_pdu(
        buffer: *mut u8,
        dest: *mut BACNET_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        invoke_id: u8,
        reason: BACNET_ABORT_REASON,
        server: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_Alarm_Acknowledgement_Address(
        pdu: *mut u8,
        pdu_size: u16,
        data: *mut BACNET_ALARM_ACK_DATA,
        dest: *mut BACNET_ADDRESS,
    ) -> u8;
}
extern "C" {
    pub fn Send_Alarm_Acknowledgement(device_id: u32, data: *mut BACNET_ALARM_ACK_DATA) -> u8;
}
extern "C" {
    pub fn Send_Atomic_Read_File_Stream(
        device_id: u32,
        file_instance: u32,
        fileStartPosition: ::std::os::raw::c_int,
        requestedOctetCount: ::std::os::raw::c_uint,
    ) -> u8;
}
extern "C" {
    pub fn Send_Atomic_Write_File_Stream(
        device_id: u32,
        file_instance: u32,
        fileStartPosition: ::std::os::raw::c_int,
        fileData: *mut BACNET_OCTET_STRING,
    ) -> u8;
}
extern "C" {
    pub fn Send_CEvent_Notify(device_id: u32, data: *mut BACNET_EVENT_NOTIFICATION_DATA) -> u8;
}
extern "C" {
    pub fn Send_CEvent_Notify_Address(
        pdu: *mut u8,
        pdu_size: u16,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
        dest: *mut BACNET_ADDRESS,
    ) -> u8;
}
extern "C" {
    pub fn Send_UCOV_Notify(
        buffer: *mut u8,
        buffer_len: ::std::os::raw::c_uint,
        cov_data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucov_notify_encode_pdu(
        buffer: *mut u8,
        buffer_len: ::std::os::raw::c_uint,
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        cov_data: *mut BACNET_COV_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_COV_Subscribe(device_id: u32, cov_data: *mut BACNET_SUBSCRIBE_COV_DATA) -> u8;
}
extern "C" {
    pub fn Send_Device_Communication_Control_Request(
        device_id: u32,
        timeDuration: u16,
        state: BACNET_COMMUNICATION_ENABLE_DISABLE,
        password: *mut ::std::os::raw::c_char,
    ) -> u8;
}
extern "C" {
    pub fn Send_Error_To_Network(
        buffer: *mut u8,
        dest: *mut BACNET_ADDRESS,
        invoke_id: u8,
        service: BACNET_CONFIRMED_SERVICE,
        error_class: BACNET_ERROR_CLASS,
        error_code: BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn error_encode_pdu(
        buffer: *mut u8,
        dest: *mut BACNET_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        invoke_id: u8,
        service: BACNET_CONFIRMED_SERVICE,
        error_class: BACNET_ERROR_CLASS,
        error_code: BACNET_ERROR_CODE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_Get_Alarm_Summary_Address(dest: *mut BACNET_ADDRESS, max_apdu: u16) -> u8;
}
extern "C" {
    pub fn Send_Get_Alarm_Summary(device_id: u32) -> u8;
}
extern "C" {
    pub fn Send_Get_Event_Information_Address(
        dest: *mut BACNET_ADDRESS,
        max_apdu: u16,
        lastReceivedObjectIdentifier: *mut BACNET_OBJECT_ID,
    ) -> u8;
}
extern "C" {
    pub fn Send_Get_Event_Information(
        device_id: u32,
        lastReceivedObjectIdentifier: *mut BACNET_OBJECT_ID,
    ) -> u8;
}
extern "C" {
    pub fn Send_GetEvent(
        target_address: *mut BACNET_ADDRESS,
        lastReceivedObjectIdentifier: *mut BACNET_OBJECT_ID,
    ) -> u8;
}
extern "C" {
    pub fn Send_GetEvent_Global() -> u8;
}
extern "C" {
    pub fn Send_I_Am_To_Network(
        target_address: *mut BACNET_ADDRESS,
        device_id: u32,
        max_apdu: ::std::os::raw::c_uint,
        segmentation: ::std::os::raw::c_int,
        vendor_id: u16,
    );
}
extern "C" {
    pub fn iam_encode_pdu(
        buffer: *mut u8,
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_I_Am(buffer: *mut u8);
}
extern "C" {
    pub fn iam_unicast_encode_pdu(
        buffer: *mut u8,
        src: *mut BACNET_ADDRESS,
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_I_Am_Unicast(buffer: *mut u8, src: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn Send_I_Have(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    );
}
extern "C" {
    pub fn Send_List_Element_Request_Data(
        service: BACNET_CONFIRMED_SERVICE,
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        application_data: *mut u8,
        application_data_len: ::std::os::raw::c_int,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Add_List_Element_Request_Data(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        application_data: *mut u8,
        application_data_len: ::std::os::raw::c_int,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Add_List_Element_Request(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        object_value: *mut BACNET_APPLICATION_DATA_VALUE,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Remove_List_Element_Request_Data(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        application_data: *mut u8,
        application_data_len: ::std::os::raw::c_int,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Remove_List_Element_Request(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        object_value: *mut BACNET_APPLICATION_DATA_VALUE,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Life_Safety_Operation_Data(device_id: u32, data: *mut BACNET_LSO_DATA) -> u8;
}
extern "C" {
    pub fn Send_Reinitialize_Device_Request(
        device_id: u32,
        state: BACNET_REINITIALIZED_STATE,
        password: *mut ::std::os::raw::c_char,
    ) -> u8;
}
extern "C" {
    pub fn Send_ReadRange_Request(
        device_id: u32,
        read_access_data: *mut BACNET_READ_RANGE_DATA,
    ) -> u8;
}
extern "C" {
    pub fn Send_Read_Property_Request_Address(
        dest: *mut BACNET_ADDRESS,
        max_apdu: u16,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Read_Property_Request(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Read_Property_Multiple_Request(
        pdu: *mut u8,
        max_pdu: usize,
        device_id: u32,
        read_access_data: *mut BACNET_READ_ACCESS_DATA,
    ) -> u8;
}
extern "C" {
    pub fn Send_TimeSync(bdate: *mut BACNET_DATE, btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn Send_TimeSync_Remote(
        dest: *mut BACNET_ADDRESS,
        bdate: *mut BACNET_DATE,
        btime: *mut BACNET_TIME,
    );
}
extern "C" {
    pub fn Send_TimeSyncUTC(bdate: *mut BACNET_DATE, btime: *mut BACNET_TIME);
}
extern "C" {
    pub fn Send_TimeSyncUTC_Remote(
        dest: *mut BACNET_ADDRESS,
        bdate: *mut BACNET_DATE,
        btime: *mut BACNET_TIME,
    );
}
extern "C" {
    pub fn Send_TimeSyncUTC_Device();
}
extern "C" {
    pub fn Send_TimeSync_Device();
}
extern "C" {
    pub fn Send_UEvent_Notify(
        buffer: *mut u8,
        data: *mut BACNET_EVENT_NOTIFICATION_DATA,
        dest: *mut BACNET_ADDRESS,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_UnconfirmedPrivateTransfer(
        dest: *mut BACNET_ADDRESS,
        private_data: *mut BACNET_PRIVATE_TRANSFER_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Send_WhoHas_Name(
        low_limit: i32,
        high_limit: i32,
        object_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn Send_WhoHas_Object(
        low_limit: i32,
        high_limit: i32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
    );
}
extern "C" {
    pub fn Send_WhoIs(low_limit: i32, high_limit: i32);
}
extern "C" {
    pub fn Send_WhoIs_Global(low_limit: i32, high_limit: i32);
}
extern "C" {
    pub fn Send_WhoIs_Local(low_limit: i32, high_limit: i32);
}
extern "C" {
    pub fn Send_WhoIs_Remote(target_address: *mut BACNET_ADDRESS, low_limit: i32, high_limit: i32);
}
extern "C" {
    pub fn Send_WhoIs_To_Network(
        target_address: *mut BACNET_ADDRESS,
        low_limit: i32,
        high_limit: i32,
    );
}
extern "C" {
    pub fn Send_Write_Property_Request(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        object_value: *mut BACNET_APPLICATION_DATA_VALUE,
        priority: u8,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Write_Property_Request_Data(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        application_data: *mut u8,
        application_data_len: ::std::os::raw::c_int,
        priority: u8,
        array_index: u32,
    ) -> u8;
}
extern "C" {
    pub fn Send_Write_Property_Multiple_Request(
        pdu: *mut u8,
        max_pdu: usize,
        device_id: u32,
        write_access_data: *mut BACNET_WRITE_ACCESS_DATA,
    ) -> u8;
}
extern "C" {
    pub fn bvlc6_handler(
        addr: *mut BACNET_IP6_ADDRESS,
        src: *mut BACNET_ADDRESS,
        npdu: *mut u8,
        npdu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_bbmd_enabled_handler(
        addr: *mut BACNET_IP6_ADDRESS,
        src: *mut BACNET_ADDRESS,
        mtu: *mut u8,
        mtu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_bbmd_disabled_handler(
        addr: *mut BACNET_IP6_ADDRESS,
        src: *mut BACNET_ADDRESS,
        mtu: *mut u8,
        mtu_len: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_send_pdu(
        dest: *mut BACNET_ADDRESS,
        npdu_data: *mut BACNET_NPDU_DATA,
        pdu: *mut u8,
        pdu_len: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_register_with_bbmd(
        bbmd_addr: *mut BACNET_IP6_ADDRESS,
        time_to_live_seconds: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bvlc6_remote_bbmd_address(bbmd_addr: *mut BACNET_IP6_ADDRESS);
}
extern "C" {
    pub fn bvlc6_remote_bbmd_lifetime() -> u16;
}
extern "C" {
    pub fn bvlc6_get_last_result() -> u16;
}
extern "C" {
    pub fn bvlc6_get_function_code() -> u8;
}
extern "C" {
    pub fn bvlc6_maintenance_timer(seconds: u16);
}
extern "C" {
    pub fn bvlc6_debug_enable();
}
extern "C" {
    pub fn bvlc6_cleanup();
}
extern "C" {
    pub fn bvlc6_init();
}
#[doc = " VMAC data structure\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vmac_data {
    pub mac: [u8; 18usize],
    pub mac_len: u8,
}
#[test]
fn bindgen_test_layout_vmac_data() {
    const UNINIT: ::std::mem::MaybeUninit<vmac_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vmac_data>(),
        19usize,
        concat!("Size of: ", stringify!(vmac_data))
    );
    assert_eq!(
        ::std::mem::align_of::<vmac_data>(),
        1usize,
        concat!("Alignment of ", stringify!(vmac_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vmac_data),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mac_len) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(vmac_data),
            "::",
            stringify!(mac_len)
        )
    );
}
extern "C" {
    pub fn VMAC_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn VMAC_Find_By_Key(device_id: u32) -> *mut vmac_data;
}
extern "C" {
    pub fn VMAC_Find_By_Data(vmac: *mut vmac_data, device_id: *mut u32) -> bool;
}
extern "C" {
    pub fn VMAC_Add(device_id: u32, pVMAC: *mut vmac_data) -> bool;
}
extern "C" {
    pub fn VMAC_Delete(device_id: u32) -> bool;
}
extern "C" {
    pub fn VMAC_Different(vmac1: *mut vmac_data, vmac2: *mut vmac_data) -> bool;
}
extern "C" {
    pub fn VMAC_Match(vmac1: *mut vmac_data, vmac2: *mut vmac_data) -> bool;
}
extern "C" {
    pub fn VMAC_Cleanup();
}
extern "C" {
    pub fn VMAC_Init();
}
extern "C" {
    pub fn VMAC_Debug_Enable();
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct bacnet_status_flags_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_bacnet_status_flags_t() {
    assert_eq!(
        ::std::mem::size_of::<bacnet_status_flags_t>(),
        1usize,
        concat!("Size of: ", stringify!(bacnet_status_flags_t))
    );
    assert_eq!(
        ::std::mem::align_of::<bacnet_status_flags_t>(),
        1usize,
        concat!("Alignment of ", stringify!(bacnet_status_flags_t))
    );
}
impl bacnet_status_flags_t {
    #[inline]
    pub fn in_alarm(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_in_alarm(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fault(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_fault(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn overridden(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_overridden(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn out_of_service(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_out_of_service(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        in_alarm: bool,
        fault: bool,
        overridden: bool,
        out_of_service: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let in_alarm: u8 = unsafe { ::std::mem::transmute(in_alarm) };
            in_alarm as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let fault: u8 = unsafe { ::std::mem::transmute(fault) };
            fault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let overridden: u8 = unsafe { ::std::mem::transmute(overridden) };
            overridden as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let out_of_service: u8 = unsafe { ::std::mem::transmute(out_of_service) };
            out_of_service as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn bacnet_data_init();
}
extern "C" {
    pub fn bacnet_data_task();
}
extern "C" {
    pub fn bacnet_data_poll_seconds_set(seconds: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn bacnet_data_poll_seconds() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bacnet_data_value_save(
        device_instance: u32,
        rp_data: *mut BACNET_READ_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    );
}
extern "C" {
    pub fn bacnet_data_object_add(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_data_analog_present_value(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        float_value: *mut f32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_data_multistate_present_value(
        device_id: u32,
        object_type: u16,
        object_instance: u32,
        unsigned_value: *mut u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_data_binary_present_value(
        device_id: u32,
        object_type: u16,
        object_instance: u32,
        bool_value: *mut bool,
    ) -> bool;
}
#[doc = " Save the requested ReadProperty data to a data store\n\n @param device_instance [in] device instance number where data originated\n @param rp_data [in] Pointer to the BACNET_READ_PROPERTY_DATA structure,\n  which is packed with the information from the ReadProperty request.\n @param value [in] pointer to the BACNET_APPLICATION_DATA_VALUE structure\n  which is packed with the decoded value from the ReadProperty request."]
pub type bacnet_read_write_value_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        device_instance: u32,
        rp_data: *mut BACNET_READ_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ),
>;
extern "C" {
    pub fn bacnet_read_write_init();
}
extern "C" {
    pub fn bacnet_read_write_task();
}
extern "C" {
    pub fn bacnet_read_write_idle() -> bool;
}
extern "C" {
    pub fn bacnet_read_write_busy() -> bool;
}
extern "C" {
    pub fn bacnet_read_property_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_write_property_real_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        value: f32,
        priority: u8,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_write_property_null_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        priority: u8,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_write_property_enumerated_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        value: ::std::os::raw::c_uint,
        priority: u8,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_write_property_unsigned_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        value: ::std::os::raw::c_uint,
        priority: u8,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_write_property_signed_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        value: ::std::os::raw::c_int,
        priority: u8,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_write_property_boolean_queue(
        device_id: u32,
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_property: BACNET_PROPERTY_ID,
        value: bool,
        priority: u8,
        array_index: u32,
    ) -> bool;
}
extern "C" {
    pub fn bacnet_read_write_value_callback_set(callback: bacnet_read_write_value_callback_t);
}
extern "C" {
    pub fn bacnet_read_write_vendor_id_filter_set(vendor_id: u16);
}
extern "C" {
    pub fn bacnet_task_init();
}
extern "C" {
    pub fn bacnet_task();
}
extern "C" {
    pub fn color_rgb_to_xy(
        r: u8,
        g: u8,
        b: u8,
        x_coordinate: *mut f32,
        y_coordinate: *mut f32,
        brightness: *mut u8,
    );
}
extern "C" {
    pub fn color_rgb_from_xy(
        red: *mut u8,
        green: *mut u8,
        blue: *mut u8,
        x_coordinate: f32,
        y_coordinate: f32,
        brightness: u8,
    );
}
extern "C" {
    pub fn color_rgb_to_ascii(red: u8, green: u8, blue: u8) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn color_rgb_from_ascii(
        red: *mut u8,
        green: *mut u8,
        blue: *mut u8,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn color_rgb_from_index(
        target_index: ::std::os::raw::c_uint,
        red: *mut u8,
        green: *mut u8,
        blue: *mut u8,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn color_rgb_count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn color_rgb_from_temperature(temperature_kelvin: u16, r: *mut u8, g: *mut u8, b: *mut u8);
}
extern "C" {
    pub fn days_is_leap_year(year: u16) -> bool;
}
extern "C" {
    pub fn days_per_month(year: u16, month: u8) -> u8;
}
extern "C" {
    pub fn days_per_year(year: u16) -> u32;
}
extern "C" {
    pub fn days_of_year(year: u16, month: u8, day: u8) -> u16;
}
extern "C" {
    pub fn days_of_year_remaining(year: u16, month: u8, day: u8) -> u16;
}
extern "C" {
    pub fn days_of_year_to_month_day(days: u32, year: u16, pMonth: *mut u8, pDay: *mut u8);
}
extern "C" {
    pub fn days_apart(year1: u16, month1: u8, day1: u8, year2: u16, month2: u8, day2: u8) -> u32;
}
extern "C" {
    pub fn days_since_epoch(epoch_year: u16, year: u16, month: u8, day: u8) -> u32;
}
extern "C" {
    pub fn days_since_epoch_to_date(
        epoch_year: u16,
        days: u32,
        pYear: *mut u16,
        pMonth: *mut u8,
        pDay: *mut u8,
    );
}
extern "C" {
    pub fn days_date_is_valid(year: u16, month: u8, day: u8) -> bool;
}
extern "C" {
    pub fn debug_printf(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn debug_aprintf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_fprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn debug_perror(format: *const ::std::os::raw::c_char, ...);
}
#[doc = " FIFO data structure\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fifo_buffer_t {
    #[doc = " first byte of data"]
    pub head: ::std::os::raw::c_uint,
    #[doc = " last byte of data"]
    pub tail: ::std::os::raw::c_uint,
    #[doc = " block of memory or array of data"]
    pub buffer: *mut u8,
    #[doc = " length of the data"]
    pub buffer_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_fifo_buffer_t() {
    const UNINIT: ::std::mem::MaybeUninit<fifo_buffer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fifo_buffer_t>(),
        24usize,
        concat!("Size of: ", stringify!(fifo_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<fifo_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(fifo_buffer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_buffer_t),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_buffer_t),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_buffer_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fifo_buffer_t),
            "::",
            stringify!(buffer_len)
        )
    );
}
#[doc = " FIFO data structure\n\n @{"]
pub type FIFO_BUFFER = fifo_buffer_t;
extern "C" {
    pub fn FIFO_Count(b: *const FIFO_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FIFO_Full(b: *const FIFO_BUFFER) -> bool;
}
extern "C" {
    pub fn FIFO_Available(b: *const FIFO_BUFFER, count: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn FIFO_Empty(b: *const FIFO_BUFFER) -> bool;
}
extern "C" {
    pub fn FIFO_Peek(b: *const FIFO_BUFFER) -> u8;
}
extern "C" {
    pub fn FIFO_Get(b: *mut FIFO_BUFFER) -> u8;
}
extern "C" {
    pub fn FIFO_Pull(
        b: *mut FIFO_BUFFER,
        data_bytes: *mut u8,
        length: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn FIFO_Put(b: *mut FIFO_BUFFER, data_byte: u8) -> bool;
}
extern "C" {
    pub fn FIFO_Add(
        b: *mut FIFO_BUFFER,
        data_bytes: *mut u8,
        count: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn FIFO_Flush(b: *mut FIFO_BUFFER);
}
extern "C" {
    pub fn FIFO_Init(b: *mut FIFO_BUFFER, buffer: *mut u8, buffer_len: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn filename_remove_path(
        filename_in: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type KEY = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Keylist_Node {
    pub key: KEY,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Keylist_Node() {
    const UNINIT: ::std::mem::MaybeUninit<Keylist_Node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Keylist_Node>(),
        16usize,
        concat!("Size of: ", stringify!(Keylist_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<Keylist_Node>(),
        8usize,
        concat!("Alignment of ", stringify!(Keylist_Node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Keylist_Node),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Keylist_Node),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Keylist {
    pub array: *mut *mut Keylist_Node,
    pub count: ::std::os::raw::c_int,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Keylist() {
    const UNINIT: ::std::mem::MaybeUninit<Keylist> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Keylist>(),
        16usize,
        concat!("Size of: ", stringify!(Keylist))
    );
    assert_eq!(
        ::std::mem::align_of::<Keylist>(),
        8usize,
        concat!("Alignment of ", stringify!(Keylist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Keylist),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Keylist),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Keylist),
            "::",
            stringify!(size)
        )
    );
}
pub type KEYLIST_TYPE = Keylist;
pub type OS_Keylist = *mut KEYLIST_TYPE;
extern "C" {
    pub fn Keylist_Create() -> OS_Keylist;
}
extern "C" {
    pub fn Keylist_Delete(list: OS_Keylist);
}
extern "C" {
    pub fn Keylist_Data_Add(
        list: OS_Keylist,
        key: KEY,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Keylist_Data_Delete(list: OS_Keylist, key: KEY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Keylist_Data_Delete_By_Index(
        list: OS_Keylist,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Keylist_Data_Pop(list: OS_Keylist) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Keylist_Data(list: OS_Keylist, key: KEY) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Keylist_Index(list: OS_Keylist, key: KEY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Keylist_Data_Index(
        list: OS_Keylist,
        index: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Keylist_Key(list: OS_Keylist, index: ::std::os::raw::c_int) -> KEY;
}
extern "C" {
    pub fn Keylist_Next_Empty_Key(list: OS_Keylist, key: KEY) -> KEY;
}
extern "C" {
    pub fn Keylist_Count(list: OS_Keylist) -> ::std::os::raw::c_int;
}
#[doc = " A timer.\n\n This structure is used for declaring a timer. The timer must be set\n with mstimer_set() before it can be used.\n\n \\hideinitializer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mstimer {
    pub start: ::std::os::raw::c_ulong,
    pub interval: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_mstimer() {
    const UNINIT: ::std::mem::MaybeUninit<mstimer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mstimer>(),
        16usize,
        concat!("Size of: ", stringify!(mstimer))
    );
    assert_eq!(
        ::std::mem::align_of::<mstimer>(),
        8usize,
        concat!("Alignment of ", stringify!(mstimer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mstimer),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mstimer),
            "::",
            stringify!(interval)
        )
    );
}
pub type mstimer_callback_function = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mstimer_callback_data_t {
    pub timer: mstimer,
    pub callback: mstimer_callback_function,
    pub next: *mut mstimer_callback_data_t,
}
#[test]
fn bindgen_test_layout_mstimer_callback_data_t() {
    const UNINIT: ::std::mem::MaybeUninit<mstimer_callback_data_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mstimer_callback_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(mstimer_callback_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mstimer_callback_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mstimer_callback_data_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mstimer_callback_data_t),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mstimer_callback_data_t),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mstimer_callback_data_t),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn mstimer_set(t: *mut mstimer, interval: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mstimer_reset(t: *mut mstimer);
}
extern "C" {
    pub fn mstimer_restart(t: *mut mstimer);
}
extern "C" {
    pub fn mstimer_expired(t: *mut mstimer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mstimer_remaining(t: *mut mstimer) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mstimer_elapsed(t: *mut mstimer) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mstimer_interval(t: *mut mstimer) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mstimer_callback(
        cb: *mut mstimer_callback_data_t,
        callback: mstimer_callback_function,
        milliseconds: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn mstimer_callback_handler();
}
extern "C" {
    pub fn mstimer_now() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mstimer_init();
}
#[doc = " ring buffer data structure\n\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ring_buffer_t {
    #[doc = " block of memory or array of data"]
    pub buffer: *mut u8,
    #[doc = " how many bytes for each chunk"]
    pub element_size: ::std::os::raw::c_uint,
    #[doc = " number of chunks of data"]
    pub element_count: ::std::os::raw::c_uint,
    #[doc = " where the writes go"]
    pub head: ::std::os::raw::c_uint,
    #[doc = " where the reads come from"]
    pub tail: ::std::os::raw::c_uint,
    pub depth: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ring_buffer_t() {
    const UNINIT: ::std::mem::MaybeUninit<ring_buffer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ring_buffer_t>(),
        32usize,
        concat!("Size of: ", stringify!(ring_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ring_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ring_buffer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ring_buffer_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ring_buffer_t),
            "::",
            stringify!(element_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).element_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ring_buffer_t),
            "::",
            stringify!(element_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ring_buffer_t),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ring_buffer_t),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ring_buffer_t),
            "::",
            stringify!(depth)
        )
    );
}
#[doc = " ring buffer data structure\n\n @{"]
pub type RING_BUFFER = ring_buffer_t;
extern "C" {
    pub fn Ringbuf_Count(b: *const RING_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Ringbuf_Depth(b: *const RING_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Ringbuf_Depth_Reset(b: *mut RING_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Ringbuf_Size(b: *const RING_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Ringbuf_Full(b: *const RING_BUFFER) -> bool;
}
extern "C" {
    pub fn Ringbuf_Empty(b: *const RING_BUFFER) -> bool;
}
extern "C" {
    pub fn Ringbuf_Peek(b: *const RING_BUFFER) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Ringbuf_Pop(b: *mut RING_BUFFER, data_element: *mut u8) -> bool;
}
extern "C" {
    pub fn Ringbuf_Pop_Element(
        b: *mut RING_BUFFER,
        this_element: *mut u8,
        data_element: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Ringbuf_Put_Front(b: *mut RING_BUFFER, data_element: *mut u8) -> bool;
}
extern "C" {
    pub fn Ringbuf_Put(b: *mut RING_BUFFER, data_element: *mut u8) -> bool;
}
extern "C" {
    pub fn Ringbuf_Data_Peek(b: *mut RING_BUFFER) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Ringbuf_Peek_Next(
        b: *const RING_BUFFER,
        data_element: *mut u8,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Ringbuf_Data_Put(b: *mut RING_BUFFER, data_element: *mut u8) -> bool;
}
extern "C" {
    pub fn Ringbuf_Init(
        b: *mut RING_BUFFER,
        buffer: *mut u8,
        element_size: ::std::os::raw::c_uint,
        element_count: ::std::os::raw::c_uint,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct static_buffer_t {
    pub data: *mut ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_uint,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_static_buffer_t() {
    const UNINIT: ::std::mem::MaybeUninit<static_buffer_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<static_buffer_t>(),
        16usize,
        concat!("Size of: ", stringify!(static_buffer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<static_buffer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(static_buffer_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(static_buffer_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(static_buffer_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(static_buffer_t),
            "::",
            stringify!(count)
        )
    );
}
pub type STATIC_BUFFER = static_buffer_t;
extern "C" {
    pub fn sbuf_init(
        b: *mut STATIC_BUFFER,
        data: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn sbuf_empty(b: *const STATIC_BUFFER) -> bool;
}
extern "C" {
    pub fn sbuf_data(b: *const STATIC_BUFFER) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sbuf_size(b: *mut STATIC_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sbuf_count(b: *mut STATIC_BUFFER) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sbuf_put(
        b: *mut STATIC_BUFFER,
        offset: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_char,
        data_size: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn sbuf_append(
        b: *mut STATIC_BUFFER,
        data: *mut ::std::os::raw::c_char,
        data_size: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn sbuf_truncate(b: *mut STATIC_BUFFER, count: ::std::os::raw::c_uint) -> bool;
}
extern "C" {
    pub fn Accumulator_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Accumulator_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Accumulator_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Accumulator_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Accumulator_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Accumulator_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Accumulator_Name(object_instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Accumulator_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Accumulator_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Accumulator_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Accumulator_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Accumulator_Units_Set(instance: u32, units: u16) -> bool;
}
extern "C" {
    pub fn Accumulator_Units(instance: u32) -> u16;
}
extern "C" {
    pub fn Accumulator_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Accumulator_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Accumulator_Present_Value(object_instance: u32) -> BACNET_UNSIGNED_INTEGER;
}
extern "C" {
    pub fn Accumulator_Present_Value_Set(
        object_instance: u32,
        value: BACNET_UNSIGNED_INTEGER,
    ) -> bool;
}
extern "C" {
    pub fn Accumulator_Max_Pres_Value(object_instance: u32) -> BACNET_UNSIGNED_INTEGER;
}
extern "C" {
    pub fn Accumulator_Max_Pres_Value_Set(
        object_instance: u32,
        value: BACNET_UNSIGNED_INTEGER,
    ) -> bool;
}
extern "C" {
    pub fn Accumulator_Scale_Integer(object_instance: u32) -> i32;
}
extern "C" {
    pub fn Accumulator_Scale_Integer_Set(object_instance: u32, arg1: i32) -> bool;
}
extern "C" {
    pub fn Accumulator_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_CREDENTIAL_DESCR {
    pub global_identifier: u32,
    pub reliability: BACNET_RELIABILITY,
    pub credential_status: bool,
    pub reasons_count: u32,
    pub reason_for_disable: [BACNET_ACCESS_CREDENTIAL_DISABLE_REASON; 4usize],
    pub auth_factors_count: u32,
    pub auth_factors: [BACNET_CREDENTIAL_AUTHENTICATION_FACTOR; 4usize],
    pub activation_time: BACNET_DATE_TIME,
    pub expiration_time: BACNET_DATE_TIME,
    pub credential_disable: BACNET_ACCESS_CREDENTIAL_DISABLE,
    pub assigned_access_rights_count: u32,
    pub assigned_access_rights: [BACNET_ASSIGNED_ACCESS_RIGHTS; 4usize],
}
#[test]
fn bindgen_test_layout_ACCESS_CREDENTIAL_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_CREDENTIAL_DESCR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_CREDENTIAL_DESCR>(),
        6136usize,
        concat!("Size of: ", stringify!(ACCESS_CREDENTIAL_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_CREDENTIAL_DESCR>(),
        8usize,
        concat!("Alignment of ", stringify!(ACCESS_CREDENTIAL_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(global_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).credential_status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(credential_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reasons_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(reasons_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reason_for_disable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(reason_for_disable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_factors_count) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(auth_factors_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_factors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(auth_factors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).activation_time) as usize - ptr as usize },
        6024usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(activation_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expiration_time) as usize - ptr as usize },
        6034usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(expiration_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).credential_disable) as usize - ptr as usize },
        6044usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(credential_disable)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).assigned_access_rights_count) as usize - ptr as usize
        },
        6048usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(assigned_access_rights_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).assigned_access_rights) as usize - ptr as usize },
        6052usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_CREDENTIAL_DESCR),
            "::",
            stringify!(assigned_access_rights)
        )
    );
}
extern "C" {
    pub fn Access_Credential_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Access_Credential_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Credential_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Credential_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Access_Credential_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Credential_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Credential_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Access_Credential_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_Credential_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Access_Credential_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Access_Credential_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Credential_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Credential_Cleanup();
}
extern "C" {
    pub fn Access_Credential_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_DOOR_DESCR {
    pub value_active: [bool; 16usize],
    pub priority_array: [BACNET_DOOR_VALUE; 16usize],
    pub relinquish_default: BACNET_DOOR_VALUE,
    pub event_state: BACNET_EVENT_STATE,
    pub reliability: BACNET_RELIABILITY,
    pub out_of_service: bool,
    pub door_status: BACNET_DOOR_STATUS,
    pub lock_status: BACNET_LOCK_STATUS,
    pub secured_status: BACNET_DOOR_SECURED_STATUS,
    pub door_pulse_time: u32,
    pub door_extended_pulse_time: u32,
    pub door_unlock_delay_time: u32,
    pub door_open_too_long_time: u32,
    pub door_alarm_state: BACNET_DOOR_ALARM_STATE,
}
#[test]
fn bindgen_test_layout_ACCESS_DOOR_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_DOOR_DESCR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_DOOR_DESCR>(),
        128usize,
        concat!("Size of: ", stringify!(ACCESS_DOOR_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_DOOR_DESCR>(),
        4usize,
        concat!("Alignment of ", stringify!(ACCESS_DOOR_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_active) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(value_active)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(priority_array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).relinquish_default) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(relinquish_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_state) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(event_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_of_service) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(out_of_service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).door_status) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(door_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_status) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(lock_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secured_status) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(secured_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).door_pulse_time) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(door_pulse_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).door_extended_pulse_time) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(door_extended_pulse_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).door_unlock_delay_time) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(door_unlock_delay_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).door_open_too_long_time) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(door_open_too_long_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).door_alarm_state) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_DOOR_DESCR),
            "::",
            stringify!(door_alarm_state)
        )
    );
}
extern "C" {
    pub fn Access_Door_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Access_Door_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Door_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Door_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Access_Door_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Door_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Door_Present_Value(object_instance: u32) -> BACNET_DOOR_VALUE;
}
extern "C" {
    pub fn Access_Door_Present_Value_Priority(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Door_Present_Value_Set(
        object_instance: u32,
        value: BACNET_DOOR_VALUE,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Access_Door_Present_Value_Relinquish(
        object_instance: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Access_Door_Relinquish_Default(object_instance: u32) -> BACNET_DOOR_VALUE;
}
extern "C" {
    pub fn Access_Door_Relinquish_Default_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Access_Door_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Door_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Access_Door_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Access_Door_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Access_Door_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_Door_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Access_Door_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_Door_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Door_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Access_Door_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Access_Door_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Access_Door_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Door_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Door_Cleanup();
}
extern "C" {
    pub fn Access_Door_Init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ACCESS_POINT_DESCR {
    pub event_state: BACNET_EVENT_STATE,
    pub reliability: BACNET_RELIABILITY,
    pub out_of_service: bool,
    pub authentication_status: BACNET_AUTHENTICATION_STATUS,
    pub active_authentication_policy: u32,
    pub number_of_authentication_policies: u32,
    pub authorization_mode: BACNET_AUTHORIZATION_MODE,
    pub access_event: BACNET_ACCESS_EVENT,
    pub access_event_tag: u32,
    pub access_event_time: BACNET_TIMESTAMP,
    pub access_event_credential: BACNET_DEVICE_OBJECT_REFERENCE,
    pub num_doors: u32,
    pub access_doors: [BACNET_DEVICE_OBJECT_REFERENCE; 4usize],
    pub priority_for_writing: u8,
}
#[test]
fn bindgen_test_layout_ACCESS_POINT_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_POINT_DESCR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_POINT_DESCR>(),
        136usize,
        concat!("Size of: ", stringify!(ACCESS_POINT_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_POINT_DESCR>(),
        4usize,
        concat!("Alignment of ", stringify!(ACCESS_POINT_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(event_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_of_service) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(out_of_service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authentication_status) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(authentication_status)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).active_authentication_policy) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(active_authentication_policy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).number_of_authentication_policies) as usize - ptr as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(number_of_authentication_policies)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).authorization_mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(authorization_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_event) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(access_event)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_event_tag) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(access_event_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_event_time) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(access_event_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_event_credential) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(access_event_credential)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_doors) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(num_doors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).access_doors) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(access_doors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priority_for_writing) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_POINT_DESCR),
            "::",
            stringify!(priority_for_writing)
        )
    );
}
extern "C" {
    pub fn Access_Point_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Access_Point_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Point_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Point_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Access_Point_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Point_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Point_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Access_Point_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_Point_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Point_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Access_Point_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Access_Point_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Access_Point_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Point_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Point_Cleanup();
}
extern "C" {
    pub fn Access_Point_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_RIGHTS_DESCR {
    pub global_identifier: u32,
    pub reliability: BACNET_RELIABILITY,
    pub enable: bool,
    pub negative_access_rules_count: u32,
    pub positive_access_rules_count: u32,
    pub negative_access_rules: [BACNET_ACCESS_RULE; 4usize],
    pub positive_access_rules: [BACNET_ACCESS_RULE; 4usize],
}
#[test]
fn bindgen_test_layout_ACCESS_RIGHTS_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_RIGHTS_DESCR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_RIGHTS_DESCR>(),
        728usize,
        concat!("Size of: ", stringify!(ACCESS_RIGHTS_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_RIGHTS_DESCR>(),
        8usize,
        concat!("Alignment of ", stringify!(ACCESS_RIGHTS_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(global_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_access_rules_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(negative_access_rules_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_access_rules_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(positive_access_rules_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_access_rules) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(negative_access_rules)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_access_rules) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_RIGHTS_DESCR),
            "::",
            stringify!(positive_access_rules)
        )
    );
}
extern "C" {
    pub fn Access_Rights_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Access_Rights_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Rights_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Rights_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Access_Rights_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Rights_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Rights_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Access_Rights_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_Rights_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Access_Rights_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Access_Rights_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Rights_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Rights_Cleanup();
}
extern "C" {
    pub fn Access_Rights_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_USER_DESCR {
    pub global_identifier: u32,
    pub reliability: BACNET_RELIABILITY,
    pub user_type: BACNET_ACCESS_USER_TYPE,
    pub credentials_count: u32,
    pub credentials: [BACNET_DEVICE_OBJECT_REFERENCE; 4usize],
}
#[test]
fn bindgen_test_layout_ACCESS_USER_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_USER_DESCR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_USER_DESCR>(),
        80usize,
        concat!("Size of: ", stringify!(ACCESS_USER_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_USER_DESCR>(),
        4usize,
        concat!("Alignment of ", stringify!(ACCESS_USER_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_USER_DESCR),
            "::",
            stringify!(global_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_USER_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_USER_DESCR),
            "::",
            stringify!(user_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).credentials_count) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_USER_DESCR),
            "::",
            stringify!(credentials_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).credentials) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_USER_DESCR),
            "::",
            stringify!(credentials)
        )
    );
}
extern "C" {
    pub fn Access_User_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Access_User_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_User_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_User_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Access_User_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_User_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_User_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Access_User_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_User_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Access_User_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Access_User_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_User_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_User_Cleanup();
}
extern "C" {
    pub fn Access_User_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ACCESS_ZONE_DESCR {
    pub global_identifier: u32,
    pub occupancy_state: BACNET_ACCESS_ZONE_OCCUPANCY_STATE,
    pub event_state: BACNET_EVENT_STATE,
    pub reliability: BACNET_RELIABILITY,
    pub out_of_service: bool,
    pub entry_points_count: u32,
    pub exit_points_count: u32,
    pub entry_points: [BACNET_DEVICE_OBJECT_REFERENCE; 4usize],
    pub exit_points: [BACNET_DEVICE_OBJECT_REFERENCE; 4usize],
}
#[test]
fn bindgen_test_layout_ACCESS_ZONE_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<ACCESS_ZONE_DESCR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ACCESS_ZONE_DESCR>(),
        156usize,
        concat!("Size of: ", stringify!(ACCESS_ZONE_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<ACCESS_ZONE_DESCR>(),
        4usize,
        concat!("Alignment of ", stringify!(ACCESS_ZONE_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).global_identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(global_identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).occupancy_state) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(occupancy_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).event_state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(event_state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_of_service) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(out_of_service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_points_count) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(entry_points_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exit_points_count) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(exit_points_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).entry_points) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(entry_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).exit_points) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(ACCESS_ZONE_DESCR),
            "::",
            stringify!(exit_points)
        )
    );
}
extern "C" {
    pub fn Access_Zone_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Access_Zone_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Zone_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Zone_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Access_Zone_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Access_Zone_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Zone_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Access_Zone_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Access_Zone_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Zone_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Access_Zone_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Access_Zone_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Access_Zone_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Zone_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Access_Zone_Cleanup();
}
extern "C" {
    pub fn Access_Zone_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct analog_input_descr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Present_Value: f32,
    pub Reliability: BACNET_RELIABILITY,
    pub Out_Of_Service: bool,
    pub Units: u8,
    pub Prior_Value: f32,
    pub COV_Increment: f32,
    pub Changed: bool,
}
#[test]
fn bindgen_test_layout_analog_input_descr() {
    const UNINIT: ::std::mem::MaybeUninit<analog_input_descr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<analog_input_descr>(),
        28usize,
        concat!("Size of: ", stringify!(analog_input_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<analog_input_descr>(),
        4usize,
        concat!("Alignment of ", stringify!(analog_input_descr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present_Value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(Present_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reliability) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(Reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Out_Of_Service) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(Out_Of_Service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Units) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(Units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prior_Value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(Prior_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COV_Increment) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(COV_Increment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Changed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_input_descr),
            "::",
            stringify!(Changed)
        )
    );
}
impl analog_input_descr {
    #[inline]
    pub fn Event_State(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Event_State(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Event_State: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Event_State: u32 = unsafe { ::std::mem::transmute(Event_State) };
            Event_State as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ANALOG_INPUT_DESCR = analog_input_descr;
extern "C" {
    pub fn Analog_Input_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Analog_Input_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Input_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Input_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Analog_Input_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Input_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Input_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Input_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Input_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Analog_Input_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Input_Units_Set(instance: u32, units: u16) -> bool;
}
extern "C" {
    pub fn Analog_Input_Units(instance: u32) -> u16;
}
extern "C" {
    pub fn Analog_Input_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Analog_Input_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Analog_Input_Present_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Input_Present_Value_Set(object_instance: u32, value: f32);
}
extern "C" {
    pub fn Analog_Input_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Input_Out_Of_Service_Set(object_instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Analog_Input_Event_State(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Input_Event_State_Set(
        object_instance: u32,
        state: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Input_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Input_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Analog_Input_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Input_COV_Increment(instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Input_COV_Increment_Set(instance: u32, value: f32);
}
extern "C" {
    pub fn Analog_Input_Intrinsic_Reporting(object_instance: u32);
}
extern "C" {
    pub fn Analog_Input_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Input_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Input_Cleanup();
}
extern "C" {
    pub fn Analog_Input_Init();
}
#[doc = " @brief Callback for gateway write present value request\n @param  object_instance - object-instance number of the object\n @param  old_value - floating point analog value prior to write\n @param  value - floating point analog value of the write"]
pub type analog_output_write_present_value_callback =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32, old_value: f32, value: f32)>;
extern "C" {
    pub fn Analog_Output_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Analog_Output_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Output_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Analog_Output_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Output_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Present_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Output_Present_Value_Set(
        object_instance: u32,
        value: f32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Output_Present_Value_Relinquish(
        object_instance: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Output_Present_Value_Priority(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Output_Write_Present_Value_Callback_Set(
        cb: analog_output_write_present_value_callback,
    );
}
extern "C" {
    pub fn Analog_Output_Relinquish_Default(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Output_Relinquish_Default_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Analog_Output_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Output_COV_Increment(instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Output_COV_Increment_Set(instance: u32, value: f32);
}
extern "C" {
    pub fn Analog_Output_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Output_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Output_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Analog_Output_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Output_Units_Set(instance: u32, units: u16) -> bool;
}
extern "C" {
    pub fn Analog_Output_Units(instance: u32) -> u16;
}
extern "C" {
    pub fn Analog_Output_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Analog_Output_Overridden(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Overridden_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Analog_Output_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Analog_Output_Reliability_Set(object_instance: u32, value: BACNET_RELIABILITY) -> bool;
}
extern "C" {
    pub fn Analog_Output_Min_Pres_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Output_Min_Pres_Value_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Max_Pres_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Output_Max_Pres_Value_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Analog_Output_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Analog_Output_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Output_Cleanup();
}
extern "C" {
    pub fn Analog_Output_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct analog_value_descr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Out_Of_Service: bool,
    pub Units: u16,
    pub Present_Value: f32,
    pub Prior_Value: f32,
    pub COV_Increment: f32,
    pub Changed: bool,
}
#[test]
fn bindgen_test_layout_analog_value_descr() {
    const UNINIT: ::std::mem::MaybeUninit<analog_value_descr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<analog_value_descr>(),
        20usize,
        concat!("Size of: ", stringify!(analog_value_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<analog_value_descr>(),
        4usize,
        concat!("Alignment of ", stringify!(analog_value_descr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Out_Of_Service) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_value_descr),
            "::",
            stringify!(Out_Of_Service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Units) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_value_descr),
            "::",
            stringify!(Units)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present_Value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_value_descr),
            "::",
            stringify!(Present_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prior_Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_value_descr),
            "::",
            stringify!(Prior_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).COV_Increment) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_value_descr),
            "::",
            stringify!(COV_Increment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Changed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(analog_value_descr),
            "::",
            stringify!(Changed)
        )
    );
}
impl analog_value_descr {
    #[inline]
    pub fn Event_State(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Event_State(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Event_State: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Event_State: u32 = unsafe { ::std::mem::transmute(Event_State) };
            Event_State as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type ANALOG_VALUE_DESCR = analog_value_descr;
extern "C" {
    pub fn Analog_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Analog_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Analog_Value_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Value_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Value_Name(object_instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Analog_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Analog_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Analog_Value_Present_Value_Set(object_instance: u32, value: f32, priority: u8) -> bool;
}
extern "C" {
    pub fn Analog_Value_Present_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Value_Event_State(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Analog_Value_Event_State_Set(
        object_instance: u32,
        state: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Analog_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Value_COV_Increment(instance: u32) -> f32;
}
extern "C" {
    pub fn Analog_Value_COV_Increment_Set(instance: u32, value: f32);
}
extern "C" {
    pub fn Analog_Value_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Analog_Value_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Analog_Value_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Analog_Value_Reliability_Set(object_instance: u32, value: BACNET_RELIABILITY) -> bool;
}
extern "C" {
    pub fn Analog_Value_Units(instance: u32) -> u16;
}
extern "C" {
    pub fn Analog_Value_Units_Set(instance: u32, unit: u16) -> bool;
}
extern "C" {
    pub fn Analog_Value_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Value_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Analog_Value_Intrinsic_Reporting(object_instance: u32);
}
extern "C" {
    pub fn Analog_Value_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Value_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Analog_Value_Cleanup();
}
extern "C" {
    pub fn Analog_Value_Init();
}
extern "C" {
    pub fn BACfile_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn bacfile_object_name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn bacfile_object_name_set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn bacfile_valid_instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn bacfile_count() -> u32;
}
extern "C" {
    pub fn bacfile_index_to_instance(find_index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn bacfile_instance_to_index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn bacfile_file_type(object_instance: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bacfile_file_type_set(object_instance: u32, mime_type: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn bacfile_archive(instance: u32) -> bool;
}
extern "C" {
    pub fn bacfile_archive_set(instance: u32, status: bool) -> bool;
}
extern "C" {
    pub fn bacfile_read_only(instance: u32) -> bool;
}
extern "C" {
    pub fn bacfile_read_only_set(object_instance: u32, read_only: bool) -> bool;
}
extern "C" {
    pub fn bacfile_file_access_stream(object_instance: u32) -> bool;
}
extern "C" {
    pub fn bacfile_file_access_stream_set(object_instance: u32, access: bool) -> bool;
}
extern "C" {
    pub fn bacfile_file_size(instance: u32) -> BACNET_UNSIGNED_INTEGER;
}
extern "C" {
    pub fn bacfile_file_size_set(object_instance: u32, file_size: BACNET_UNSIGNED_INTEGER) -> bool;
}
extern "C" {
    pub fn bacfile_instance_from_tsm(invokeID: u8) -> u32;
}
extern "C" {
    pub fn bacfile_read_stream_data(data: *mut BACNET_ATOMIC_READ_FILE_DATA) -> bool;
}
extern "C" {
    pub fn bacfile_read_ack_stream_data(
        instance: u32,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> bool;
}
extern "C" {
    pub fn bacfile_write_stream_data(data: *mut BACNET_ATOMIC_WRITE_FILE_DATA) -> bool;
}
extern "C" {
    pub fn bacfile_read_record_data(data: *mut BACNET_ATOMIC_READ_FILE_DATA) -> bool;
}
extern "C" {
    pub fn bacfile_read_ack_record_data(
        instance: u32,
        data: *mut BACNET_ATOMIC_READ_FILE_DATA,
    ) -> bool;
}
extern "C" {
    pub fn bacfile_write_record_data(data: *mut BACNET_ATOMIC_WRITE_FILE_DATA) -> bool;
}
extern "C" {
    pub fn bacfile_read_property(rpdata: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bacfile_write_property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn bacfile_pathname(instance: u32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn bacfile_pathname_set(instance: u32, pathname: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn bacfile_pathname_instance(pathname: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn bacfile_read(object_instance: u32, buffer: *mut u8, buffer_size: u32) -> u32;
}
extern "C" {
    pub fn bacfile_create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn bacfile_delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn bacfile_cleanup();
}
extern "C" {
    pub fn bacfile_init();
}
extern "C" {
    pub fn Binary_Input_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Binary_Input_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Input_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Input_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Binary_Input_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Input_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Input_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Input_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Input_Present_Value(object_instance: u32) -> BACNET_BINARY_PV;
}
extern "C" {
    pub fn Binary_Input_Present_Value_Set(object_instance: u32, value: BACNET_BINARY_PV) -> bool;
}
extern "C" {
    pub fn Binary_Input_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Input_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Input_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Binary_Input_Reliability_Set(object_instance: u32, value: BACNET_RELIABILITY) -> bool;
}
extern "C" {
    pub fn Binary_Input_Inactive_Text(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Input_Inactive_Text_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Input_Active_Text(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Input_Active_Text_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Input_Polarity(object_instance: u32) -> BACNET_POLARITY;
}
extern "C" {
    pub fn Binary_Input_Polarity_Set(object_instance: u32, polarity: BACNET_POLARITY) -> bool;
}
extern "C" {
    pub fn Binary_Input_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Input_Out_Of_Service_Set(object_instance: u32, value: bool);
}
extern "C" {
    pub fn Binary_Input_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Input_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Input_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Binary_Input_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Binary_Input_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Binary_Input_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Input_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Input_Cleanup();
}
extern "C" {
    pub fn Binary_Input_Init();
}
#[doc = " @brief Callback for gateway write present value request\n @param  object_instance - object-instance number of the object\n @param  old_value - binary preset-value prior to write\n @param  value - binary preset-value of the write"]
pub type binary_output_write_present_value_callback = ::std::option::Option<
    unsafe extern "C" fn(
        object_instance: u32,
        old_value: BACNET_BINARY_PV,
        value: BACNET_BINARY_PV,
    ),
>;
extern "C" {
    pub fn Binary_Output_Init();
}
extern "C" {
    pub fn Binary_Output_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Binary_Output_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Output_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Output_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Binary_Output_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Output_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Output_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Output_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Inactive_Text(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Output_Inactive_Text_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Active_Text(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Output_Active_Text_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Binary_Output_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Binary_Output_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Output_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Binary_Output_Present_Value(instance: u32) -> BACNET_BINARY_PV;
}
extern "C" {
    pub fn Binary_Output_Present_Value_Set(
        instance: u32,
        binary_value: BACNET_BINARY_PV,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Present_Value_Relinquish(
        instance: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Present_Value_Priority(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Output_Write_Present_Value_Callback_Set(
        cb: binary_output_write_present_value_callback,
    );
}
extern "C" {
    pub fn Binary_Output_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Output_Out_Of_Service_Set(object_instance: u32, value: bool);
}
extern "C" {
    pub fn Binary_Output_Polarity(instance: u32) -> BACNET_POLARITY;
}
extern "C" {
    pub fn Binary_Output_Polarity_Set(object_instance: u32, polarity: BACNET_POLARITY) -> bool;
}
extern "C" {
    pub fn Binary_Output_Reliability_Set(object_instance: u32, value: BACNET_RELIABILITY) -> bool;
}
extern "C" {
    pub fn Binary_Output_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Binary_Output_Relinquish_Default(object_instance: u32) -> BACNET_BINARY_PV;
}
extern "C" {
    pub fn Binary_Output_Relinquish_Default_Set(
        object_instance: u32,
        value: BACNET_BINARY_PV,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Output_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Output_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Output_Cleanup();
}
extern "C" {
    pub fn Binary_Value_Init();
}
extern "C" {
    pub fn Binary_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Binary_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Binary_Value_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Binary_Value_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Value_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Value_Name(object_instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Value_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Value_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Value_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Binary_Value_Reliability_Set(object_instance: u32, value: BACNET_RELIABILITY) -> bool;
}
extern "C" {
    pub fn Binary_Value_Inactive_Text(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Value_Inactive_Text_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Value_Active_Text(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Binary_Value_Active_Text_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Binary_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Binary_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Binary_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Binary_Value_Present_Value(instance: u32) -> BACNET_BINARY_PV;
}
extern "C" {
    pub fn Binary_Value_Present_Value_Set(instance: u32, value: BACNET_BINARY_PV) -> bool;
}
extern "C" {
    pub fn Binary_Value_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Value_Out_Of_Service_Set(instance: u32, value: bool);
}
extern "C" {
    pub fn Binary_Value_Polarity(instance: u32) -> BACNET_POLARITY;
}
extern "C" {
    pub fn Binary_Value_Polarity_Set(object_instance: u32, polarity: BACNET_POLARITY) -> bool;
}
extern "C" {
    pub fn Binary_Value_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Value_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Binary_Value_Cleanup();
}
extern "C" {
    pub fn Lighting_Output_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Lighting_Output_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Lighting_Output_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Lighting_Output_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Lighting_Output_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Present_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Lighting_Output_Present_Value_Priority(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Lighting_Output_Present_Value_Set(
        object_instance: u32,
        value: f32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Present_Value_Relinquish(
        object_instance: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Relinquish_Default(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Lighting_Output_Relinquish_Default_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Lighting_Output_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_COV_Increment(instance: u32) -> f32;
}
extern "C" {
    pub fn Lighting_Output_COV_Increment_Set(instance: u32, value: f32);
}
extern "C" {
    pub fn Lighting_Output_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Lighting_Output_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Lighting_Output_Lighting_Command_Set(
        object_instance: u32,
        value: *mut BACNET_LIGHTING_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Lighting_Command(
        object_instance: u32,
        value: *mut BACNET_LIGHTING_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_In_Progress(object_instance: u32) -> BACNET_LIGHTING_IN_PROGRESS;
}
extern "C" {
    pub fn Lighting_Output_In_Progress_Set(
        object_instance: u32,
        in_progress: BACNET_LIGHTING_IN_PROGRESS,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Tracking_Value(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Lighting_Output_Tracking_Value_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Blink_Warn_Enable(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Blink_Warn_Enable_Set(object_instance: u32, enable: bool) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Egress_Time(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Lighting_Output_Egress_Time_Set(object_instance: u32, seconds: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Egress_Active(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Default_Fade_Time(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Lighting_Output_Default_Fade_Time_Set(object_instance: u32, milliseconds: u32) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Default_Ramp_Rate(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Lighting_Output_Default_Ramp_Rate_Set(
        object_instance: u32,
        percent_per_second: f32,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Default_Step_Increment(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Lighting_Output_Default_Step_Increment_Set(
        object_instance: u32,
        step_increment: f32,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Default_Priority(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Lighting_Output_Default_Priority_Set(
        object_instance: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Lighting_Output_Timer(milliseconds: u16);
}
extern "C" {
    pub fn Lighting_Output_Init();
}
extern "C" {
    pub fn Lighting_Output_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Lighting_Output_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BACnet_Channel_Value_t {
    pub tag: u8,
    pub type_: BACnet_Channel_Value_t__bindgen_ty_1,
    pub next: *mut BACnet_Channel_Value_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union BACnet_Channel_Value_t__bindgen_ty_1 {
    pub Boolean: bool,
    pub Unsigned_Int: u32,
    pub Signed_Int: i32,
    pub Real: f32,
    pub Double: f64,
    pub Enumerated: u32,
    pub Lighting_Command: BACNET_LIGHTING_COMMAND,
}
#[test]
fn bindgen_test_layout_BACnet_Channel_Value_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Channel_Value_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Channel_Value_t__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Channel_Value_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Unsigned_Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Unsigned_Int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Signed_Int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Signed_Int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Real) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Real)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Enumerated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Enumerated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Lighting_Command) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t__bindgen_ty_1),
            "::",
            stringify!(Lighting_Command)
        )
    );
}
#[test]
fn bindgen_test_layout_BACnet_Channel_Value_t() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_Channel_Value_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_Channel_Value_t>(),
        48usize,
        concat!("Size of: ", stringify!(BACnet_Channel_Value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_Channel_Value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(BACnet_Channel_Value_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_Channel_Value_t),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_CHANNEL_VALUE = BACnet_Channel_Value_t;
extern "C" {
    pub fn Channel_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Channel_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Channel_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Channel_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Channel_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Channel_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Channel_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Channel_Name_Set(object_instance: u32, new_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn Channel_Read_Property(rpdata: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Channel_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Channel_Present_Value(object_instance: u32) -> *mut BACNET_CHANNEL_VALUE;
}
extern "C" {
    pub fn Channel_Present_Value_Set(
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Channel_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Channel_Out_Of_Service_Set(object_instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Channel_Last_Priority(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Channel_Write_Status(object_instance: u32) -> BACNET_WRITE_STATUS;
}
extern "C" {
    pub fn Channel_Number(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Channel_Number_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Channel_Reference_List_Member_Count(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Channel_Reference_List_Member_Element(
        object_instance: u32,
        element: ::std::os::raw::c_uint,
    ) -> *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE;
}
extern "C" {
    pub fn Channel_Reference_List_Member_Element_Set(
        object_instance: u32,
        array_index: ::std::os::raw::c_uint,
        pMemberSrc: *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    ) -> bool;
}
extern "C" {
    pub fn Channel_Reference_List_Member_Element_Add(
        object_instance: u32,
        pMemberSrc: *mut BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Channel_Reference_List_Member_Local_Add(
        object_instance: u32,
        type_: BACNET_OBJECT_TYPE,
        instance: u32,
        propertyIdentifier: BACNET_PROPERTY_ID,
        arrayIndex: u32,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Channel_Control_Groups_Element(object_instance: u32, array_index: i32) -> u16;
}
extern "C" {
    pub fn Channel_Control_Groups_Element_Set(
        object_instance: u32,
        array_index: i32,
        value: u16,
    ) -> bool;
}
extern "C" {
    pub fn Channel_Value_Copy(
        cvalue: *mut BACNET_CHANNEL_VALUE,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Channel_Value_Encode(
        apdu: *mut u8,
        apdu_max: ::std::os::raw::c_int,
        value: *mut BACNET_CHANNEL_VALUE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Channel_Coerce_Data_Encode(
        apdu: *mut u8,
        max_apdu: ::std::os::raw::c_uint,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
        tag: BACNET_APPLICATION_TAG,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Channel_Write_Member_Value(
        wp_data: *mut BACNET_WRITE_PROPERTY_DATA,
        value: *mut BACNET_APPLICATION_DATA_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Channel_Init();
}
#[doc = " @brief Callback for gateway write present value request\n @param  object_instance - object-instance number of the object\n @param  old_value - BACnetXYColor value prior to write\n @param  value - BACnetXYColor value of the write"]
pub type color_write_present_value_callback = ::std::option::Option<
    unsafe extern "C" fn(
        object_instance: u32,
        old_value: *mut BACNET_XY_COLOR,
        value: *mut BACNET_XY_COLOR,
    ),
>;
extern "C" {
    pub fn Color_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Color_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Color_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Color_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Color_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Color_Name_Set(object_instance: u32, new_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn Color_Read_Property(rpdata: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Color_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Color_Present_Value_Set(object_instance: u32, value: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn Color_Present_Value(object_instance: u32, value: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn Color_Write_Present_Value_Callback_Set(cb: color_write_present_value_callback);
}
extern "C" {
    pub fn Color_Tracking_Value_Set(object_instance: u32, value: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn Color_Tracking_Value(object_instance: u32, value: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn Color_Command(object_instance: u32, value: *mut BACNET_COLOR_COMMAND) -> bool;
}
extern "C" {
    pub fn Color_Command_Set(object_instance: u32, value: *mut BACNET_COLOR_COMMAND) -> bool;
}
extern "C" {
    pub fn Color_Default_Color_Set(object_instance: u32, value: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn Color_Default_Color(object_instance: u32, value: *mut BACNET_XY_COLOR) -> bool;
}
extern "C" {
    pub fn Color_Default_Fade_Time(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Default_Fade_Time_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_In_Progress(object_instance: u32) -> BACNET_COLOR_OPERATION_IN_PROGRESS;
}
extern "C" {
    pub fn Color_In_Progress_Set(
        object_instance: u32,
        value: BACNET_COLOR_OPERATION_IN_PROGRESS,
    ) -> bool;
}
extern "C" {
    pub fn Color_Transition(object_instance: u32) -> BACNET_COLOR_TRANSITION;
}
extern "C" {
    pub fn Color_Transition_Set(object_instance: u32, value: BACNET_COLOR_TRANSITION) -> bool;
}
extern "C" {
    pub fn Color_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Color_Description_Set(instance: u32, new_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn Color_Write_Enabled(instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Write_Enable(instance: u32);
}
extern "C" {
    pub fn Color_Write_Disable(instance: u32);
}
extern "C" {
    pub fn Color_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Cleanup();
}
extern "C" {
    pub fn Color_Init();
}
#[doc = " @brief Callback for gateway write present value request\n @param  object_instance - object-instance number of the object\n @param  old_value - 32-bit value prior to write\n @param  value - 32-bit value of the write"]
pub type color_temperature_write_present_value_callback =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32, old_value: u32, value: u32)>;
extern "C" {
    pub fn Color_Temperature_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Color_Temperature_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Color_Temperature_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Color_Temperature_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Color_Temperature_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Present_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Present_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Write_Present_Value_Callback_Set(
        cb: color_temperature_write_present_value_callback,
    );
}
extern "C" {
    pub fn Color_Temperature_Tracking_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Tracking_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Min_Pres_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Min_Pres_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Max_Pres_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Max_Pres_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Command(
        object_instance: u32,
        value: *mut BACNET_COLOR_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Command_Set(
        object_instance: u32,
        value: *mut BACNET_COLOR_COMMAND,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Default_Color_Temperature_Set(
        object_instance: u32,
        value: u32,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Default_Color_Temperature(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Default_Fade_Time(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Default_Fade_Time_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Default_Ramp_Rate(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Default_Ramp_Rate_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Default_Step_Increment(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Color_Temperature_Default_Step_Increment_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_In_Progress(
        object_instance: u32,
    ) -> BACNET_COLOR_OPERATION_IN_PROGRESS;
}
extern "C" {
    pub fn Color_Temperature_In_Progress_Set(
        object_instance: u32,
        value: BACNET_COLOR_OPERATION_IN_PROGRESS,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Transition(object_instance: u32) -> BACNET_COLOR_TRANSITION;
}
extern "C" {
    pub fn Color_Temperature_Transition_Set(
        object_instance: u32,
        value: BACNET_COLOR_TRANSITION,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Color_Temperature_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Write_Enabled(instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Write_Enable(instance: u32);
}
extern "C" {
    pub fn Color_Temperature_Write_Disable(instance: u32);
}
extern "C" {
    pub fn Color_Temperature_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Color_Temperature_Cleanup();
}
extern "C" {
    pub fn Color_Temperature_Init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bacnet_action_list {
    pub Device_Id: BACNET_OBJECT_ID,
    pub Object_Id: BACNET_OBJECT_ID,
    pub Property_Identifier: BACNET_PROPERTY_ID,
    pub Property_Array_Index: u32,
    pub Value: BACNET_APPLICATION_DATA_VALUE,
    pub Priority: u8,
    pub Post_Delay: u32,
    pub Quit_On_Failure: bool,
    pub Write_Successful: bool,
    pub next: *mut bacnet_action_list,
}
#[test]
fn bindgen_test_layout_bacnet_action_list() {
    const UNINIT: ::std::mem::MaybeUninit<bacnet_action_list> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bacnet_action_list>(),
        6848usize,
        concat!("Size of: ", stringify!(bacnet_action_list))
    );
    assert_eq!(
        ::std::mem::align_of::<bacnet_action_list>(),
        8usize,
        concat!("Alignment of ", stringify!(bacnet_action_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Device_Id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Device_Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Id) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Object_Id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Property_Identifier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Property_Identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Property_Array_Index) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Property_Array_Index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        6824usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Post_Delay) as usize - ptr as usize },
        6828usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Post_Delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Quit_On_Failure) as usize - ptr as usize },
        6832usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Quit_On_Failure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Write_Successful) as usize - ptr as usize },
        6833usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(Write_Successful)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        6840usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_action_list),
            "::",
            stringify!(next)
        )
    );
}
pub type BACNET_ACTION_LIST = bacnet_action_list;
extern "C" {
    pub fn cl_encode_apdu(apdu: *mut u8, bcl: *mut BACNET_ACTION_LIST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cl_decode_apdu(
        apdu: *mut u8,
        apdu_len: ::std::os::raw::c_uint,
        tag: BACNET_APPLICATION_TAG,
        bcl: *mut BACNET_ACTION_LIST,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct command_descr {
    pub Present_Value: u32,
    pub In_Process: bool,
    pub All_Writes_Successful: bool,
    pub Action: [BACNET_ACTION_LIST; 8usize],
}
#[test]
fn bindgen_test_layout_command_descr() {
    const UNINIT: ::std::mem::MaybeUninit<command_descr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<command_descr>(),
        54792usize,
        concat!("Size of: ", stringify!(command_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<command_descr>(),
        8usize,
        concat!("Alignment of ", stringify!(command_descr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present_Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(command_descr),
            "::",
            stringify!(Present_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).In_Process) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(command_descr),
            "::",
            stringify!(In_Process)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).All_Writes_Successful) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(command_descr),
            "::",
            stringify!(All_Writes_Successful)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(command_descr),
            "::",
            stringify!(Action)
        )
    );
}
pub type COMMAND_DESCR = command_descr;
extern "C" {
    pub fn Command_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Command_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Command_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Command_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Command_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Command_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Command_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Command_Name_Set(object_instance: u32, new_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn Command_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Command_Description_Set(instance: u32, new_name: *mut ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn Command_Read_Property(rpdata: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Command_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Command_Present_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Command_Present_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Command_In_Process(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Command_In_Process_Set(object_instance: u32, value: bool) -> bool;
}
extern "C" {
    pub fn Command_All_Writes_Successful(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Command_All_Writes_Successful_Set(object_instance: u32, value: bool) -> bool;
}
extern "C" {
    pub fn Command_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Command_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Command_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Command_COV_Increment(instance: u32) -> f32;
}
extern "C" {
    pub fn Command_COV_Increment_Set(instance: u32, value: f32);
}
extern "C" {
    pub fn Command_Intrinsic_Reporting(object_instance: u32);
}
extern "C" {
    pub fn Command_Init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CREDENTIAL_DATA_INPUT_DESCR {
    pub present_value: BACNET_AUTHENTICATION_FACTOR,
    pub reliability: BACNET_RELIABILITY,
    pub out_of_service: bool,
    pub supported_formats_count: u32,
    pub supported_formats: [BACNET_AUTHENTICATION_FACTOR_FORMAT; 4usize],
    pub timestamp: BACNET_TIMESTAMP,
}
#[test]
fn bindgen_test_layout_CREDENTIAL_DATA_INPUT_DESCR() {
    const UNINIT: ::std::mem::MaybeUninit<CREDENTIAL_DATA_INPUT_DESCR> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CREDENTIAL_DATA_INPUT_DESCR>(),
        1560usize,
        concat!("Size of: ", stringify!(CREDENTIAL_DATA_INPUT_DESCR))
    );
    assert_eq!(
        ::std::mem::align_of::<CREDENTIAL_DATA_INPUT_DESCR>(),
        8usize,
        concat!("Alignment of ", stringify!(CREDENTIAL_DATA_INPUT_DESCR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).present_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CREDENTIAL_DATA_INPUT_DESCR),
            "::",
            stringify!(present_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reliability) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(CREDENTIAL_DATA_INPUT_DESCR),
            "::",
            stringify!(reliability)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out_of_service) as usize - ptr as usize },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(CREDENTIAL_DATA_INPUT_DESCR),
            "::",
            stringify!(out_of_service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_formats_count) as usize - ptr as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(CREDENTIAL_DATA_INPUT_DESCR),
            "::",
            stringify!(supported_formats_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).supported_formats) as usize - ptr as usize },
        1500usize,
        concat!(
            "Offset of field: ",
            stringify!(CREDENTIAL_DATA_INPUT_DESCR),
            "::",
            stringify!(supported_formats)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(CREDENTIAL_DATA_INPUT_DESCR),
            "::",
            stringify!(timestamp)
        )
    );
}
extern "C" {
    pub fn Credential_Data_Input_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Credential_Data_Input_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Credential_Data_Input_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Credential_Data_Input_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Credential_Data_Input_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Credential_Data_Input_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Credential_Data_Input_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Credential_Data_Input_Cleanup();
}
extern "C" {
    pub fn Credential_Data_Input_Init();
}
extern "C" {
    pub fn CharacterString_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn CharacterString_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn CharacterString_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn CharacterString_Value_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn CharacterString_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CharacterString_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Present_Value(
        object_instance: u32,
        value: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Present_Value_Set(
        object_instance: u32,
        value: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Description_Set(
        object_instance: u32,
        text_string: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn CharacterString_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn CharacterString_Value_Init();
}
#[doc = " Called so a BACnet object can perform any necessary initialization.\n @ingroup ObjHelpers"]
pub type object_init_function = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Counts the number of objects of this type.\n @ingroup ObjHelpers\n @return Count of implemented objects of this type."]
pub type object_count_function =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_uint>;
#[doc = " Maps an object index position to its corresponding BACnet object instance number.\n @ingroup ObjHelpers\n @param index [in] The index of the object, in the array of objects of its type.\n @return The BACnet object instance number to be used in a BACNET_OBJECT_ID."]
pub type object_index_to_instance_function =
    ::std::option::Option<unsafe extern "C" fn(index: ::std::os::raw::c_uint) -> u32>;
#[doc = " Provides the BACnet Object_Name for a given object instance of this type.\n @ingroup ObjHelpers\n @param object_instance [in] The object instance number to be looked up.\n @param object_name [in,out] Pointer to a character_string structure that\n         will hold a copy of the object name if this is a valid object_instance.\n @return True if the object_instance is valid and object_name has been\n         filled with a copy of the Object's name."]
pub type object_name_function = ::std::option::Option<
    unsafe extern "C" fn(object_instance: u32, object_name: *mut BACNET_CHARACTER_STRING) -> bool,
>;
#[doc = " Look in the table of objects of this type, and see if this is a valid\n  instance number.\n @ingroup ObjHelpers\n @param [in] The object instance number to be looked up.\n @return True if the object instance refers to a valid object of this type."]
pub type object_valid_instance_function =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32) -> bool>;
#[doc = " Helper function to step through an array of objects and find either the\n first one or the next one of a given type. Used to step through an array\n of objects which is not necessarily contiguous for each type i.e. the\n index for the 'n'th object of a given type is not necessarily 'n'.\n @ingroup ObjHelpers\n @param [in] The index of the current object or a value of ~0 to indicate\n start at the beginning.\n @return The index of the next object of the required type or ~0 (all bits\n == 1) to indicate no more objects found."]
pub type object_iterate_function = ::std::option::Option<
    unsafe extern "C" fn(current_index: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint,
>;
#[doc = " Look in the table of objects of this type, and get the COV Value List.\n @ingroup ObjHelpers\n @param [in] The object instance number to be looked up.\n @param [out] The value list\n @return True if the object instance supports this feature, and has changed."]
pub type object_value_list_function = ::std::option::Option<
    unsafe extern "C" fn(object_instance: u32, value_list: *mut BACNET_PROPERTY_VALUE) -> bool,
>;
#[doc = " Look in the table of objects for this instance to see if value changed.\n @ingroup ObjHelpers\n @param [in] The object instance number to be looked up.\n @return True if the object instance has changed."]
pub type object_cov_function =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32) -> bool>;
#[doc = " Look in the table of objects for this instance to clear the changed flag.\n @ingroup ObjHelpers\n @param [in] The object instance number to be looked up."]
pub type object_cov_clear_function =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32)>;
#[doc = " Intrinsic Reporting funcionality.\n @ingroup ObjHelpers\n @param [in] Object instance."]
pub type object_intrinsic_reporting_function =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32)>;
#[doc = " Defines the group of object helper functions for any supported Object.\n @ingroup ObjHelpers\n Each Object must provide some implementation of each of these helpers\n in order to properly support the handlers.  Eg, the ReadProperty handler\n handler_read_property() relies on the instance of Object_Read_Property\n for each Object type, or configure the function as NULL.\n In both appearance and operation, this group of functions acts like\n they are member functions of a C++ Object base class."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct object_functions {
    pub Object_Type: BACNET_OBJECT_TYPE,
    pub Object_Init: object_init_function,
    pub Object_Count: object_count_function,
    pub Object_Index_To_Instance: object_index_to_instance_function,
    pub Object_Valid_Instance: object_valid_instance_function,
    pub Object_Name: object_name_function,
    pub Object_Read_Property: read_property_function,
    pub Object_Write_Property: write_property_function,
    pub Object_RPM_List: rpm_property_lists_function,
    pub Object_RR_Info: rr_info_function,
    pub Object_Iterator: object_iterate_function,
    pub Object_Value_List: object_value_list_function,
    pub Object_COV: object_cov_function,
    pub Object_COV_Clear: object_cov_clear_function,
    pub Object_Intrinsic_Reporting: object_intrinsic_reporting_function,
    pub Object_Add_List_Element: list_element_function,
    pub Object_Remove_List_Element: list_element_function,
}
#[test]
fn bindgen_test_layout_object_functions() {
    const UNINIT: ::std::mem::MaybeUninit<object_functions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<object_functions>(),
        136usize,
        concat!("Size of: ", stringify!(object_functions))
    );
    assert_eq!(
        ::std::mem::align_of::<object_functions>(),
        8usize,
        concat!("Alignment of ", stringify!(object_functions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Init) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Index_To_Instance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Index_To_Instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Valid_Instance) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Valid_Instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Read_Property) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Read_Property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Write_Property) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Write_Property)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_RPM_List) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_RPM_List)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_RR_Info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_RR_Info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Iterator) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Iterator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Value_List) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Value_List)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_COV) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_COV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_COV_Clear) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_COV_Clear)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Intrinsic_Reporting) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Intrinsic_Reporting)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Add_List_Element) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Add_List_Element)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Remove_List_Element) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(object_functions),
            "::",
            stringify!(Object_Remove_List_Element)
        )
    );
}
#[doc = " Defines the group of object helper functions for any supported Object.\n @ingroup ObjHelpers\n Each Object must provide some implementation of each of these helpers\n in order to properly support the handlers.  Eg, the ReadProperty handler\n handler_read_property() relies on the instance of Object_Read_Property\n for each Object type, or configure the function as NULL.\n In both appearance and operation, this group of functions acts like\n they are member functions of a C++ Object base class."]
pub type object_functions_t = object_functions;
#[doc = " Structure to define the Object Properties common to all Objects."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct commonBacObj_s {
    #[doc = " The BACnet type of this object (ie, what class is this object from?).\n This property, of type BACnetObjectType, indicates membership in a\n particular object type class. Each inherited class will be of one type."]
    pub mObject_Type: BACNET_OBJECT_TYPE,
    #[doc = " The instance number for this class instance."]
    pub Object_Instance_Number: u32,
    #[doc = " Object Name; must be unique.\n This property, of type CharacterString, shall represent a name for\n the object that is unique within the BACnet Device that maintains it."]
    pub Object_Name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_commonBacObj_s() {
    const UNINIT: ::std::mem::MaybeUninit<commonBacObj_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<commonBacObj_s>(),
        40usize,
        concat!("Size of: ", stringify!(commonBacObj_s))
    );
    assert_eq!(
        ::std::mem::align_of::<commonBacObj_s>(),
        4usize,
        concat!("Alignment of ", stringify!(commonBacObj_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mObject_Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(commonBacObj_s),
            "::",
            stringify!(mObject_Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Instance_Number) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(commonBacObj_s),
            "::",
            stringify!(Object_Instance_Number)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(commonBacObj_s),
            "::",
            stringify!(Object_Name)
        )
    );
}
#[doc = " Structure to define the Object Properties common to all Objects."]
pub type COMMON_BAC_OBJECT = commonBacObj_s;
#[doc = " Structure to define the Properties of Device Objects which distinguish\n  one instance from another.\n  This structure only defines fields for properties that are unique to\n  a given Device object.  The rest may be fixed in device.c or hard-coded\n  into the read-property encoding.\n  This may be useful for implementations which manage multiple Devices,\n  eg, a Gateway."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devObj_s {
    #[doc = " The BACnet Device Address for this device; ->len depends on DLL type."]
    pub bacDevAddr: BACNET_ADDRESS,
    #[doc = " Structure for the Object Properties common to all Objects."]
    pub bacObj: COMMON_BAC_OBJECT,
    #[doc = " Device Description."]
    pub Description: [::std::os::raw::c_char; 64usize],
    #[doc = " The upcounter that shows if the Device ID or object structure has changed."]
    pub Database_Revision: u32,
}
#[test]
fn bindgen_test_layout_devObj_s() {
    const UNINIT: ::std::mem::MaybeUninit<devObj_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<devObj_s>(),
        128usize,
        concat!("Size of: ", stringify!(devObj_s))
    );
    assert_eq!(
        ::std::mem::align_of::<devObj_s>(),
        4usize,
        concat!("Alignment of ", stringify!(devObj_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bacDevAddr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(devObj_s),
            "::",
            stringify!(bacDevAddr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bacObj) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(devObj_s),
            "::",
            stringify!(bacObj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(devObj_s),
            "::",
            stringify!(Description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Database_Revision) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(devObj_s),
            "::",
            stringify!(Database_Revision)
        )
    );
}
#[doc = " Structure to define the Properties of Device Objects which distinguish\n  one instance from another.\n  This structure only defines fields for properties that are unique to\n  a given Device object.  The rest may be fixed in device.c or hard-coded\n  into the read-property encoding.\n  This may be useful for implementations which manage multiple Devices,\n  eg, a Gateway."]
pub type DEVICE_OBJECT_DATA = devObj_s;
extern "C" {
    pub fn Device_Init(object_table: *mut object_functions_t);
}
extern "C" {
    pub fn Device_Reinitialize(rd_data: *mut BACNET_REINITIALIZE_DEVICE_DATA) -> bool;
}
extern "C" {
    pub fn Device_Reinitialize_State_Set(state: BACNET_REINITIALIZED_STATE) -> bool;
}
extern "C" {
    pub fn Device_Reinitialized_State() -> BACNET_REINITIALIZED_STATE;
}
extern "C" {
    pub fn Device_Objects_RR_Info(object_type: BACNET_OBJECT_TYPE) -> rr_info_function;
}
extern "C" {
    pub fn Device_getCurrentDateTime(DateTime: *mut BACNET_DATE_TIME);
}
extern "C" {
    pub fn Device_UTC_Offset() -> i32;
}
extern "C" {
    pub fn Device_UTC_Offset_Set(offset: i16);
}
extern "C" {
    pub fn Device_Daylight_Savings_Status() -> bool;
}
extern "C" {
    pub fn Device_Align_Intervals() -> bool;
}
extern "C" {
    pub fn Device_Align_Intervals_Set(flag: bool) -> bool;
}
extern "C" {
    pub fn Device_Time_Sync_Interval() -> u32;
}
extern "C" {
    pub fn Device_Time_Sync_Interval_Set(value: u32) -> bool;
}
extern "C" {
    pub fn Device_Interval_Offset() -> u32;
}
extern "C" {
    pub fn Device_Interval_Offset_Set(value: u32) -> bool;
}
extern "C" {
    pub fn Device_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Device_Objects_Property_List(
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        pPropertyList: *mut special_property_list_t,
    );
}
extern "C" {
    pub fn Device_Encode_Value_List(
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Device_Value_List_Supported(object_type: BACNET_OBJECT_TYPE) -> bool;
}
extern "C" {
    pub fn Device_COV(object_type: BACNET_OBJECT_TYPE, object_instance: u32) -> bool;
}
extern "C" {
    pub fn Device_COV_Clear(object_type: BACNET_OBJECT_TYPE, object_instance: u32);
}
extern "C" {
    pub fn Device_Object_Instance_Number() -> u32;
}
extern "C" {
    pub fn Device_Set_Object_Instance_Number(object_id: u32) -> bool;
}
extern "C" {
    pub fn Device_Valid_Object_Instance_Number(object_id: u32) -> bool;
}
extern "C" {
    pub fn Device_Object_List_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Device_Object_List_Identifier(
        array_index: u32,
        object_type: *mut BACNET_OBJECT_TYPE,
        instance: *mut u32,
    ) -> bool;
}
extern "C" {
    pub fn Device_Object_List_Element_Encode(
        object_instance: u32,
        array_index: BACNET_ARRAY_INDEX,
        apdu: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Device_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Device_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Device_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Device_Set_Object_Name(object_name: *mut BACNET_CHARACTER_STRING) -> bool;
}
extern "C" {
    pub fn Device_Object_Name_Copy(
        object_type: BACNET_OBJECT_TYPE,
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Device_Object_Name_ANSI_Init(object_name: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn Device_Object_Name_ANSI() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_System_Status() -> BACNET_DEVICE_STATUS;
}
extern "C" {
    pub fn Device_Set_System_Status(
        status: BACNET_DEVICE_STATUS,
        local: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Device_Vendor_Name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_Vendor_Identifier() -> u16;
}
extern "C" {
    pub fn Device_Set_Vendor_Identifier(vendor_id: u16);
}
extern "C" {
    pub fn Device_Model_Name() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_Set_Model_Name(name: *const ::std::os::raw::c_char, length: usize) -> bool;
}
extern "C" {
    pub fn Device_Firmware_Revision() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_Application_Software_Version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_Set_Application_Software_Version(
        name: *const ::std::os::raw::c_char,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn Device_Description() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_Set_Description(name: *const ::std::os::raw::c_char, length: usize) -> bool;
}
extern "C" {
    pub fn Device_Location() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn Device_Set_Location(name: *const ::std::os::raw::c_char, length: usize) -> bool;
}
extern "C" {
    pub fn Device_Protocol_Version() -> u8;
}
extern "C" {
    pub fn Device_Protocol_Revision() -> u8;
}
extern "C" {
    pub fn Device_Segmentation_Supported() -> BACNET_SEGMENTATION;
}
extern "C" {
    pub fn Device_Database_Revision() -> u32;
}
extern "C" {
    pub fn Device_Set_Database_Revision(revision: u32);
}
extern "C" {
    pub fn Device_Inc_Database_Revision();
}
extern "C" {
    pub fn Device_Valid_Object_Name(
        object_name: *mut BACNET_CHARACTER_STRING,
        object_type: *mut BACNET_OBJECT_TYPE,
        object_instance: *mut u32,
    ) -> bool;
}
extern "C" {
    pub fn Device_Valid_Object_Id(object_type: BACNET_OBJECT_TYPE, object_instance: u32) -> bool;
}
extern "C" {
    pub fn Device_Read_Property(rpdata: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Device_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Device_Add_List_Element(
        list_element: *mut BACNET_LIST_ELEMENT_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Device_Remove_List_Element(
        list_element: *mut BACNET_LIST_ELEMENT_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DeviceGetRRInfo(pRequest: *mut BACNET_READ_RANGE_DATA, pInfo: *mut RR_PROP_INFO)
        -> bool;
}
extern "C" {
    pub fn Device_Read_Property_Local(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Device_Write_Property_Local(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Routing_Device_Init(first_object_instance: u32);
}
extern "C" {
    pub fn Add_Routed_Device(
        Object_Instance: u32,
        Object_Name: *mut BACNET_CHARACTER_STRING,
        Description: *const ::std::os::raw::c_char,
    ) -> u16;
}
extern "C" {
    pub fn Get_Routed_Device_Object(idx: ::std::os::raw::c_int) -> *mut DEVICE_OBJECT_DATA;
}
extern "C" {
    pub fn Get_Routed_Device_Address(idx: ::std::os::raw::c_int) -> *mut BACNET_ADDRESS;
}
extern "C" {
    pub fn routed_get_my_address(my_address: *mut BACNET_ADDRESS);
}
extern "C" {
    pub fn Routed_Device_Address_Lookup(
        idx: ::std::os::raw::c_int,
        address_len: u8,
        mac_adress: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Routed_Device_GetNext(
        dest: *mut BACNET_ADDRESS,
        DNET_list: *mut ::std::os::raw::c_int,
        cursor: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn Routed_Device_Is_Valid_Network(
        dest_net: u16,
        DNET_list: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn Routed_Device_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Routed_Device_Valid_Object_Instance_Number(object_id: u32) -> bool;
}
extern "C" {
    pub fn Routed_Device_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Routed_Device_Object_Instance_Number() -> u32;
}
extern "C" {
    pub fn Routed_Device_Set_Object_Instance_Number(object_id: u32) -> bool;
}
extern "C" {
    pub fn Routed_Device_Set_Object_Name(
        encoding: u8,
        value: *const ::std::os::raw::c_char,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn Routed_Device_Set_Description(
        name: *const ::std::os::raw::c_char,
        length: usize,
    ) -> bool;
}
extern "C" {
    pub fn Routed_Device_Inc_Database_Revision();
}
extern "C" {
    pub fn Routed_Device_Service_Approval(
        service: BACNET_SERVICES_SUPPORTED,
        service_argument: ::std::os::raw::c_int,
        apdu_buff: *mut u8,
        invoke_id: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Integer_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Integer_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Integer_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Integer_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Integer_Value_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Integer_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Integer_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Integer_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Integer_Value_Present_Value_Set(object_instance: u32, value: i32, priority: u8) -> bool;
}
extern "C" {
    pub fn Integer_Value_Present_Value(object_instance: u32) -> i32;
}
extern "C" {
    pub fn Integer_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Integer_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Integer_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Integer_Value_COV_Increment(instance: u32) -> f32;
}
extern "C" {
    pub fn Integer_Value_COV_Increment_Set(instance: u32, value: f32);
}
extern "C" {
    pub fn Integer_Value_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Integer_Value_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Integer_Value_Units(instance: u32) -> u16;
}
extern "C" {
    pub fn Integer_Value_Units_Set(instance: u32, unit: u16) -> bool;
}
extern "C" {
    pub fn Integer_Value_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Integer_Value_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn Integer_Value_Init();
}
extern "C" {
    pub fn Load_Control_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Load_Control_State_Machine_Handler();
}
extern "C" {
    pub fn Load_Control_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Load_Control_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Load_Control_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Load_Control_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Load_Control_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Load_Control_Init();
}
extern "C" {
    pub fn Load_Control_State_Machine(object_index: ::std::os::raw::c_int);
}
extern "C" {
    pub fn Load_Control_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Load_Control_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Life_Safety_Point_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Life_Safety_Point_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Life_Safety_Point_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Life_Safety_Point_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Life_Safety_Point_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Life_Safety_Point_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Life_Safety_Point_Init();
}
extern "C" {
    pub fn Life_Safety_Point_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Life_Safety_Point_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Multistate_Input_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Input_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Multistate_Input_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Input_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Multistate_Input_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Present_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Multistate_Input_Present_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Multistate_Input_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Out_Of_Service_Set(object_instance: u32, value: bool);
}
extern "C" {
    pub fn Multistate_Input_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Multistate_Input_Description_Set(
        object_instance: u32,
        text_string: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Multistate_Input_Reliability_Set(
        object_instance: u32,
        value: BACNET_RELIABILITY,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Input_State_Text_Set(
        object_instance: u32,
        state_index: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Max_States_Set(instance: u32, max_states_requested: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_State_Text(
        object_instance: u32,
        state_index: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Multistate_Input_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Input_Cleanup();
}
extern "C" {
    pub fn Multistate_Input_Init();
}
#[doc = " @brief Callback for gateway write present value request\n @param  object_instance - object-instance number of the object\n @param  old_value - multistate preset-value prior to write\n @param  value - multistate preset-value of the write"]
pub type multistate_output_write_present_value_callback =
    ::std::option::Option<unsafe extern "C" fn(object_instance: u32, old_value: u32, value: u32)>;
extern "C" {
    pub fn Multistate_Output_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Multistate_Output_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Output_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Multistate_Output_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Output_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Multistate_Output_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Present_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Multistate_Output_Present_Value_Set(
        object_instance: u32,
        value: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Present_Value_Relinquish(
        instance: u32,
        priority: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Present_Value_Priority(object_instance: u32)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Output_Write_Present_Value_Callback_Set(
        cb: multistate_output_write_present_value_callback,
    );
}
extern "C" {
    pub fn Multistate_Output_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Multistate_Output_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Out_Of_Service_Set(object_instance: u32, value: bool);
}
extern "C" {
    pub fn Multistate_Output_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Multistate_Output_Description_Set(
        object_instance: u32,
        text_string: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_State_Text_Set(
        object_instance: u32,
        state_index: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Max_States_Set(instance: u32, max_states_requested: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_State_Text(
        object_instance: u32,
        state_index: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Multistate_Output_State_Text_List_Set(
        object_instance: u32,
        state_text_list: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Multistate_Output_Reliability_Set(
        object_instance: u32,
        value: BACNET_RELIABILITY,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Relinquish_Default(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Multistate_Output_Relinquish_Default_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Output_Cleanup();
}
extern "C" {
    pub fn Multistate_Output_Init();
}
extern "C" {
    pub fn Multistate_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Multistate_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Multistate_Value_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Multistate_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Multistate_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Present_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn Multistate_Value_Present_Value_Set(object_instance: u32, value: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn Multistate_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Out_Of_Service_Set(object_instance: u32, value: bool);
}
extern "C" {
    pub fn Multistate_Value_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Multistate_Value_Description_Set(
        object_instance: u32,
        text_string: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Value_State_Text_Set(
        object_instance: u32,
        state_index: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Max_States_Set(instance: u32, max_states_requested: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_State_Text(
        object_instance: u32,
        state_index: u32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Multistate_Value_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Multistate_Value_Cleanup();
}
extern "C" {
    pub fn Multistate_Value_Init();
}
extern "C" {
    pub fn Network_Port_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Network_Port_Property_List(
        object_instance: u32,
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Network_Port_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Name_Set(
        object_instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Network_Port_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Reliability(object_instance: u32) -> BACNET_RELIABILITY;
}
extern "C" {
    pub fn Network_Port_Reliability_Set(object_instance: u32, value: BACNET_RELIABILITY) -> bool;
}
extern "C" {
    pub fn Network_Port_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn Network_Port_Out_Of_Service_Set(instance: u32, oos_flag: bool) -> bool;
}
extern "C" {
    pub fn Network_Port_Type(object_instance: u32) -> u8;
}
extern "C" {
    pub fn Network_Port_Type_Set(object_instance: u32, value: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_Network_Number(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Network_Port_Network_Number_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Network_Port_Quality(object_instance: u32) -> BACNET_PORT_QUALITY;
}
extern "C" {
    pub fn Network_Port_Quality_Set(object_instance: u32, value: BACNET_PORT_QUALITY) -> bool;
}
extern "C" {
    pub fn Network_Port_MAC_Address(
        object_instance: u32,
        mac_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_MAC_Address_Set(
        object_instance: u32,
        mac_src: *mut u8,
        mac_len: u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_APDU_Length(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Network_Port_APDU_Length_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Network_Port_MSTP_Max_Master(object_instance: u32) -> u8;
}
extern "C" {
    pub fn Network_Port_MSTP_Max_Master_Set(object_instance: u32, value: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_MSTP_Max_Info_Frames(object_instance: u32) -> u8;
}
extern "C" {
    pub fn Network_Port_MSTP_Max_Info_Frames_Set(object_instance: u32, value: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_Link_Speed(object_instance: u32) -> f32;
}
extern "C" {
    pub fn Network_Port_Link_Speed_Set(object_instance: u32, value: f32) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Address(
        object_instance: u32,
        ip_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Address_Get(
        object_instance: u32,
        a: *mut u8,
        b: *mut u8,
        c: *mut u8,
        d: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Address_Set(object_instance: u32, a: u8, b: u8, c: u8, d: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Subnet_Prefix(object_instance: u32) -> u8;
}
extern "C" {
    pub fn Network_Port_IP_Subnet_Prefix_Set(object_instance: u32, value: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Subnet(
        object_instance: u32,
        subnet_mask: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Subnet_Get(
        object_instance: u32,
        a: *mut u8,
        b: *mut u8,
        c: *mut u8,
        d: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Subnet_Set(object_instance: u32, a: u8, b: u8, c: u8, d: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Gateway(
        object_instance: u32,
        subnet_mask: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Gateway_Get(
        object_instance: u32,
        a: *mut u8,
        b: *mut u8,
        c: *mut u8,
        d: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_Gateway_Set(object_instance: u32, a: u8, b: u8, c: u8, d: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_DNS_Server(
        object_instance: u32,
        index: ::std::os::raw::c_uint,
        subnet_mask: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_DNS_Server_Get(
        object_instance: u32,
        index: ::std::os::raw::c_uint,
        a: *mut u8,
        b: *mut u8,
        c: *mut u8,
        d: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IP_DNS_Server_Set(
        object_instance: u32,
        index: ::std::os::raw::c_uint,
        a: u8,
        b: u8,
        c: u8,
        d: u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_BIP_Port(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Network_Port_BIP_Port_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Network_Port_BIP_Mode(object_instance: u32) -> BACNET_IP_MODE;
}
extern "C" {
    pub fn Network_Port_BIP_Mode_Set(object_instance: u32, value: BACNET_IP_MODE) -> bool;
}
extern "C" {
    pub fn Network_Port_BBMD_Accept_FD_Registrations(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Network_Port_BBMD_Accept_FD_Registrations_Set(object_instance: u32, value: bool)
        -> bool;
}
extern "C" {
    pub fn Network_Port_BBMD_BD_Table(object_instance: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Network_Port_BBMD_BD_Table_Set(
        object_instance: u32,
        bdt_head: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_BBMD_FD_Table(object_instance: u32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn Network_Port_BBMD_FD_Table_Set(
        object_instance: u32,
        fdt_head: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Remote_BBMD_IP_Address(
        object_instance: u32,
        a: *mut u8,
        b: *mut u8,
        c: *mut u8,
        d: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Remote_BBMD_IP_Address_Set(
        object_instance: u32,
        a: u8,
        b: u8,
        c: u8,
        d: u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Remote_BBMD_BIP_Port(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Network_Port_Remote_BBMD_BIP_Port_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Network_Port_Remote_BBMD_BIP_Lifetime(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Network_Port_Remote_BBMD_BIP_Lifetime_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Network_Port_BIP6_Mode(object_instance: u32) -> BACNET_IP_MODE;
}
extern "C" {
    pub fn Network_Port_BIP6_Mode_Set(object_instance: u32, value: BACNET_IP_MODE) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Address(
        object_instance: u32,
        ip_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Address_Set(object_instance: u32, ip_address: *mut u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Multicast_Address(
        object_instance: u32,
        ip_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Multicast_Address_Set(
        object_instance: u32,
        ip_address: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Subnet_Prefix(object_instance: u32) -> u8;
}
extern "C" {
    pub fn Network_Port_IPv6_Subnet_Prefix_Set(object_instance: u32, value: u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Gateway(
        object_instance: u32,
        ip_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Gateway_Set(object_instance: u32, ip_address: *mut u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_DNS_Server(
        object_instance: u32,
        dns_index: ::std::os::raw::c_uint,
        ip_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_DNS_Server_Set(
        object_instance: u32,
        dns_index: ::std::os::raw::c_uint,
        ip_address: *mut u8,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_DHCP_Server(
        object_instance: u32,
        ip_address: *mut BACNET_OCTET_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_DHCP_Server_Set(object_instance: u32, ip_address: *mut u8) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Zone_Index(
        object_instance: u32,
        zone_index: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_IPv6_Gateway_Zone_Index_Set(
        object_instance: u32,
        zone_index: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_BIP6_Port(object_instance: u32) -> u16;
}
extern "C" {
    pub fn Network_Port_BIP6_Port_Set(object_instance: u32, value: u16) -> bool;
}
extern "C" {
    pub fn Network_Port_Changes_Pending(instance: u32) -> bool;
}
extern "C" {
    pub fn Network_Port_Changes_Pending_Set(instance: u32, flag: bool) -> bool;
}
extern "C" {
    pub fn Network_Port_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Network_Port_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Network_Port_Index_To_Instance(find_index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Network_Port_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Network_Port_Object_Instance_Number_Set(
        index: ::std::os::raw::c_uint,
        object_instance: u32,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Read_Range_BDT(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Network_Port_Read_Range_FDT(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Network_Port_Read_Range(
        pRequest: *mut BACNET_READ_RANGE_DATA,
        pInfo: *mut RR_PROP_INFO,
    ) -> bool;
}
extern "C" {
    pub fn Network_Port_Create(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Network_Port_Delete(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Network_Port_Cleanup();
}
extern "C" {
    pub fn Network_Port_Init();
}
extern "C" {
    pub fn Network_Port_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Network_Port_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct object_device_t {
    pub Object_Identifier: BACNET_OBJECT_ID,
    pub Object_Name: BACNET_CHARACTER_STRING,
    pub Object_Type: BACNET_OBJECT_TYPE,
    pub System_Status: BACNET_DEVICE_STATUS,
    pub Vendor_Name: BACNET_CHARACTER_STRING,
    pub Vendor_Identifier: u16,
    pub Model_Name: BACNET_CHARACTER_STRING,
    pub Firmware_Revision: BACNET_CHARACTER_STRING,
    pub Application_Software_Version: BACNET_CHARACTER_STRING,
    pub Location: BACNET_CHARACTER_STRING,
    pub Description: BACNET_CHARACTER_STRING,
    pub Protocol_Version: u8,
    pub Protocol_Revision: u8,
    pub Protocol_Services_Supported: BACNET_BIT_STRING,
    pub Protocol_Object_Types_Supported: BACNET_BIT_STRING,
    pub Object_List: OS_Keylist,
    pub Max_APDU_Length_Accepted: u32,
    pub Segmentation_Supported: BACNET_SEGMENTATION,
    pub APDU_Timeout: u32,
    pub Number_Of_APDU_Retries: u8,
    pub Database_Revision: u32,
}
#[test]
fn bindgen_test_layout_object_device_t() {
    const UNINIT: ::std::mem::MaybeUninit<object_device_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<object_device_t>(),
        10456usize,
        concat!("Size of: ", stringify!(object_device_t))
    );
    assert_eq!(
        ::std::mem::align_of::<object_device_t>(),
        8usize,
        concat!("Alignment of ", stringify!(object_device_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Identifier) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Object_Identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Object_Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Type) as usize - ptr as usize },
        1488usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Object_Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).System_Status) as usize - ptr as usize },
        1492usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(System_Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Vendor_Name) as usize - ptr as usize },
        1496usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Vendor_Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Vendor_Identifier) as usize - ptr as usize },
        2976usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Vendor_Identifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Model_Name) as usize - ptr as usize },
        2984usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Model_Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Firmware_Revision) as usize - ptr as usize },
        4464usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Firmware_Revision)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).Application_Software_Version) as usize - ptr as usize
        },
        5944usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Application_Software_Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Location) as usize - ptr as usize },
        7424usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Description) as usize - ptr as usize },
        8904usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Protocol_Version) as usize - ptr as usize },
        10384usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Protocol_Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Protocol_Revision) as usize - ptr as usize },
        10385usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Protocol_Revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Protocol_Services_Supported) as usize - ptr as usize },
        10386usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Protocol_Services_Supported)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).Protocol_Object_Types_Supported) as usize - ptr as usize
        },
        10402usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Protocol_Object_Types_Supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_List) as usize - ptr as usize },
        10424usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Object_List)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Max_APDU_Length_Accepted) as usize - ptr as usize },
        10432usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Max_APDU_Length_Accepted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Segmentation_Supported) as usize - ptr as usize },
        10436usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Segmentation_Supported)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).APDU_Timeout) as usize - ptr as usize },
        10440usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(APDU_Timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Number_Of_APDU_Retries) as usize - ptr as usize },
        10444usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Number_Of_APDU_Retries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Database_Revision) as usize - ptr as usize },
        10448usize,
        concat!(
            "Offset of field: ",
            stringify!(object_device_t),
            "::",
            stringify!(Database_Revision)
        )
    );
}
pub type OBJECT_DEVICE_T = object_device_t;
extern "C" {
    pub fn objects_device_delete(index: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn objects_device_new(device_instance: u32) -> *mut OBJECT_DEVICE_T;
}
extern "C" {
    pub fn objects_device_by_instance(device_instance: u32) -> *mut OBJECT_DEVICE_T;
}
extern "C" {
    pub fn objects_device_data(index: ::std::os::raw::c_int) -> *mut OBJECT_DEVICE_T;
}
extern "C" {
    pub fn objects_device_count() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn objects_device_id(index: ::std::os::raw::c_int) -> u32;
}
extern "C" {
    pub fn objects_init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct octetstring_value_descr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Out_Of_Service: bool,
    pub Present_Value: BACNET_OCTET_STRING,
}
#[test]
fn bindgen_test_layout_octetstring_value_descr() {
    const UNINIT: ::std::mem::MaybeUninit<octetstring_value_descr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<octetstring_value_descr>(),
        1488usize,
        concat!("Size of: ", stringify!(octetstring_value_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<octetstring_value_descr>(),
        8usize,
        concat!("Alignment of ", stringify!(octetstring_value_descr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Out_Of_Service) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(octetstring_value_descr),
            "::",
            stringify!(Out_Of_Service)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present_Value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(octetstring_value_descr),
            "::",
            stringify!(Present_Value)
        )
    );
}
impl octetstring_value_descr {
    #[inline]
    pub fn Event_State(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Event_State(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Event_State: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let Event_State: u32 = unsafe { ::std::mem::transmute(Event_State) };
            Event_State as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type OCTETSTRING_VALUE_DESCR = octetstring_value_descr;
extern "C" {
    pub fn OctetString_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn OctetString_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn OctetString_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn OctetString_Value_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn OctetString_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn OctetString_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Present_Value_Set(
        object_instance: u32,
        value: *mut BACNET_OCTET_STRING,
        priority: u8,
    ) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Present_Value(object_instance: u32) -> *mut BACNET_OCTET_STRING;
}
extern "C" {
    pub fn OctetString_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn OctetString_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn OctetString_Value_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn OctetString_Value_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn OctetString_Value_Intrinsic_Reporting(object_instance: u32);
}
extern "C" {
    pub fn OctetString_Value_Init();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct positiveinteger_value_descr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Present_Value: u32,
    pub Units: u16,
}
#[test]
fn bindgen_test_layout_positiveinteger_value_descr() {
    const UNINIT: ::std::mem::MaybeUninit<positiveinteger_value_descr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<positiveinteger_value_descr>(),
        12usize,
        concat!("Size of: ", stringify!(positiveinteger_value_descr))
    );
    assert_eq!(
        ::std::mem::align_of::<positiveinteger_value_descr>(),
        4usize,
        concat!("Alignment of ", stringify!(positiveinteger_value_descr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present_Value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(positiveinteger_value_descr),
            "::",
            stringify!(Present_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Units) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(positiveinteger_value_descr),
            "::",
            stringify!(Units)
        )
    );
}
impl positiveinteger_value_descr {
    #[inline]
    pub fn Out_Of_Service(&self) -> bool {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Out_Of_Service(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Out_Of_Service: bool) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Out_Of_Service: u8 = unsafe { ::std::mem::transmute(Out_Of_Service) };
            Out_Of_Service as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type POSITIVEINTEGER_VALUE_DESCR = positiveinteger_value_descr;
extern "C" {
    pub fn PositiveInteger_Value_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn PositiveInteger_Value_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn PositiveInteger_Value_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn PositiveInteger_Value_Instance_To_Index(object_instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn PositiveInteger_Value_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Read_Property(
        rpdata: *mut BACNET_READ_PROPERTY_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn PositiveInteger_Value_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Present_Value_Set(
        object_instance: u32,
        value: u32,
        priority: u8,
    ) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Present_Value(object_instance: u32) -> u32;
}
extern "C" {
    pub fn PositiveInteger_Value_Change_Of_Value(instance: u32) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Change_Of_Value_Clear(instance: u32);
}
extern "C" {
    pub fn PositiveInteger_Value_Encode_Value_List(
        object_instance: u32,
        value_list: *mut BACNET_PROPERTY_VALUE,
    ) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Description(instance: u32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn PositiveInteger_Value_Description_Set(
        instance: u32,
        new_name: *mut ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Out_Of_Service(instance: u32) -> bool;
}
extern "C" {
    pub fn PositiveInteger_Value_Out_Of_Service_Set(instance: u32, oos_flag: bool);
}
extern "C" {
    pub fn PositiveInteger_Value_Intrinsic_Reporting(object_instance: u32);
}
extern "C" {
    pub fn PositiveInteger_Value_Init();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bacnet_obj_daily_schedule {
    pub Time_Values: [BACNET_TIME_VALUE; 8usize],
    pub TV_Count: u16,
}
#[test]
fn bindgen_test_layout_bacnet_obj_daily_schedule() {
    const UNINIT: ::std::mem::MaybeUninit<bacnet_obj_daily_schedule> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bacnet_obj_daily_schedule>(),
        200usize,
        concat!("Size of: ", stringify!(bacnet_obj_daily_schedule))
    );
    assert_eq!(
        ::std::mem::align_of::<bacnet_obj_daily_schedule>(),
        8usize,
        concat!("Alignment of ", stringify!(bacnet_obj_daily_schedule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Time_Values) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_obj_daily_schedule),
            "::",
            stringify!(Time_Values)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TV_Count) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(bacnet_obj_daily_schedule),
            "::",
            stringify!(TV_Count)
        )
    );
}
pub type BACNET_OBJ_DAILY_SCHEDULE = bacnet_obj_daily_schedule;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct schedule {
    pub Start_Date: BACNET_DATE,
    pub End_Date: BACNET_DATE,
    pub Weekly_Schedule: [BACNET_OBJ_DAILY_SCHEDULE; 7usize],
    pub Schedule_Default: BACNET_APPLICATION_DATA_VALUE,
    pub Present_Value: BACNET_APPLICATION_DATA_VALUE,
    pub Object_Property_References: [BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE; 4usize],
    pub obj_prop_ref_cnt: u8,
    pub Priority_For_Writing: u8,
    pub Out_Of_Service: bool,
}
#[test]
fn bindgen_test_layout_schedule() {
    const UNINIT: ::std::mem::MaybeUninit<schedule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<schedule>(),
        15152usize,
        concat!("Size of: ", stringify!(schedule))
    );
    assert_eq!(
        ::std::mem::align_of::<schedule>(),
        8usize,
        concat!("Alignment of ", stringify!(schedule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Start_Date) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Start_Date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).End_Date) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(End_Date)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Weekly_Schedule) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Weekly_Schedule)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Schedule_Default) as usize - ptr as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Schedule_Default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Present_Value) as usize - ptr as usize },
        8216usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Present_Value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Object_Property_References) as usize - ptr as usize },
        15016usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Object_Property_References)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj_prop_ref_cnt) as usize - ptr as usize },
        15144usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(obj_prop_ref_cnt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Priority_For_Writing) as usize - ptr as usize },
        15145usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Priority_For_Writing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Out_Of_Service) as usize - ptr as usize },
        15146usize,
        concat!(
            "Offset of field: ",
            stringify!(schedule),
            "::",
            stringify!(Out_Of_Service)
        )
    );
}
pub type SCHEDULE_DESCR = schedule;
extern "C" {
    pub fn Schedule_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Schedule_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Schedule_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Schedule_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Schedule_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Schedule_Init();
}
extern "C" {
    pub fn Schedule_Out_Of_Service_Set(object_instance: u32, value: bool);
}
extern "C" {
    pub fn Schedule_Out_Of_Service(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Schedule_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Schedule_Read_Property(rpdata: *mut BACNET_READ_PROPERTY_DATA) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Schedule_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Schedule_In_Effective_Period(desc: *mut SCHEDULE_DESCR, date: *mut BACNET_DATE) -> bool;
}
extern "C" {
    pub fn Schedule_Recalculate_PV(
        desc: *mut SCHEDULE_DESCR,
        wday: BACNET_WEEKDAY,
        time: *mut BACNET_TIME,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_error {
    pub usClass: u16,
    pub usCode: u16,
}
#[test]
fn bindgen_test_layout_tl_error() {
    const UNINIT: ::std::mem::MaybeUninit<tl_error> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_error>(),
        4usize,
        concat!("Size of: ", stringify!(tl_error))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_error>(),
        2usize,
        concat!("Alignment of ", stringify!(tl_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usClass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_error),
            "::",
            stringify!(usClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usCode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_error),
            "::",
            stringify!(usCode)
        )
    );
}
pub type TL_ERROR = tl_error;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_bits {
    pub ucLen: u8,
    pub ucStore: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_tl_bits() {
    const UNINIT: ::std::mem::MaybeUninit<tl_bits> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_bits>(),
        5usize,
        concat!("Size of: ", stringify!(tl_bits))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_bits>(),
        1usize,
        concat!("Alignment of ", stringify!(tl_bits))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucLen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_bits),
            "::",
            stringify!(ucLen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucStore) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_bits),
            "::",
            stringify!(ucStore)
        )
    );
}
pub type TL_BITS = tl_bits;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tl_data_record {
    pub tTimeStamp: bacnet_time_t,
    pub ucRecType: u8,
    pub ucStatus: u8,
    pub Datum: tl_data_record__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union tl_data_record__bindgen_ty_1 {
    pub ucLogStatus: u8,
    pub ucBoolean: u8,
    pub fReal: f32,
    pub ulEnum: u32,
    pub ulUValue: u32,
    pub lSValue: i32,
    pub Bits: TL_BITS,
    pub Error: TL_ERROR,
    pub fTime: f32,
}
#[test]
fn bindgen_test_layout_tl_data_record__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<tl_data_record__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_data_record__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(tl_data_record__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_data_record__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(tl_data_record__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucLogStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(ucLogStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucBoolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(ucBoolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fReal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(fReal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulEnum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(ulEnum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulUValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(ulUValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lSValue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(lSValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(Bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(Error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record__bindgen_ty_1),
            "::",
            stringify!(fTime)
        )
    );
}
#[test]
fn bindgen_test_layout_tl_data_record() {
    const UNINIT: ::std::mem::MaybeUninit<tl_data_record> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_data_record>(),
        24usize,
        concat!("Size of: ", stringify!(tl_data_record))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_data_record>(),
        8usize,
        concat!("Alignment of ", stringify!(tl_data_record))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tTimeStamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record),
            "::",
            stringify!(tTimeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucRecType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record),
            "::",
            stringify!(ucRecType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucStatus) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record),
            "::",
            stringify!(ucStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Datum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_data_record),
            "::",
            stringify!(Datum)
        )
    );
}
pub type TL_DATA_REC = tl_data_record;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tl_log_info {
    pub bEnable: bool,
    pub StartTime: BACNET_DATE_TIME,
    pub tStartTime: bacnet_time_t,
    pub StopTime: BACNET_DATE_TIME,
    pub tStopTime: bacnet_time_t,
    pub ucTimeFlags: u8,
    pub Source: BACNET_DEVICE_OBJECT_PROPERTY_REFERENCE,
    pub ulLogInterval: u32,
    pub bStopWhenFull: bool,
    pub ulRecordCount: u32,
    pub ulTotalRecordCount: u32,
    pub LoggingType: BACNET_LOGGING_TYPE,
    pub bAlignIntervals: bool,
    pub ulIntervalOffset: u32,
    pub bTrigger: bool,
    pub iIndex: ::std::os::raw::c_int,
    pub tLastDataTime: bacnet_time_t,
}
#[test]
fn bindgen_test_layout_tl_log_info() {
    const UNINIT: ::std::mem::MaybeUninit<tl_log_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tl_log_info>(),
        136usize,
        concat!("Size of: ", stringify!(tl_log_info))
    );
    assert_eq!(
        ::std::mem::align_of::<tl_log_info>(),
        8usize,
        concat!("Alignment of ", stringify!(tl_log_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bEnable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(bEnable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StartTime) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tStartTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(tStartTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StopTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(StopTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tStopTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(tStopTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ucTimeFlags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(ucTimeFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Source) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(Source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulLogInterval) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(ulLogInterval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bStopWhenFull) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(bStopWhenFull)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulRecordCount) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(ulRecordCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulTotalRecordCount) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(ulTotalRecordCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LoggingType) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(LoggingType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bAlignIntervals) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(bAlignIntervals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ulIntervalOffset) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(ulIntervalOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bTrigger) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(bTrigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iIndex) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(iIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tLastDataTime) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(tl_log_info),
            "::",
            stringify!(tLastDataTime)
        )
    );
}
pub type TL_LOG_INFO = tl_log_info;
extern "C" {
    pub fn Trend_Log_Property_Lists(
        pRequired: *mut *const ::std::os::raw::c_int,
        pOptional: *mut *const ::std::os::raw::c_int,
        pProprietary: *mut *const ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn Trend_Log_Valid_Instance(object_instance: u32) -> bool;
}
extern "C" {
    pub fn Trend_Log_Count() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Trend_Log_Index_To_Instance(index: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn Trend_Log_Instance_To_Index(instance: u32) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn Trend_Log_Object_Instance_Add(instance: u32) -> bool;
}
extern "C" {
    pub fn Trend_Log_Object_Name(
        object_instance: u32,
        object_name: *mut BACNET_CHARACTER_STRING,
    ) -> bool;
}
extern "C" {
    pub fn Trend_Log_Read_Property(rpdata: *mut BACNET_READ_PROPERTY_DATA)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Trend_Log_Write_Property(wp_data: *mut BACNET_WRITE_PROPERTY_DATA) -> bool;
}
extern "C" {
    pub fn Trend_Log_Init();
}
extern "C" {
    pub fn TL_Insert_Status_Rec(
        iLog: ::std::os::raw::c_int,
        eStatus: BACNET_LOG_STATUS,
        bState: bool,
    );
}
extern "C" {
    pub fn TL_Is_Enabled(iLog: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn TL_BAC_Time_To_Local(SourceTime: *mut BACNET_DATE_TIME) -> bacnet_time_t;
}
extern "C" {
    pub fn TL_Local_Time_To_BAC(DestTime: *mut BACNET_DATE_TIME, SourceTime: bacnet_time_t);
}
extern "C" {
    pub fn TL_encode_entry(
        apdu: *mut u8,
        iLog: ::std::os::raw::c_int,
        iEntry: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TL_encode_by_position(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TL_encode_by_sequence(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TL_encode_by_time(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TrendLogGetRRInfo(
        pRequest: *mut BACNET_READ_RANGE_DATA,
        pInfo: *mut RR_PROP_INFO,
    ) -> bool;
}
extern "C" {
    pub fn rr_trend_log_encode(
        apdu: *mut u8,
        pRequest: *mut BACNET_READ_RANGE_DATA,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn trend_log_timer(uSeconds: u16);
}
extern "C" {
    pub static mut Handler_Transmit_Buffer: [u8; 1502usize];
}
pub const BACNET_TSM_STATE_TSM_STATE_IDLE: BACNET_TSM_STATE = 0;
pub const BACNET_TSM_STATE_TSM_STATE_AWAIT_CONFIRMATION: BACNET_TSM_STATE = 1;
pub const BACNET_TSM_STATE_TSM_STATE_AWAIT_RESPONSE: BACNET_TSM_STATE = 2;
pub const BACNET_TSM_STATE_TSM_STATE_SEGMENTED_REQUEST: BACNET_TSM_STATE = 3;
pub const BACNET_TSM_STATE_TSM_STATE_SEGMENTED_CONFIRMATION: BACNET_TSM_STATE = 4;
pub type BACNET_TSM_STATE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BACnet_TSM_Data {
    pub RetryCount: u8,
    pub RequestTimer: u16,
    pub InvokeID: u8,
    pub state: BACNET_TSM_STATE,
    pub dest: BACNET_ADDRESS,
    pub npdu_data: BACNET_NPDU_DATA,
    pub apdu: [u8; 1502usize],
    pub apdu_len: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_BACnet_TSM_Data() {
    const UNINIT: ::std::mem::MaybeUninit<BACnet_TSM_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BACnet_TSM_Data>(),
        1556usize,
        concat!("Size of: ", stringify!(BACnet_TSM_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<BACnet_TSM_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(BACnet_TSM_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RetryCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(RetryCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RequestTimer) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(RequestTimer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).InvokeID) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(InvokeID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dest) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(dest)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npdu_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(npdu_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apdu) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(apdu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apdu_len) as usize - ptr as usize },
        1552usize,
        concat!(
            "Offset of field: ",
            stringify!(BACnet_TSM_Data),
            "::",
            stringify!(apdu_len)
        )
    );
}
pub type BACNET_TSM_DATA = BACnet_TSM_Data;
pub type tsm_timeout_function = ::std::option::Option<unsafe extern "C" fn(invoke_id: u8)>;
extern "C" {
    pub fn tsm_set_timeout_handler(pFunction: tsm_timeout_function);
}
extern "C" {
    pub fn tsm_transaction_available() -> bool;
}
extern "C" {
    pub fn tsm_transaction_idle_count() -> u8;
}
extern "C" {
    pub fn tsm_timer_milliseconds(milliseconds: u16);
}
extern "C" {
    pub fn tsm_free_invoke_id(invokeID: u8);
}
extern "C" {
    pub fn tsm_next_free_invokeID() -> u8;
}
extern "C" {
    pub fn tsm_invokeID_set(invokeID: u8);
}
extern "C" {
    pub fn tsm_set_confirmed_unsegmented_transaction(
        invokeID: u8,
        dest: *mut BACNET_ADDRESS,
        ndpu_data: *mut BACNET_NPDU_DATA,
        apdu: *mut u8,
        apdu_len: u16,
    );
}
extern "C" {
    pub fn tsm_get_transaction_pdu(
        invokeID: u8,
        dest: *mut BACNET_ADDRESS,
        ndpu_data: *mut BACNET_NPDU_DATA,
        apdu: *mut u8,
        apdu_len: *mut u16,
    ) -> bool;
}
extern "C" {
    pub fn tsm_invoke_id_free(invokeID: u8) -> bool;
}
extern "C" {
    pub fn tsm_invoke_id_failed(invokeID: u8) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uci_context {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ucix_init(config_file: *const ::std::os::raw::c_char) -> *mut uci_context;
}
extern "C" {
    pub fn ucix_init_path(
        path: *const ::std::os::raw::c_char,
        config_file: *const ::std::os::raw::c_char,
    ) -> *mut uci_context;
}
extern "C" {
    pub fn ucix_cleanup(ctx: *mut uci_context);
}
extern "C" {
    pub fn ucix_save(ctx: *mut uci_context);
}
extern "C" {
    pub fn ucix_save_state(ctx: *mut uci_context);
}
extern "C" {
    pub fn ucix_get_option(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        o: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucix_get_option_int(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        o: *const ::std::os::raw::c_char,
        def: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucix_add_section(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        t: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ucix_add_option(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        o: *const ::std::os::raw::c_char,
        t: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ucix_add_option_int(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        o: *const ::std::os::raw::c_char,
        t: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ucix_commit(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucix_revert(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        o: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ucix_del(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
        o: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn ucix_for_each_section_type(
        ctx: *mut uci_context,
        p: *const ::std::os::raw::c_char,
        t: *const ::std::os::raw::c_char,
        cb: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_char,
                arg2: *mut ::std::os::raw::c_void,
            ),
        >,
        priv_: *mut ::std::os::raw::c_void,
    );
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
